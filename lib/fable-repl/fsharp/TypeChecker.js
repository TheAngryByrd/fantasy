import { wrapModuleOrNamespaceType, ValCopyFlag, copyModuleOrNamespaceType, TyconRefMap, ComputeRemappingFromInferredSignatureToExplicitSignature, CollectTyparsNoCaching, freeInVal, ensureCcuHasModuleOrNamespaceAtPath, typarsAEquiv, tyconOrder, reduceTyconRefAbbrevMeasureable, reduceTyconRefAbbrev, CanHaveUseNullAsTrueValueAttribute, TyconHasUseNullAsTrueValueAttribute, superOfTycon, isClassTy, TypeNullIsExtraValue, TryFindFSharpInt32Attribute, ModuleNameIsMangled, $7C$SpecialNotEquatableHeadType$7C$_$7C$ as _SpecialNotEquatableHeadType___, $7C$SpecialEquatableHeadType$7C$_$7C$ as _SpecialEquatableHeadType___, TryFindFSharpBoolAttribute, $7C$SpecialComparableHeadType$7C$_$7C$ as _SpecialComparableHeadType___, Entity$2E$HasOverride as Entity_HasOverride, Entity$2E$HasInterface as Entity_HasInterface, generalizeTyconRef, freeInTypesLeftToRight, freeInTypes, mkInvisibleLet, mkTypeChoose, emptyFreeVars, CollectLocalsNoCaching, freeInExpr, unionFreeVars, ExprRewritingEnv, RewriteExpr, mkRecdFieldGetAddrViaExprAddr, mkStaticRecdFieldGetAddr, MakeApplicationAndBetaReduce, AdjustValForExpectedArity, mkInt, valOrder, fullDisplayTextOfModRef, EntityRef$2E$HasInterface as EntityRef_HasInterface, useGenuineField, emptyFreeTypars, mkGenericBindRhs, TypeEquivEnv, SignatureRepackageInfo, PartitionValTyparsForApparentEnclosingType, mkMemberLambdas, mkILAsmClt, mkIfThen, mkCallFailStaticInit, mkCallFailInit, accFreeInTypes, isInterfaceTyconRef, LinearizeTopMatch, InferArityOfExprBinding, AdjustValToTopVal, mkSequential, mkTypeLambda, tryDestRefTupleExpr, $7C$ExprValWithPossibleTypeInst$7C$_$7C$ as _ExprValWithPossibleTypeInst___, $7C$InnerExprPat$7C$ as _InnerExprPat_, ComputeFieldName, TryDecodeILAttribute, EvalLiteralExprOrAttribArg, ActivePatternInfo$2E$ResultType as ActivePatternInfo_ResultType, mkCallArrayLength, mkInt32, mkArrayElemAddress, mkNullTest, isStringTy, mkNativePtrTy, mkRefTupledVarsTy, mkLetsBind, mkCompGenBind, mkUnionCaseFieldGetUnprovenViaExprAddr, mkNoneCase, mkSomeCase, fspec_Missing_Value, mkValAddr, $7C$ByrefTy$7C$_$7C$ as _ByrefTy___, $7C$NullableTy$7C$_$7C$ as _NullableTy___, mkCallLiftValueWithDefn, isQuotedExprTy, mkCallQuoteToLinqLambdaExpression, destLinqExpressionTy, isLinqExpressionTy, mkFunTy, mkCallCreateEvent, mkIEventType, slotSigHasVoidReturnTy, mkRecdFieldGet, mkStaticRecdFieldGet, mkStaticRecdFieldSet, mkValSet, mkAddrSet, mkLambdas, stripTyEqns, mkChoiceCaseRef, mkCallSeqSingleton, mkCond, mkCallSeqMap, mkApps, ArgInfosOfMember, $7C$AttribBoolArg$7C$_$7C$ as _AttribBoolArg___, $7C$ExtractAttribNamedArg$7C$_$7C$ as _ExtractAttribNamedArg___, $7C$AttribStringArg$7C$_$7C$ as _AttribStringArg___, mkQuotedExprTy, mkRawQuotedExprTy, mkLdlen, mkDecr, mkZero, mkLdelem, destArrayTy, mkCallNewFormat, mkPrintfFormatTy, mkString, mkObjExpr, isRecdTy, op_PlusMinusGreater, mkMethodTy, mkRecordExpr, fullDisplayTextOfTyconRef, mkRecdFieldGetViaExprAddr, actualTyOfRecdFieldForTycon, destAppTy, mkCallCreateInstance, TryFindTyconRefStringAttribute, mkExnCaseFieldSet, isExnFieldMutable, mkUnionCaseFieldSet, isUnionCaseFieldMutable, mkExnCaseFieldGet, mkUnionCaseFieldGetUnproven, primMkCond, mkDefault, mkTryFinally, mkTryWith, mkCallSeq, mkCallSeqToList, mkCallSeqToArray, mkFastForLoop, mkLocal, mkWhile, mkNil, mkCons, mkAnyTupled, mkRefTupled, mkNull, mkCallUnbox, mkCallTypeTest, mkMultiLambda, mkLet, isAbstractTycon, mkThrow, actualTyOfRecdField, mkListTy, mkArrayType, ActivePatternInfo$2E$OverallType as ActivePatternInfo_OverallType, ActivePatternInfo$2E$get_Names as ActivePatternInfo_get_Names, destOptionTy, isUnitTy, isOptionTy, mkByteArrayTy, isAppTy, helpEnsureTypeHasMetadata, mkArrayTy, $7C$AppTy$7C$_$7C$ as _AppTy___, IsMatchingFSharpAttribute, mkOptionTy, GetTopTauTypeInFSharpForm, GetTopValTypeInCompiledForm, mkReraise, mkCompGenSequential, destFunTy, mkLazyOr, mkLazyAnd, mkMultiLambdas, mkLetBind, mkOne, mkRefCellSet, mkGetArg0, stripTopLambda, mkBind, mkLazyForce, mkLazyDelayed, mkLazyTy, mkInvisibleBind, stripExpr, ValHash, mkCallSeqFinally, mkCallSeqGenerated, mkCallSeqAppend, mkCallSeqDelay, mkCallSeqUsing, mkCallSeqCollect, mkCoerceIfNeeded, mkCallSeqEmpty, mkCallSeqOfFunctions, isArray1DTy, mkRefCell, mkMutableCompGenLocal, isObjTy, mkAndSimplifyMatch, mkRecdFieldSetViaExprAddr, mkAsmExpr, mkExprAddrOfExpr, mkIsInstConditional, exprForVal as exprForVal_4, Mutates, mkUnit, getErasedTypes, isMeasureTy, Erasure, stripTyEqnsWrtErasure, isErasedType, isTyparTy, mkRefTupledTy, mkIteratedFunTy, mkCoerceExpr, isSealedTy, applyTys, isForallTy, valRefEq, mkTyAppExpr, mkRefCellGet, mkCallCheckThis, destRefCellTy, exprForValRef, isRefCellTy, destByrefTy, mkAddrGet, isByrefTy, mkByrefTy, CompileAsEvent, tryDestTyparTy, TypeSatisfiesNullConstraint, tryDestRefTupleTy, stripFunTy, accFreeInTypars, unionFreeTypars, isDelegateTy, HasFSharpAttribute, isExnAllocObservable, isRecdOrUnionOrStructTyconRefAllocObservable, isUnionCaseRefAllocObservable, unionFreeLocals, unionFreeTycons, typarOrder, mkExnExpr, mkUnionCaseExpr, actualTysOfUnionCaseFields, mkTyparInst, actualResultTyOfUnionCase, recdFieldsOfExnDefRef, recdFieldTysOfExnDefRef, GetFSharpViewOfReturnType, argsOfAppTy, instType, tryDestForallTy, AllowTypeDirectedDetupling, InferArityOfExpr, freeInTypeLeftToRight, NormalizeDeclaredTyparsForEquiRecursiveInference, isAnyParTy, primMkApp, generalizeTypars, mkRefCellTy, isFSharpObjModelTy, tryDestAppTy, isStructTy, TryFindFSharpStringAttribute, $7C$AttribInt32Arg$7C$_$7C$ as _AttribInt32Arg___, TryFindFSharpAttribute, MemberIsExplicitImpl, ValRefIsExplicitImpl, tryMkForallTy, TypeScheme, tcrefOfAppTy, qualifiedMangledNameOfTyconRef, MemberIsCompiledAsInstance, isInterfaceTy, domainOfFunTy, isFunTy, ProdMeasures, isArrayTy, isListTy, mkSeqTy, Expr$2E$get_Range as Expr_get_Range, op_MinusMinusGreater, tryDestFunTy, destStructTupleTy, isStructTupleTy, destRefTupleTy, isRefTupleTy, wrapModuleOrNamespaceExprInNamespace, wrapModuleOrNamespaceTypeInNamespace, tryNormalizeMeasureInType, ValMultiMap, emptyTyparInst, emptyFreeTyvars, accFreeInType, CollectAllNoCaching, freeInType as freeInType_1, emptyFreeLocals, emptyFreeTycons, isAnyTupleTy, generalizedTyconRef, tyconRefEq, mkAppTy, typeEquiv, DisplayEnv, tyOfExpr, mkLambda as mkLambda_1, mkCompGenLet, mkCompGenLocal, HasFSharpAttributeOpt } from "./TastOps";
import { PatternValBinding, ActionOnFailure, TypedMatchClause, CompilePattern, Pattern } from "./PatternMatchCompilation";
import { unzip3, singleton as singleton_1, initialize, mapIndexed, concat, unzip, choose as choose_1, collect, partition, filter, reverse, append, map as map_1, ofArray } from "../fable-core/List";
import List from "../fable-core/List";
import { trimRangeToLine, range0, range, unionRanges } from "./range";
import { setType } from "../fable-core/Symbol";
import _Symbol from "../fable-core/Symbol";
import { GenericParam, hasInterface, compare, compareUnions, comparePrimitives, equals, Unit, Function as _Function, Array as _Array, Tuple, Any, Interface, makeGeneric, Option, equalsRecords } from "../fable-core/Util";
import { TypedImplFile, ModuleOrNamespaceExprWithSig, mkNonLocalTyconRef, ModuleOrNamespaceBinding, CombineCcuContentFragments, stripUnitEqns, stripTyparEqns, mkUnionCaseRef, MakeUnionRepr, TyconObjModelKind, NewTycon, NewModuleOrNamespace, ExceptionInfo, NewExn, $7C$ValDeref$7C$ as _ValDeref_, TyconObjModelData, TyconRepresentation, MakeRecdFieldsTable, typesOfVals, NewUnionCase, ModuleOrNamespaceExpr, typarRefEq, AttribKind, AttribNamedArg, AttribExpr, StaticOptimization, Duplicate, ccuEq, ccuOfTyconRef, ObjExprMethod, SpecialWhileLoopMarker, TOp, NewTypar, UndefinedName, TraitConstraintInfo, TyparConstraint, NewFreeVarsCache, SequentialOpKind, Binding as Binding_1, valEq, DecisionTreeTarget, copyTypars, typarEq, ValUseFlag, mkRecdFieldRef, NewRecdField, Accessibility, globalNng, ValRecursiveScopeInfo, ValMutability, NewVal, ParentRef, combineAccess, taccessPublic, taccessInternal, taccessPrivate, MaybeLazy, mkNonLocalEntityRef, Expr, ValBaseOrThisInfo, ValInline, Attrib, SlotSig, ValMemberInfo, ValReprInfoModule, ValReprInfo, ArgReprInfo, Const, TyparDynamicReq, TyparRigidity, TyparKind, Measure, tupInfoStruct, tupInfoRef, compPathOfCcu, CcuThunk, mkTyparTy, mkLocalModRef, mkNonLocalCcuRootEntityRef, mkLocalTyconRef, mkLocalEntityRef, mkLocalValRef, typeOfVal, RecordConstructionInfo, ModuleOrNamespaceKind, NewEmptyModuleOrNamespaceType, compPathInternal, CompilationPath, Entity, RecdField, Typar, Val, RecdFieldRef, EntityRef, ValRef, TType } from "./tast";
import { SynTypeDefnRepr, SynTypeDefn, textOfLid, SynModuleDecl, PreXmlDoc, SynTypeDefnSigRepr, SynTypeDefnSig, SynModuleSigDecl, $7C$SynPatForNullaryArgs$7C$_$7C$ as _SynPatForNullaryArgs___, $7C$SynPatForConstructorDecl$7C$_$7C$ as _SynPatForConstructorDecl___, mkSynAssign, mkSynBinding, SynReturnInfo, SynConstructorArgs, SynTypeDefnKind, NonVirtualMemberFlags, SynArgInfo, ClassCtorMemberFlags, CtorMemberFlags, StaticMemberFlags, SynTypar, SequencePointInfoForForLoop, mkSynSimplePatVar, SimplePatsOfPat, mkSynBifix, arbExpr, mkSynId, mkSynIdGet, mkSynDelay, SequencePointInfoForFinally, SequencePointInfoForTry, SequencePointInfoForWhileLoop, OverrideMemberFlags, mkSynThisPatVar, synExprContainsError, SynMatchClause, mkSynPrefix, $7C$SynPatErrorSkip$7C$ as _SynPatErrorSkip_, rangeOfLid, SynSimplePat, SynSimplePatAlternativeIdInfo, SynTypeDefnSimpleRepr, SynComponentInfo, SynBinding, SynMemberDefn, SynType, SequencePointInfoForSeq, SeqExprOnly, mkSynTrifix, mkSynInfix, SequencePointInfoForTarget, $7C$SynExprParen$7C$_$7C$ as _SynExprParen___, $7C$LongOrSingleIdent$7C$_$7C$ as _LongOrSingleIdent___, mkSynLidGet, $7C$SingleIdent$7C$_$7C$ as _SingleIdent___, noInferredTypars, mkSynApp1, inferredTyparDecls, SynConst, MemberFlags, mkSynPatVar, PushCurriedPatternsToExpr, SynBindingKind, SynValTyparDecls, SynValData, SynPat, PushPatternToExpr, SynExpr, SynBindingReturnInfo, SynSimplePats, ident, arrPathOfLid, SequencePointInfoForBinding, XmlDoc, SynAccess, SynInfo, MemberKind as MemberKind_2, mkSynUnit, pathToSynLid, LongIdentWithDots, SynAttribute, SynValInfo, TyparStaticReq, FsiDynamicModulePrefix, pathOfLid, NiceNameGenerator, SynArgNameGenerator, Ident } from "./ast";
import { TcGlobals } from "./TcGlobals";
import { MakeSlotParam, RecdFieldInfo, MakeSlotSig, ExistsSameHeadTypeInHierarchy, ReflectedArgInfo, OptionalArgCallerSideValue, HasHeadType, MethInfosEquivByNameAndSig, CallerInfoInfo, nonStandardEventError, GettersOfPropInfos, SettersOfPropInfos, UnionCaseInfo, GetSuperTypeOfType, FoldPrimaryHierarchyOfType, FindDelegateTypeOfPropertyEvent, BadEventTransformation, CompiledSigOfMeth, FixupNewTypars, AllowMultiIntfInstantiations, ExistsInEntireHierarchyOfType, MethInfo } from "./infos";
import { makeSome, defaultArg, getValue } from "../fable-core/Option";
import { PossibleUnverifiableCode, ReportedError, ErrorWithSuggestions, conditionallySuppressErrorReporting, suppressErrorReporting, NoSuggestions, errorRecovery, ErrorLoggerExtensions, ErrorD, TryD, RaiseOperationResult, Deprecated, NumberedError, errorR, InternalError, warning, CommitOperationResult, Error as _Error, error as error_1 } from "./ErrorLogger";
import { SR } from "../codegen/FSComp";
import { CheckPropInfoAttributes, TryBindMethInfoAttribute, TryFindMethInfoStringAttribute, CheckValAttributes, CheckUnionCaseAttributes, CheckEntityAttributes, CheckFSharpAttributes, CheckMethInfoAttributes, CheckILFieldAttributes, CheckRecdFieldInfoAttributes } from "./AttributeChecking";
import { IsTypeAccessible, IsMethInfoAccessible, CheckValAccessible, CheckUnionCaseAccessible, CheckTyconAccessible, CheckRecdFieldAccessible, IsTypeAndMethInfoAccessible, AccessorDomain, CheckILFieldInfoAccessible, CheckRecdFieldInfoAccessible } from "./AccessibilityLogic";
import { TypeDefinitelySubsumesTypeNoCoercion, CanCoerce, TypeFeasiblySubsumesType } from "./TypeRelations";
import { ArgumentAnalysis, AssignedCalledArg, CoerceFromFSharpFuncToDelegate, ExamineMethodForLambdaPropagation, CalledMeth, CallerNamedArg, CallerArg as CallerArg_1, BuildNewDelegateExpr, BuildObjCtorCall, BuildMethodCall, IsBaseCall } from "./MethodCalls";
import { Map as _Map_1, Set as _Set } from "../utils/TaggedCollections";
import { LookupTypeNameInEnvNoArity, LookupKind, ResolveLongIdentInType, AddActivePatternResultTagsToNameEnv, ResolveExprDotLongIdentAndComputeRange, ResolveLongIdentAsExprAndComputeRange, TypeNameResolutionFlag, TemporarilySuspendReportingTypecheckResultsToSink, AddFakeNameToNameEnv, ResolveObjectConstructor, AllPropInfosOfTypeInScope, CallExprHasTypeSink, ArgumentContainer, TryFindPatternByName, ResolveTypeLongIdentInTyconRef, CheckForDuplicateTyparFlag, ResolveExprLongIdent, AllMethInfosOfTypeInScope, TypeNameResolutionInfo, WarnOnUpperFlag, ResolvePatternLongIdent, FreshenRecdFieldRef, ResolveField, WithNewTypecheckResultsSink, AddFakeNamedValRefToNameEnv, PermitDirectReferenceToGeneratedType, TypeNameResolutionStaticArgsInfo, ResolveTypeLongIdent, AfterResolution, OpenDeclaration, FullyQualifiedFlag, ResultCollectionSettings, ResolveLongIndentAsModuleOrNamespace, NameResolver, TcResultsSink, AddDeclaredTyparsToNameEnv, AddModuleOrNamespaceRefToNameEnv, ItemOccurence, CallNameResolutionSink, Item, AddModuleAbbrevToNameEnv, AddModuleOrNamespaceRefsToNameEnv, CallOpenDeclarationSink, AddModulesAndNamespacesContentsToNameEnv, AddTyconRefsToNameEnv, BulkAdd, AddExceptionDeclsToNameEnv, CallEnvSink, AddValRefToNameEnv, NameResolutionEnv } from "./NameResolution";
import { ErrorFromApplyingDefault, SolveTyparEqualsTyp, CheckDeclaredTypars, ResolveOverloading, AddCxTypeMustSubsumeTypeMatchingOnlyUndoIfFailed, UnifyUniqueOverloading, BakedInTraitConstraintNames, SolveTypEqualsTypKeepAbbrevs, NewErrorMeasure, NewErrorType, AddConstraint, AddCxMethodConstraint, AddCxTypeMustSupportDefaultCtor, AddCxTypeIsDelegate, AddCxTypeIsEnum, AddCxTypeIsUnmanaged, AddCxTypeIsValueType, AddCxTypeIsReferenceType, AddCxTypeMustSupportEquality, AddCxTypeMustSupportComparison, AddCxTypeMustSupportNull, AddCxTypeMustSubsumeTypeUndoIfFailed, FreshenMethInfo, AddCxTypeMustSubsumeType, EliminateConstraintsForGeneralizedTypars, SimplifyMeasuresInTypeScheme, ErrorFromAddingConstraint, OptionalTrace, CanonicalizeRelevantMemberConstraints, MakeConstraintSolverEnv, ChooseTyparSolutionAndSolve, FreshenTypeInst, NewAnonTypar, AddCxTypeEqualsTypeUndoIfFailed, NewInferenceType, NewInferenceTypes, AddCxTypeEqualsType, FreshenAndFixupTypars, FreshenTypars, ConstraintSolverState, ContextInfo } from "./ConstraintSolver";
import { ZsetModule } from "../absil/zset";
import { QueueListModule } from "./QueueList";
import { EventuallyModule, eventually, String as _String, LazyWithContext, ResultOrException, NameMultiMapModule, List as List_1, ResultOrExceptionModule, NameMapModule } from "../absil/illib";
import { tryHead, iterateIndexed, choose as choose_2, sortWith, sumBy, skipWhile, takeWhile, tryPick, map2, sum, find, reduce, zip3, replicate, tryFindIndex, last, empty, append as append_1, zip, range as range_1, singleton, collect as collect_1, mapFold, iterate2, item as item_6, map as map_2, delay, toList, tryFind, forAll2, iterate, forAll, fold, exists as exists_1, foldBack } from "../fable-core/Seq";
import { fold as fold_1, tryGetValue, groupBy, map as map_4, iterate as iterate_1, remove, tryFind as tryFind_1, create, add as add_1, foldBack as foldBack_1, isEmpty } from "../fable-core/Map";
import _Map from "../fable-core/Map";
import { Microsoft, System } from "../fcs-fable/adapters";
import { ImportMap } from "./import";
import { TryFindPropInfo, TryFindIntrinsicMethInfo, ArgsTypOfEventInfo, GetSigOfFunctionForDelegate, IsIndexerType, FindMemberFlag, InfoReader } from "./InfoReader";
import { indexOfAny, printf, toText, join, replace, isNullOrEmpty, startsWith } from "../fable-core/String";
import { progress, mapFoldFst, Zset, NameSetModule, Graph, bufs, ListSet, p23 } from "./lib";
import { opNameNil, IllegalCharactersInTypeAndNamespaceNames, ActivePatternInfoOfValName, IsPrefixOperator, CompilerGeneratedName, CompileOpName, IsCompilerGeneratedName, opNameNullableEqualsNullable, opNameNullableEquals, opNameEqualsNullable, opNameCons, $7C$Control$7C$Equality$7C$Relational$7C$Indexer$7C$FixedTypes$7C$Other$7C$ as _Control_Equality_Relational_Indexer_FixedTypes_Other_, IsTernaryOperator, DecompileOpName, IsInfixOperator, IsMangledOpName, ChopPropertyName, opNameEquals } from "./PrettyNaming";
import { stringOfMethInfo, minimalStringOfType, outputQualifiedValSpec, prettyStringOfTy } from "./NicePrint";
import { intToRational, DivRational, NegRational } from "./rational";
import { fromString, fromBits } from "../fable-core/Long";
import CurriedLambda from "../fable-core/CurriedLambda";
import Comparer from "../fable-core/Comparer";
import { splitNamespace, ILArrayShape, ILReadonly, ILBasicType, ILType, mkILCtorMethSpecForTy, mkILNonGenericBoxedTy, ILFieldInit, mkNormalLdsfld, mkNormalStsfld, mkNormalStfld, ILInstr, mkNormalLdfld, mkILNamedTy, mkILFieldSpec, ILBoxity } from "../absil/il";
import { map as map_3 } from "../fable-core/Array";
import { FinalTypeDefinitionChecksAtEndOfInferenceScope, GetAbstractPropInfosForSynPropertyDecl, GetAbstractMethInfosForSynMethodDecl, DispatchSlotChecking, SlotImplSet } from "./MethodOverrides";
import { distinct, filter as filter_1, addInPlace, add as add_2, create as create_1 } from "../fable-core/Set";
import _Set_1 from "../fable-core/Set";
import { ParseFormatString } from "./CheckFormatStrings";
import { parse } from "../fable-core/Int32";
import Choice from "../fable-core/Choice";
import Lazy from "../fable-core/Lazy";
import { CheckNamesOfModuleOrNamespace, Checker } from "./SignatureConformance";
import { ZmapModule } from "../absil/zmap";
import { MakeBindingsForEqualsAugmentation, MakeValsForEqualsAugmentation, MakeBindingsForEqualityWithComparerAugmentation, MakeBindingsForCompareWithComparerAugmentation, MakeBindingsForCompareAugmentation, MakeValsForEqualityWithComparerAugmentation, TyconIsCandidateForAugmentationWithEquals, MakeValsForCompareWithComparerAugmentation, MakeValsForCompareAugmentation, TyconIsCandidateForAugmentationWithCompare } from "./AugmentWithHashCompare";
import { dprintn } from "../absil/ildiag";
import { UnsolvedTyparsOfModuleDef } from "./FindUnsolved";
import { CheckTopImpl } from "./PostInferenceChecks";
export function isThreadOrContextStatic(g, attrs) {
  if (HasFSharpAttributeOpt(g, g.attrib_ThreadStaticAttribute, attrs)) {
    return true;
  } else {
    return HasFSharpAttributeOpt(g, g.attrib_ContextStaticAttribute, attrs);
  }
}
export function mkNilListPat(g, m, ty) {
  return new Pattern(6, [g.nil_ucref, ofArray([ty]), new List(), m]);
}
export function mkConsListPat(g, ty, ph, pt) {
  return new Pattern(6, [g.cons_ucref, ofArray([ty]), ofArray([ph, pt]), unionRanges(ph.Range, pt.Range)]);
}
export function mkCompGenLetIn(m, nm, ty, e, f) {
  const patternInput = mkCompGenLocal(m, nm, ty);
  return mkCompGenLet(m, patternInput[0], e, f([patternInput[0], patternInput[1]]));
}
export function mkUnitDelayLambda(g, m, e) {
  const patternInput = mkCompGenLocal(m, "unitVar", g.unit_ty);
  return mkLambda_1(m, patternInput[0], e, tyOfExpr(g, e));
}
export class BakedInMemberConstraintName extends Error {
  constructor(data0, data1) {
    super();
    Object.setPrototypeOf(this, BakedInMemberConstraintName.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.BakedInMemberConstraintName",
      interfaces: ["FSharpException"],
      properties: {
        Data0: "string",
        Data1: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.BakedInMemberConstraintName", BakedInMemberConstraintName);
export class FunctionExpected extends Error {
  constructor(data0, data1, data2) {
    super();
    Object.setPrototypeOf(this, FunctionExpected.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.FunctionExpected",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.FunctionExpected", FunctionExpected);
export class NotAFunction extends Error {
  constructor(data0, data1, data2, data3) {
    super();
    Object.setPrototypeOf(this, NotAFunction.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.NotAFunction",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: range,
        Data3: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.NotAFunction", NotAFunction);
export class NotAFunctionButIndexer extends Error {
  constructor(data0, data1, data2, data3, data4) {
    super();
    Object.setPrototypeOf(this, NotAFunctionButIndexer.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
    this.Data4 = data4;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.NotAFunctionButIndexer",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: Option("string"),
        Data3: range,
        Data4: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.NotAFunctionButIndexer", NotAFunctionButIndexer);
export class Recursion extends Error {
  constructor(data0, data1, data2, data3, data4) {
    super();
    Object.setPrototypeOf(this, Recursion.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
    this.Data4 = data4;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.Recursion",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: Ident,
        Data2: TType,
        Data3: TType,
        Data4: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.Recursion", Recursion);
export class RecursiveUseCheckedAtRuntime extends Error {
  constructor(data0, data1, data2) {
    super();
    Object.setPrototypeOf(this, RecursiveUseCheckedAtRuntime.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.RecursiveUseCheckedAtRuntime",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: ValRef,
        Data2: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.RecursiveUseCheckedAtRuntime", RecursiveUseCheckedAtRuntime);
export class LetRecEvaluatedOutOfOrder extends Error {
  constructor(data0, data1, data2, data3) {
    super();
    Object.setPrototypeOf(this, LetRecEvaluatedOutOfOrder.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.LetRecEvaluatedOutOfOrder",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: ValRef,
        Data2: ValRef,
        Data3: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.LetRecEvaluatedOutOfOrder", LetRecEvaluatedOutOfOrder);
export class LetRecCheckedAtRuntime extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, LetRecCheckedAtRuntime.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.LetRecCheckedAtRuntime",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.LetRecCheckedAtRuntime", LetRecCheckedAtRuntime);
export class LetRecUnsound extends Error {
  constructor(data0, data1, data2) {
    super();
    Object.setPrototypeOf(this, LetRecUnsound.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.LetRecUnsound",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: makeGeneric(List, {
          T: ValRef
        }),
        Data2: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.LetRecUnsound", LetRecUnsound);
export class TyconBadArgs extends Error {
  constructor(data0, data1, data2, data3) {
    super();
    Object.setPrototypeOf(this, TyconBadArgs.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2 | 0;
    this.Data3 = data3;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.TyconBadArgs",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: EntityRef,
        Data2: "number",
        Data3: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.TyconBadArgs", TyconBadArgs);
export class UnionCaseWrongArguments extends Error {
  constructor(data0, data1, data2, data3) {
    super();
    Object.setPrototypeOf(this, UnionCaseWrongArguments.prototype);
    this.Data0 = data0;
    this.Data1 = data1 | 0;
    this.Data2 = data2 | 0;
    this.Data3 = data3;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.UnionCaseWrongArguments",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: "number",
        Data2: "number",
        Data3: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.UnionCaseWrongArguments", UnionCaseWrongArguments);
export class UnionCaseWrongNumberOfArgs extends Error {
  constructor(data0, data1, data2, data3) {
    super();
    Object.setPrototypeOf(this, UnionCaseWrongNumberOfArgs.prototype);
    this.Data0 = data0;
    this.Data1 = data1 | 0;
    this.Data2 = data2 | 0;
    this.Data3 = data3;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.UnionCaseWrongNumberOfArgs",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: "number",
        Data2: "number",
        Data3: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.UnionCaseWrongNumberOfArgs", UnionCaseWrongNumberOfArgs);
export class FieldsFromDifferentTypes extends Error {
  constructor(data0, data1, data2, data3) {
    super();
    Object.setPrototypeOf(this, FieldsFromDifferentTypes.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.FieldsFromDifferentTypes",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: RecdFieldRef,
        Data2: RecdFieldRef,
        Data3: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.FieldsFromDifferentTypes", FieldsFromDifferentTypes);
export class FieldGivenTwice extends Error {
  constructor(data0, data1, data2) {
    super();
    Object.setPrototypeOf(this, FieldGivenTwice.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.FieldGivenTwice",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: RecdFieldRef,
        Data2: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.FieldGivenTwice", FieldGivenTwice);
export class MissingFields extends Error {
  constructor(data0, data1) {
    super();
    Object.setPrototypeOf(this, MissingFields.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.MissingFields",
      interfaces: ["FSharpException"],
      properties: {
        Data0: makeGeneric(List, {
          T: "string"
        }),
        Data1: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.MissingFields", MissingFields);
export class FunctionValueUnexpected extends Error {
  constructor(data0, data1, data2) {
    super();
    Object.setPrototypeOf(this, FunctionValueUnexpected.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.FunctionValueUnexpected",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.FunctionValueUnexpected", FunctionValueUnexpected);
export class UnitTypeExpected extends Error {
  constructor(data0, data1, data2) {
    super();
    Object.setPrototypeOf(this, UnitTypeExpected.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.UnitTypeExpected",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.UnitTypeExpected", UnitTypeExpected);
export class UnitTypeExpectedWithEquality extends Error {
  constructor(data0, data1, data2) {
    super();
    Object.setPrototypeOf(this, UnitTypeExpectedWithEquality.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.UnitTypeExpectedWithEquality",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.UnitTypeExpectedWithEquality", UnitTypeExpectedWithEquality);
export class UnitTypeExpectedWithPossibleAssignment extends Error {
  constructor(data0, data1, data2, data3, data4) {
    super();
    Object.setPrototypeOf(this, UnitTypeExpectedWithPossibleAssignment.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
    this.Data4 = data4;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.UnitTypeExpectedWithPossibleAssignment",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: "boolean",
        Data3: "string",
        Data4: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.UnitTypeExpectedWithPossibleAssignment", UnitTypeExpectedWithPossibleAssignment);
export class UnitTypeExpectedWithPossiblePropertySetter extends Error {
  constructor(data0, data1, data2, data3, data4) {
    super();
    Object.setPrototypeOf(this, UnitTypeExpectedWithPossiblePropertySetter.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
    this.Data4 = data4;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.UnitTypeExpectedWithPossiblePropertySetter",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: "string",
        Data3: "string",
        Data4: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.UnitTypeExpectedWithPossiblePropertySetter", UnitTypeExpectedWithPossiblePropertySetter);
export class UnionPatternsBindDifferentNames extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, UnionPatternsBindDifferentNames.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.UnionPatternsBindDifferentNames",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.UnionPatternsBindDifferentNames", UnionPatternsBindDifferentNames);
export class VarBoundTwice extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, VarBoundTwice.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.VarBoundTwice",
      interfaces: ["FSharpException"],
      properties: {
        Data0: Ident
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.VarBoundTwice", VarBoundTwice);
export class ValueRestriction extends Error {
  constructor(data0, data1, data2, data3, data4) {
    super();
    Object.setPrototypeOf(this, ValueRestriction.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
    this.Data4 = data4;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.ValueRestriction",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: "boolean",
        Data2: Val,
        Data3: Typar,
        Data4: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.ValueRestriction", ValueRestriction);
export class FieldNotMutable extends Error {
  constructor(data0, data1, data2) {
    super();
    Object.setPrototypeOf(this, FieldNotMutable.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.FieldNotMutable",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: RecdFieldRef,
        Data2: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.FieldNotMutable", FieldNotMutable);
export class ValNotMutable extends Error {
  constructor(data0, data1, data2) {
    super();
    Object.setPrototypeOf(this, ValNotMutable.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.ValNotMutable",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: ValRef,
        Data2: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.ValNotMutable", ValNotMutable);
export class ValNotLocal extends Error {
  constructor(data0, data1, data2) {
    super();
    Object.setPrototypeOf(this, ValNotLocal.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.ValNotLocal",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: ValRef,
        Data2: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.ValNotLocal", ValNotLocal);
export class InvalidRuntimeCoercion extends Error {
  constructor(data0, data1, data2, data3) {
    super();
    Object.setPrototypeOf(this, InvalidRuntimeCoercion.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.InvalidRuntimeCoercion",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: TType,
        Data3: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.InvalidRuntimeCoercion", InvalidRuntimeCoercion);
export class IndeterminateRuntimeCoercion extends Error {
  constructor(data0, data1, data2, data3) {
    super();
    Object.setPrototypeOf(this, IndeterminateRuntimeCoercion.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.IndeterminateRuntimeCoercion",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: TType,
        Data3: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.IndeterminateRuntimeCoercion", IndeterminateRuntimeCoercion);
export class IndeterminateStaticCoercion extends Error {
  constructor(data0, data1, data2, data3) {
    super();
    Object.setPrototypeOf(this, IndeterminateStaticCoercion.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.IndeterminateStaticCoercion",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: TType,
        Data3: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.IndeterminateStaticCoercion", IndeterminateStaticCoercion);
export class RuntimeCoercionSourceSealed extends Error {
  constructor(data0, data1, data2) {
    super();
    Object.setPrototypeOf(this, RuntimeCoercionSourceSealed.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.RuntimeCoercionSourceSealed",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.RuntimeCoercionSourceSealed", RuntimeCoercionSourceSealed);
export class CoercionTargetSealed extends Error {
  constructor(data0, data1, data2) {
    super();
    Object.setPrototypeOf(this, CoercionTargetSealed.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.CoercionTargetSealed",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.CoercionTargetSealed", CoercionTargetSealed);
export class UpcastUnnecessary extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, UpcastUnnecessary.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.UpcastUnnecessary",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.UpcastUnnecessary", UpcastUnnecessary);
export class TypeTestUnnecessary extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, TypeTestUnnecessary.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.TypeTestUnnecessary",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.TypeTestUnnecessary", TypeTestUnnecessary);
export class StaticCoercionShouldUseBox extends Error {
  constructor(data0, data1, data2, data3) {
    super();
    Object.setPrototypeOf(this, StaticCoercionShouldUseBox.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.StaticCoercionShouldUseBox",
      interfaces: ["FSharpException"],
      properties: {
        Data0: DisplayEnv,
        Data1: TType,
        Data2: TType,
        Data3: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.StaticCoercionShouldUseBox", StaticCoercionShouldUseBox);
export class SelfRefObjCtor extends Error {
  constructor(data0, data1) {
    super();
    Object.setPrototypeOf(this, SelfRefObjCtor.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.SelfRefObjCtor",
      interfaces: ["FSharpException"],
      properties: {
        Data0: "boolean",
        Data1: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.SelfRefObjCtor", SelfRefObjCtor);
export class VirtualAugmentationOnNullValuedType extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, VirtualAugmentationOnNullValuedType.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.VirtualAugmentationOnNullValuedType",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.VirtualAugmentationOnNullValuedType", VirtualAugmentationOnNullValuedType);
export class NonVirtualAugmentationOnNullValuedType extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, NonVirtualAugmentationOnNullValuedType.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.NonVirtualAugmentationOnNullValuedType",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.NonVirtualAugmentationOnNullValuedType", NonVirtualAugmentationOnNullValuedType);
export class UseOfAddressOfOperator extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, UseOfAddressOfOperator.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.UseOfAddressOfOperator",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.UseOfAddressOfOperator", UseOfAddressOfOperator);
export class DeprecatedThreadStaticBindingWarning extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, DeprecatedThreadStaticBindingWarning.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.DeprecatedThreadStaticBindingWarning",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.DeprecatedThreadStaticBindingWarning", DeprecatedThreadStaticBindingWarning);
export class IntfImplInIntrinsicAugmentation extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, IntfImplInIntrinsicAugmentation.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.IntfImplInIntrinsicAugmentation",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.IntfImplInIntrinsicAugmentation", IntfImplInIntrinsicAugmentation);
export class IntfImplInExtrinsicAugmentation extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, IntfImplInExtrinsicAugmentation.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.IntfImplInExtrinsicAugmentation",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.IntfImplInExtrinsicAugmentation", IntfImplInExtrinsicAugmentation);
export class OverrideInIntrinsicAugmentation extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, OverrideInIntrinsicAugmentation.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.OverrideInIntrinsicAugmentation",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.OverrideInIntrinsicAugmentation", OverrideInIntrinsicAugmentation);
export class OverrideInExtrinsicAugmentation extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, OverrideInExtrinsicAugmentation.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.OverrideInExtrinsicAugmentation",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.OverrideInExtrinsicAugmentation", OverrideInExtrinsicAugmentation);
export class NonUniqueInferredAbstractSlot extends Error {
  constructor(data0, data1, data2, data3, data4, data5) {
    super();
    Object.setPrototypeOf(this, NonUniqueInferredAbstractSlot.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
    this.Data2 = data2;
    this.Data3 = data3;
    this.Data4 = data4;
    this.Data5 = data5;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.NonUniqueInferredAbstractSlot",
      interfaces: ["FSharpException"],
      properties: {
        Data0: TcGlobals,
        Data1: DisplayEnv,
        Data2: "string",
        Data3: MethInfo,
        Data4: MethInfo,
        Data5: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.NonUniqueInferredAbstractSlot", NonUniqueInferredAbstractSlot);
export class StandardOperatorRedefinitionWarning extends Error {
  constructor(data0, data1) {
    super();
    Object.setPrototypeOf(this, StandardOperatorRedefinitionWarning.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.StandardOperatorRedefinitionWarning",
      interfaces: ["FSharpException"],
      properties: {
        Data0: "string",
        Data1: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.StandardOperatorRedefinitionWarning", StandardOperatorRedefinitionWarning);
export class InvalidInternalsVisibleToAssemblyName extends Error {
  constructor(data0, data1) {
    super();
    Object.setPrototypeOf(this, InvalidInternalsVisibleToAssemblyName.prototype);
    this.Data0 = data0;
    this.Data1 = data1;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.InvalidInternalsVisibleToAssemblyName",
      interfaces: ["FSharpException"],
      properties: {
        Data0: "string",
        Data1: Option("string")
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.InvalidInternalsVisibleToAssemblyName", InvalidInternalsVisibleToAssemblyName);
export function IsSecurityAttribute(g, amap, casmap, _arg1, m) {
  const matchValue = g.attrib_SecurityAttribute;

  if (matchValue != null) {
    const matchValue_1 = getValue(matchValue).TyconRef.TryDeref;

    if (matchValue_1.tag === 1) {
      return false;
    } else {
      const tcs = _arg1.data[0].Stamp;

      if (casmap.has(tcs)) {
        return casmap.get(tcs);
      } else {
        const exists = ExistsInEntireHierarchyOfType(function (t) {
          return typeEquiv(g, t, mkAppTy(getValue(matchValue).TyconRef, new List()));
        }, g, amap, m, new AllowMultiIntfInstantiations(0), mkAppTy(_arg1.data[0], new List()));
        casmap.set(tcs, exists);
        return exists;
      }
    }
  } else {
    return false;
  }
}
export function IsSecurityCriticalAttribute(g, _arg1) {
  if (tyconRefEq(g, _arg1.data[0], g.attrib_SecurityCriticalAttribute.TyconRef)) {
    return true;
  } else {
    return tyconRefEq(g, _arg1.data[0], g.attrib_SecuritySafeCriticalAttribute.TyconRef);
  }
}
export function RecdFieldInstanceChecks(g, amap, ad, m, rfinfo) {
  if (rfinfo.IsStatic) {
    error_1(new _Error(SR.tcStaticFieldUsedWhenInstanceFieldExpected(), m));
  }

  CommitOperationResult(CheckRecdFieldInfoAttributes(g, rfinfo, m));
  CheckRecdFieldInfoAccessible(amap, m, ad, rfinfo);
}
export function ILFieldInstanceChecks(g, amap, ad, m, finfo) {
  if (finfo.IsStatic) {
    error_1(new _Error(SR.tcStaticFieldUsedWhenInstanceFieldExpected(), m));
  }

  CheckILFieldInfoAccessible(g, amap, m, ad, finfo);
  CheckILFieldAttributes(g, finfo, m);
}
export function MethInfoChecks(g, amap, isInstance, tyargsOpt, objArgs, ad, m, minfo) {
  if (minfo.IsInstance !== isInstance) {
    if (isInstance) {
      error_1(new _Error(SR.csMethodIsNotAnInstanceMethod(minfo.LogicalName), m));
    } else {
      error_1(new _Error(SR.csMethodIsNotAStaticMethod(minfo.LogicalName), m));
    }
  }

  let ad_1;
  const matchValue = [objArgs, ad];
  const $var1 = matchValue[0].tail != null ? matchValue[0].tail.tail == null ? matchValue[1].tag === 0 ? matchValue[1].data[1] != null ? [0, matchValue[0].head, matchValue[1].data[0], getValue(matchValue[1].data[1])] : [1] : [1] : [1] : [1];

  switch ($var1[0]) {
    case 0:
      const objArgTy = tyOfExpr(g, $var1[1]);
      const ty = generalizedTyconRef($var1[3]);

      if (TypeFeasiblySubsumesType(0, g, amap, m, ty, new CanCoerce(0), objArgTy)) {
        ad_1 = ad;
      } else if (IsBaseCall(objArgs)) {
        ad_1 = ad;
      } else {
        ad_1 = new AccessorDomain(0, [$var1[2], null]);
      }

      break;

    case 1:
      ad_1 = ad;
      break;
  }

  if (!IsTypeAndMethInfoAccessible(amap, m, ad, ad_1, minfo)) {
    error_1(new _Error(SR.tcMethodNotAccessible(minfo.LogicalName), m));
  }

  if ((isAnyTupleTy(g, minfo.ApparentEnclosingType) ? !minfo.IsExtensionMember : false) ? minfo.LogicalName.indexOf("get_Item") === 0 ? true : minfo.LogicalName.indexOf("get_Rest") === 0 : false) {
    warning(new _Error(SR.tcTupleMemberNotNormallyUsed(), m));
  }

  CommitOperationResult(CheckMethInfoAttributes(g, m, tyargsOpt, minfo));
}
export function CheckRecdFieldMutation(m, denv, rfinfo) {
  if (!rfinfo.RecdField.IsMutable) {
    error_1(new FieldNotMutable(denv, rfinfo.RecdFieldRef, m));
  }
}
export class SafeInitData {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.SafeInitData",
      interfaces: ["FSharpUnion"],
      cases: [["SafeInitField", RecdFieldRef, RecdField], ["NoSafeInitInfo"]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.SafeInitData", SafeInitData);
export class CtorInfo {
  constructor(ctorShapeCounter, safeThisValOpt, safeInitInfo, ctorIsImplicit) {
    this.ctorShapeCounter = ctorShapeCounter | 0;
    this.safeThisValOpt = safeThisValOpt;
    this.safeInitInfo = safeInitInfo;
    this.ctorIsImplicit = ctorIsImplicit;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.CtorInfo",
      interfaces: ["FSharpRecord"],
      properties: {
        ctorShapeCounter: "number",
        safeThisValOpt: Option(Val),
        safeInitInfo: SafeInitData,
        ctorIsImplicit: "boolean"
      }
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.CtorInfo", CtorInfo);
export class UngeneralizableItem {
  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.UngeneralizableItem",
      properties: {
        CachedFreeLocalTycons: makeGeneric(_Set, {
          T: Entity,
          ComparerTag: Interface("System.Collections.Generic.IComparer")
        }),
        CachedFreeTraitSolutions: makeGeneric(_Set, {
          T: Val,
          ComparerTag: Interface("System.Collections.Generic.IComparer")
        }),
        WillNeverHaveFreeTypars: "boolean"
      }
    };
  }

  constructor(computeFreeTyvars) {
    this.computeFreeTyvars = computeFreeTyvars;
    this.willNeverHaveFreeTypars = false;
    this.cachedFreeLocalTycons = emptyFreeTycons;
    this.cachedFreeTraitSolutions = emptyFreeLocals;
  }

  GetFreeTyvars() {
    const fvs = this.computeFreeTyvars();

    if (fvs.FreeTypars.IsEmpty) {
      this.willNeverHaveFreeTypars = true;
      this.cachedFreeLocalTycons = fvs.FreeTycons;
      this.cachedFreeTraitSolutions = fvs.FreeTraitSolutions;
    }

    return fvs;
  }

  get WillNeverHaveFreeTypars() {
    return this.willNeverHaveFreeTypars;
  }

  get CachedFreeLocalTycons() {
    return this.cachedFreeLocalTycons;
  }

  get CachedFreeTraitSolutions() {
    return this.cachedFreeTraitSolutions;
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.UngeneralizableItem", UngeneralizableItem);
export class TcEnv {
  constructor(eNameResEnv, eUngeneralizableItems, ePath, eCompPath, eAccessPath, eAccessRights, eInternalsVisibleCompPaths, eModuleOrNamespaceTypeAccumulator, eContextInfo, eFamilyType, eCtorInfo, eCallerMemberName) {
    this.eNameResEnv = eNameResEnv;
    this.eUngeneralizableItems = eUngeneralizableItems;
    this.ePath = ePath;
    this.eCompPath = eCompPath;
    this.eAccessPath = eAccessPath;
    this.eAccessRights = eAccessRights;
    this.eInternalsVisibleCompPaths = eInternalsVisibleCompPaths;
    this.eModuleOrNamespaceTypeAccumulator = eModuleOrNamespaceTypeAccumulator;
    this.eContextInfo = eContextInfo;
    this.eFamilyType = eFamilyType;
    this.eCtorInfo = eCtorInfo;
    this.eCallerMemberName = eCallerMemberName;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.TcEnv",
      interfaces: ["FSharpRecord"],
      properties: {
        eNameResEnv: NameResolutionEnv,
        eUngeneralizableItems: makeGeneric(List, {
          T: UngeneralizableItem
        }),
        ePath: makeGeneric(List, {
          T: Ident
        }),
        eCompPath: CompilationPath,
        eAccessPath: CompilationPath,
        eAccessRights: AccessorDomain,
        eInternalsVisibleCompPaths: makeGeneric(List, {
          T: CompilationPath
        }),
        eModuleOrNamespaceTypeAccumulator: Any,
        eContextInfo: ContextInfo,
        eFamilyType: Option(EntityRef),
        eCtorInfo: Option(CtorInfo),
        eCallerMemberName: Option("string")
      }
    };
  }

  get DisplayEnv() {
    return this.eNameResEnv.DisplayEnv;
  }

  get NameEnv() {
    return this.eNameResEnv;
  }

  get AccessRights() {
    return this.eAccessRights;
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.TcEnv", TcEnv);
export function computeAccessRights(eAccessPath, eInternalsVisibleCompPaths, eFamilyType) {
  return new AccessorDomain(0, [new List(eAccessPath, eInternalsVisibleCompPaths), eFamilyType]);
}
export function emptyTcEnv(g) {
  const cpath = compPathInternal;
  const eNameResEnv = NameResolutionEnv.Empty(g);
  const eUngeneralizableItems = new List();
  const ePath = new List();
  const eAccessRights = computeAccessRights(cpath, new List(), null);
  const eInternalsVisibleCompPaths = new List();
  const eContextInfo = new ContextInfo(0);
  return new TcEnv(eNameResEnv, eUngeneralizableItems, ePath, cpath, cpath, eAccessRights, eInternalsVisibleCompPaths, {
    contents: NewEmptyModuleOrNamespaceType(new ModuleOrNamespaceKind(2))
  }, eContextInfo, null, null, null);
}
export function InitialExplicitCtorInfo(safeThisValOpt, safeInitInfo) {
  return new CtorInfo(3, safeThisValOpt, safeInitInfo, false);
}
export function InitialImplicitCtorInfo() {
  return new CtorInfo(0, null, new SafeInitData(1), true);
}
export function EnterFamilyRegion(tcref, env) {
  const eFamilyType = tcref;
  const eAccessRights = computeAccessRights(env.eAccessPath, env.eInternalsVisibleCompPaths, eFamilyType);
  return new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, eFamilyType, env.eCtorInfo, env.eCallerMemberName);
}
export function ExitFamilyRegion(env) {
  const eFamilyType = null;

  if (env.eFamilyType == null) {
    return env;
  } else {
    const eAccessRights = computeAccessRights(env.eAccessPath, env.eInternalsVisibleCompPaths, eFamilyType);
    return new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  }
}
export function AreWithinCtorShape(env) {
  if (env.eCtorInfo != null) {
    return getValue(env.eCtorInfo).ctorShapeCounter > 0;
  } else {
    return false;
  }
}
export function AreWithinImplicitCtor(env) {
  if (env.eCtorInfo != null) {
    return getValue(env.eCtorInfo).ctorIsImplicit;
  } else {
    return false;
  }
}
export function GetCtorShapeCounter(env) {
  if (env.eCtorInfo != null) {
    return getValue(env.eCtorInfo).ctorShapeCounter | 0;
  } else {
    return 0;
  }
}
export function GetRecdInfo(env) {
  if (env.eCtorInfo != null) {
    if (getValue(env.eCtorInfo).ctorShapeCounter === 1) {
      return new RecordConstructionInfo(0);
    } else {
      return new RecordConstructionInfo(1);
    }
  } else {
    return new RecordConstructionInfo(1);
  }
}
export function AdjustCtorShapeCounter(f, env) {
  const eCtorInfo = defaultArg(env.eCtorInfo, null, function (ctorInfo) {
    return new CtorInfo(f(ctorInfo.ctorShapeCounter), ctorInfo.safeThisValOpt, ctorInfo.safeInitInfo, ctorInfo.ctorIsImplicit);
  });
  return new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, eCtorInfo, env.eCallerMemberName);
}
export function ExitCtorShapeRegion(env) {
  return AdjustCtorShapeCounter(function (_arg1) {
    return 0;
  }, env);
}
export function isEmptyFreeTyvars(ftyvs) {
  if (ZsetModule.isEmpty(ftyvs.FreeTypars)) {
    return ZsetModule.isEmpty(ftyvs.FreeTycons);
  } else {
    return false;
  }
}
export function addFreeItemOfTy(typ, eUngeneralizableItems) {
  const fvs = freeInType_1(CollectAllNoCaching, typ);

  if (isEmptyFreeTyvars(fvs)) {
    return eUngeneralizableItems;
  } else {
    return new List(new UngeneralizableItem(function () {
      return freeInType_1(CollectAllNoCaching, typ);
    }), eUngeneralizableItems);
  }
}
export function addFreeInModuleTy(mtyp, acc) {
  return QueueListModule.foldBack(($var5, $var6) => ($var4 => ($var2 => $var3 => function (arg10_, arg20_) {
    return accFreeInType(CollectAllNoCaching, arg10_, arg20_);
  }($var2, $var3))(function (v) {
    return typeOfVal(v);
  }($var4)))($var5)($var6), mtyp.AllValsAndMembers, QueueListModule.foldBack(function (mspec, acc_1) {
    return addFreeInModuleTy(mspec.ModuleOrNamespaceType, acc_1);
  }, mtyp.AllEntities, acc));
}
export function freeInModuleTy(mtyp) {
  return addFreeInModuleTy(mtyp, emptyFreeTyvars);
}
export function addFreeItemOfModuleTy(mtyp, eUngeneralizableItems) {
  const fvs = freeInModuleTy(mtyp);

  if (isEmptyFreeTyvars(fvs)) {
    return eUngeneralizableItems;
  } else {
    return new List(new UngeneralizableItem(function () {
      return freeInModuleTy(mtyp);
    }), eUngeneralizableItems);
  }
}
export function AddValMapToNameEnv(vs, nenv) {
  return NameMapModule.foldBackRange(function (v, nenv_1) {
    return AddValRefToNameEnv(nenv_1, mkLocalValRef(v));
  }, vs, nenv);
}
export function AddValListToNameEnv(vs, nenv) {
  return foldBack(function (v, nenv_1) {
    return AddValRefToNameEnv(nenv_1, mkLocalValRef(v));
  }, vs, nenv);
}
export function addInternalsAccessibility(env, ccu) {
  const compPath = new CompilationPath(0, [ccu.ILScopeRef, new List()]);
  const eInternalsVisibleCompPaths = new List(compPath, env.eInternalsVisibleCompPaths);
  const eAccessRights = computeAccessRights(env.eAccessPath, eInternalsVisibleCompPaths, env.eFamilyType);
  const eInternalsVisibleCompPaths_1 = new List(compPath, env.eInternalsVisibleCompPaths);
  return new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, eAccessRights, eInternalsVisibleCompPaths_1, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
}
export function AddLocalValPrimitive(v, env) {
  return new TcEnv(AddValRefToNameEnv(env.eNameResEnv, mkLocalValRef(v)), addFreeItemOfTy(v.Type, env.eUngeneralizableItems), env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
}
export function AddLocalValMap(tcSink, scopem, vals, env) {
  const env_1 = isEmpty(vals, null) ? env : new TcEnv(AddValMapToNameEnv(vals, env.eNameResEnv), NameMapModule.foldBackRange(($var10, $var11) => ($var9 => ($var7 => $var8 => function (typ, eUngeneralizableItems) {
    return addFreeItemOfTy(typ, eUngeneralizableItems);
  }($var7, $var8))(function (v) {
    return typeOfVal(v);
  }($var9)))($var10)($var11), vals, env.eUngeneralizableItems), env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  CallEnvSink(tcSink, scopem, env_1.NameEnv, env_1.eAccessRights);
  return env_1;
}
export function AddLocalVals(tcSink, scopem, vals, env) {
  const env_1 = vals.tail == null ? env : new TcEnv(AddValListToNameEnv(vals, env.eNameResEnv), foldBack(($var15, $var16) => ($var14 => ($var12 => $var13 => function (typ, eUngeneralizableItems) {
    return addFreeItemOfTy(typ, eUngeneralizableItems);
  }($var12, $var13))(function (v) {
    return typeOfVal(v);
  }($var14)))($var15)($var16), vals, env.eUngeneralizableItems), env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  CallEnvSink(tcSink, scopem, env_1.NameEnv, env_1.eAccessRights);
  return env_1;
}
export function AddLocalVal(tcSink, scopem, v, env) {
  const env_1 = new TcEnv(AddValRefToNameEnv(env.eNameResEnv, mkLocalValRef(v)), addFreeItemOfTy(v.Type, env.eUngeneralizableItems), env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  CallEnvSink(tcSink, scopem, env_1.NameEnv, env_1.eAccessRights);
  return env_1;
}
export function AddLocalExnDefnAndReport(tcSink, scopem, env, exnc) {
  const env_1 = new TcEnv(AddExceptionDeclsToNameEnv(new BulkAdd(1), env.eNameResEnv, mkLocalEntityRef(exnc)), env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  CallEnvSink(tcSink, exnc.Range, env_1.NameEnv, env_1.eAccessRights);
  CallEnvSink(tcSink, scopem, env_1.NameEnv, env_1.eAccessRights);
  return env_1;
}
export function AddLocalTyconRefs(ownDefinition, g, amap, m, tcrefs, env) {
  if (tcrefs.tail == null) {
    return env;
  } else {
    return new TcEnv(AddTyconRefsToNameEnv(new BulkAdd(1), ownDefinition, g, amap, m, false, env.eNameResEnv, tcrefs), env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  }
}
export function AddLocalTycons(g, amap, m, tycons, env) {
  var tcrefs;

  if (tycons.tail == null) {
    return env;
  } else {
    return (tcrefs = map_1(function (x) {
      return mkLocalTyconRef(x);
    }, tycons), function (env_1) {
      return AddLocalTyconRefs(false, g, amap, m, tcrefs, env_1);
    })(env);
  }
}
export function AddLocalTyconsAndReport(tcSink, scopem, g, amap, m, tycons, env) {
  const env_1 = AddLocalTycons(g, amap, m, tycons, env);
  CallEnvSink(tcSink, scopem, env_1.NameEnv, env_1.eAccessRights);
  return env_1;
}
export function OpenModulesOrNamespaces(tcSink, g, amap, scopem, root, env, mvvs, openDeclaration) {
  const env_1 = mvvs.tail == null ? env : new TcEnv(AddModulesAndNamespacesContentsToNameEnv(g, amap, env.eAccessRights, scopem, root, env.eNameResEnv, mvvs), env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  CallEnvSink(tcSink, scopem, env_1.NameEnv, env_1.eAccessRights);
  CallOpenDeclarationSink(tcSink, openDeclaration);
  return env_1;
}
export function AddRootModuleOrNamespaceRefs(g, amap, m, env, modrefs) {
  if (modrefs.tail == null) {
    return env;
  } else {
    return new TcEnv(AddModuleOrNamespaceRefsToNameEnv(g, amap, m, true, env.eAccessRights, env.eNameResEnv, modrefs), env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  }
}
export function AddNonLocalCcu(g, amap, scopem, env, assemblyName, ccu, internalsVisibleToAttributes) {
  const internalsVisible = exists_1(function (visibleTo) {
    try {
      return new System.Reflection.AssemblyName(visibleTo).Name === assemblyName;
    } catch (e) {
      warning(new InvalidInternalsVisibleToAssemblyName(visibleTo, ccu.FileName));
      return false;
    }
  }, internalsVisibleToAttributes);
  const env_1 = internalsVisible ? addInternalsAccessibility(env, ccu) : env;
  const modrefs = map_1(function (x) {
    return mkNonLocalCcuRootEntityRef(ccu, x);
  }, ccu.RootModulesAndNamespaces);
  const tcrefs = map_1(function (x_1) {
    return mkNonLocalCcuRootEntityRef(ccu, x_1);
  }, ccu.RootTypeAndExceptionDefinitions);
  const env_2 = AddRootModuleOrNamespaceRefs(g, amap, scopem, env_1, modrefs);
  const env_3 = tcrefs.tail == null ? env_2 : new TcEnv(AddTyconRefsToNameEnv(new BulkAdd(0), false, g, amap, scopem, true, env_2.eNameResEnv, tcrefs), env_2.eUngeneralizableItems, env_2.ePath, env_2.eCompPath, env_2.eAccessPath, env_2.eAccessRights, env_2.eInternalsVisibleCompPaths, env_2.eModuleOrNamespaceTypeAccumulator, env_2.eContextInfo, env_2.eFamilyType, env_2.eCtorInfo, env_2.eCallerMemberName);
  return env_3;
}
export function AddLocalRootModuleOrNamespace(tcSink, g, amap, scopem, env, mtyp) {
  const modrefs = function (list) {
    return map_1(function (v) {
      return mkLocalModRef(v);
    }, list);
  }(mtyp.ModuleAndNamespaceDefinitions);

  const tcrefs = function (list_1) {
    return map_1(function (x) {
      return mkLocalTyconRef(x);
    }, list_1);
  }(mtyp.TypeAndExceptionDefinitions);

  const env_1 = AddRootModuleOrNamespaceRefs(g, amap, scopem, env, modrefs);
  const env_2 = new TcEnv(tcrefs.tail == null ? env_1.eNameResEnv : AddTyconRefsToNameEnv(new BulkAdd(1), false, g, amap, scopem, true, env_1.eNameResEnv, tcrefs), addFreeItemOfModuleTy(mtyp, env_1.eUngeneralizableItems), env_1.ePath, env_1.eCompPath, env_1.eAccessPath, env_1.eAccessRights, env_1.eInternalsVisibleCompPaths, env_1.eModuleOrNamespaceTypeAccumulator, env_1.eContextInfo, env_1.eFamilyType, env_1.eCtorInfo, env_1.eCallerMemberName);
  CallEnvSink(tcSink, scopem, env_2.NameEnv, env_2.eAccessRights);
  return env_2;
}
export function AddModuleAbbreviationAndReport(tcSink, scopem, id, modrefs, env) {
  const env_1 = modrefs.tail == null ? env : new TcEnv(AddModuleAbbrevToNameEnv(id, env.eNameResEnv, modrefs), env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  CallEnvSink(tcSink, scopem, env_1.NameEnv, env_1.eAccessRights);
  const item = new Item(18, modrefs);
  CallNameResolutionSink(tcSink, id.idRange, env_1.NameEnv, item, item, emptyTyparInst, new ItemOccurence(1), env_1.DisplayEnv, env_1.eAccessRights);
  return env_1;
}
export function AddLocalSubModule(g, amap, m, env, modul) {
  const env_1 = new TcEnv(AddModuleOrNamespaceRefToNameEnv(g, amap, m, false, env.eAccessRights, env.eNameResEnv, mkLocalModRef(modul)), addFreeItemOfModuleTy(modul.ModuleOrNamespaceType, env.eUngeneralizableItems), env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  return env_1;
}
export function AddLocalSubModuleAndReport(tcSink, scopem, g, amap, m, env, modul) {
  const env_1 = AddLocalSubModule(g, amap, m, env, modul);
  CallEnvSink(tcSink, scopem, env_1.NameEnv, env_1.eAccessRights);
  return env_1;
}
export function RegisterDeclaredTypars(typars, env) {
  if (typars.tail == null) {
    return env;
  } else {
    const eUngeneralizableItems_1 = foldBack(($var20, $var21) => ($var19 => ($var17 => $var18 => function (typ, eUngeneralizableItems) {
      return addFreeItemOfTy(typ, eUngeneralizableItems);
    }($var17, $var18))(function (tp) {
      return mkTyparTy(tp);
    }($var19)))($var20)($var21), typars, env.eUngeneralizableItems);
    return new TcEnv(env.eNameResEnv, eUngeneralizableItems_1, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  }
}
export function AddDeclaredTypars(check, typars, env) {
  if (typars.tail == null) {
    return env;
  } else {
    const env_1 = new TcEnv(AddDeclaredTyparsToNameEnv(check, env.eNameResEnv, typars), env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
    return RegisterDeclaredTypars(typars, env_1);
  }
}
export class cenv {
  constructor(g, recUses, postInferenceChecks, createsGeneratedProvidedTypes, isScript, amap, synArgNameGenerator, tcSink, topCcu, css, compilingCanonicalFslibModuleType, isSig, haveSig, niceNameGen, infoReader, nameResolver, conditionalDefines) {
    this.g = g;
    this.recUses = recUses;
    this.postInferenceChecks = postInferenceChecks;
    this.createsGeneratedProvidedTypes = createsGeneratedProvidedTypes;
    this.isScript = isScript;
    this.amap = amap;
    this.synArgNameGenerator = synArgNameGenerator;
    this.tcSink = tcSink;
    this.topCcu = topCcu;
    this.css = css;
    this.compilingCanonicalFslibModuleType = compilingCanonicalFslibModuleType;
    this.isSig = isSig;
    this.haveSig = haveSig;
    this.niceNameGen = niceNameGen;
    this.infoReader = infoReader;
    this.nameResolver = nameResolver;
    this.conditionalDefines = conditionalDefines;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.cenv",
      interfaces: ["FSharpRecord"],
      properties: {
        g: TcGlobals,
        recUses: makeGeneric(ValMultiMap, {
          T: Tuple([Any, range, "boolean"])
        }),
        postInferenceChecks: _Array(_Function([Unit, Unit])),
        createsGeneratedProvidedTypes: "boolean",
        isScript: "boolean",
        amap: ImportMap,
        synArgNameGenerator: SynArgNameGenerator,
        tcSink: TcResultsSink,
        topCcu: CcuThunk,
        css: ConstraintSolverState,
        compilingCanonicalFslibModuleType: "boolean",
        isSig: "boolean",
        haveSig: "boolean",
        niceNameGen: NiceNameGenerator,
        infoReader: InfoReader,
        nameResolver: NameResolver,
        conditionalDefines: makeGeneric(List, {
          T: "string"
        })
      }
    };
  }

  static Create(g, isScript, niceNameGen, amap, topCcu, isSig, haveSig, conditionalDefines, tcSink, tcVal) {
    const infoReader = new InfoReader(g, amap);

    const instantiationGenerator = function (m, tpsorig) {
      return FreshenTypars(m, tpsorig);
    };

    const nameResolver = NameResolver[".ctor"](g, amap, infoReader, instantiationGenerator);
    const recUses = ValMultiMap.Empty;
    const postInferenceChecks = [];
    const css = ConstraintSolverState.New(g, amap, infoReader, tcVal);
    const synArgNameGenerator = new SynArgNameGenerator();
    return new cenv(g, recUses, postInferenceChecks, false, isScript, amap, synArgNameGenerator, tcSink, topCcu, css, (isSig ? true : !haveSig) ? g.compilingFslib : false, isSig, haveSig, niceNameGen, infoReader, nameResolver, conditionalDefines);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.cenv", cenv);
export function CopyAndFixupTypars(m, rigid, tpsorig) {
  return FreshenAndFixupTypars(m, rigid, new List(), new List(), tpsorig);
}
export function UnifyTypes(cenv_1, env, m, expectedTy, actualTy) {
  AddCxTypeEqualsType(env.eContextInfo, env.DisplayEnv, cenv_1.css, m, tryNormalizeMeasureInType(cenv_1.g, expectedTy), tryNormalizeMeasureInType(cenv_1.g, actualTy));
}
export function MakeInitialEnv(env) {
  const mtypeAcc = {
    contents: NewEmptyModuleOrNamespaceType(new ModuleOrNamespaceKind(2))
  };
  return [new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, mtypeAcc, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName), mtypeAcc];
}
export function MakeInnerEnvWithAcc(env, nm, mtypeAcc, modKind) {
  const path = append(env.ePath, ofArray([nm]));

  const cpath = function (arg00, arg10) {
    return env.eCompPath.NestedCompPath(arg00, arg10);
  }(nm.idText, modKind);

  const eAccessRights = computeAccessRights(cpath, env.eInternalsVisibleCompPaths, env.eFamilyType);
  const eNameResEnv = new NameResolutionEnv(env.DisplayEnv.AddOpenPath(pathOfLid(path)), env.eNameResEnv.eUnqualifiedItems, env.eNameResEnv.ePatItems, env.eNameResEnv.eModulesAndNamespaces, env.eNameResEnv.eFullyQualifiedModulesAndNamespaces, env.eNameResEnv.eFieldLabels, env.eNameResEnv.eTyconsByAccessNames, env.eNameResEnv.eFullyQualifiedTyconsByAccessNames, env.eNameResEnv.eTyconsByDemangledNameAndArity, env.eNameResEnv.eFullyQualifiedTyconsByDemangledNameAndArity, env.eNameResEnv.eIndexedExtensionMembers, env.eNameResEnv.eUnindexedExtensionMembers, env.eNameResEnv.eTypars);
  return new TcEnv(eNameResEnv, env.eUngeneralizableItems, path, cpath, cpath, eAccessRights, env.eInternalsVisibleCompPaths, mtypeAcc, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
}
export function MakeInnerEnv(env, nm, modKind) {
  const mtypeAcc = {
    contents: NewEmptyModuleOrNamespaceType(modKind)
  };
  return [MakeInnerEnvWithAcc(env, nm, mtypeAcc, modKind), mtypeAcc];
}
export function MakeInnerEnvForTyconRef(_cenv, env, tcref, isExtrinsicExtension) {
  if (isExtrinsicExtension) {
    return env;
  } else {
    const env_1 = EnterFamilyRegion(tcref, env);

    const eAccessPath = function (arg00, arg10) {
      return env_1.eCompPath.NestedCompPath(arg00, arg10);
    }(tcref.LogicalName, new ModuleOrNamespaceKind(1));

    const eAccessRights = computeAccessRights(eAccessPath, env_1.eInternalsVisibleCompPaths, env_1.eFamilyType);
    return new TcEnv(env_1.eNameResEnv, env_1.eUngeneralizableItems, env_1.ePath, env_1.eCompPath, eAccessPath, eAccessRights, env_1.eInternalsVisibleCompPaths, env_1.eModuleOrNamespaceTypeAccumulator, env_1.eContextInfo, env_1.eFamilyType, env_1.eCtorInfo, env_1.eCallerMemberName);
  }
}
export function MakeInnerEnvForMember(cenv_1, env, v) {
  const matchValue = v.MemberInfo;

  if (matchValue != null) {
    return MakeInnerEnvForTyconRef(cenv_1, env, v.MemberApparentEntity, v.IsExtensionMember);
  } else {
    return env;
  }
}
export function GetCurrAccumulatedModuleOrNamespaceType(env) {
  return env.eModuleOrNamespaceTypeAccumulator.contents;
}
export function SetCurrAccumulatedModuleOrNamespaceType(env, x) {
  env.eModuleOrNamespaceTypeAccumulator.contents = x;
}
export function LocateEnv(ccu, env, enclosingNamespacePath) {
  const cpath = compPathOfCcu(ccu);
  let env_1;
  const ePath = new List();
  const eAccessRights = computeAccessRights(cpath, env.eInternalsVisibleCompPaths, env.eFamilyType);
  env_1 = new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, ePath, cpath, cpath, eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  const env_3 = fold(function (env_2, id) {
    return MakeInnerEnv(env_2, id, new ModuleOrNamespaceKind(2))[0];
  }, env_1, enclosingNamespacePath);
  return env_3;
}
export function BuildRootModuleType(enclosingNamespacePath, cpath, mtyp) {
  return function (tupledArg) {
    return [tupledArg[1][0], reverse(tupledArg[1][1])];
  }(foldBack(function (id, tupledArg_1) {
    const patternInput = wrapModuleOrNamespaceTypeInNamespace(id, tupledArg_1[0].ParentCompPath, tupledArg_1[1][0]);
    return [tupledArg_1[0].ParentCompPath, [patternInput[0], new List(patternInput[1], tupledArg_1[1][1])]];
  }, enclosingNamespacePath, [cpath, [mtyp, new List()]]));
}
export function BuildRootModuleExpr(enclosingNamespacePath, cpath, mexpr) {
  return foldBack(function (id, tupledArg) {
    return [tupledArg[0].ParentCompPath, wrapModuleOrNamespaceExprInNamespace(id, tupledArg[0].ParentCompPath, tupledArg[1])];
  }, enclosingNamespacePath, [cpath, mexpr])[1];
}
export function TryStripPrefixPath(g, enclosingNamespacePath) {
  const $var22 = enclosingNamespacePath.tail != null ? (((g.isInteractive ? !(enclosingNamespacePath.tail.tail == null) : false) ? startsWith(enclosingNamespacePath.head.idText, FsiDynamicModulePrefix, 4) : false) ? function (str) {
    return forAll(function (c) {
      return System.Char.IsDigit(c);
    }, str);
  }(enclosingNamespacePath.head.idText.slice(FsiDynamicModulePrefix.length, enclosingNamespacePath.head.idText.length)) : false) ? [0, enclosingNamespacePath.head, enclosingNamespacePath.tail] : [1] : [1];

  switch ($var22[0]) {
    case 0:
      return [$var22[1], $var22[2]];

    case 1:
      return null;
  }
}
export function ImplicitlyOpenOwnNamespace(tcSink, g, amap, scopem, enclosingNamespacePath, env) {
  if (enclosingNamespacePath.tail == null) {
    return env;
  } else {
    let enclosingNamespacePathToOpen;
    const matchValue = TryStripPrefixPath(g, enclosingNamespacePath);

    if (matchValue == null) {
      enclosingNamespacePathToOpen = enclosingNamespacePath;
    } else {
      const rest = getValue(matchValue)[1];
      enclosingNamespacePathToOpen = rest;
    }

    if (enclosingNamespacePathToOpen.tail != null) {
      const matchValue_1 = ResolveLongIndentAsModuleOrNamespace(tcSink, new ResultCollectionSettings(0), amap, scopem, true, new FullyQualifiedFlag(1), env.eNameResEnv, env.eAccessRights, enclosingNamespacePathToOpen.head, enclosingNamespacePathToOpen.tail, true);

      if (matchValue_1.tag === 1) {
        return env;
      } else {
        const modrefs = map_1(function (tupledArg) {
          return p23(tupledArg[0], tupledArg[1], tupledArg[2]);
        }, matchValue_1.data);
        const openDecl = OpenDeclaration.Create(enclosingNamespacePathToOpen, modrefs, scopem, true);
        return OpenModulesOrNamespaces(tcSink, g, amap, scopem, false, env, modrefs, openDecl);
      }
    } else {
      return env;
    }
  }
}
export function ShrinkContext(env, oldRange, newRange) {
  switch (env.eContextInfo.tag) {
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 13:
      return env;

    case 6:
      if (!equals(env.eContextInfo.data[1], oldRange)) {
        return env;
      } else {
        const eContextInfo = new ContextInfo(6, [env.eContextInfo.data[0], newRange]);
        return new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
      }

    case 11:
      if (!equals(env.eContextInfo.data, oldRange)) {
        return env;
      } else {
        const eContextInfo_1 = new ContextInfo(11, newRange);
        return new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, eContextInfo_1, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
      }

    case 12:
      if (!equals(env.eContextInfo.data, oldRange)) {
        return env;
      } else {
        const eContextInfo_2 = new ContextInfo(12, newRange);
        return new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, eContextInfo_2, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
      }

    case 1:
      if (!equals(env.eContextInfo.data, oldRange)) {
        return env;
      } else {
        const eContextInfo_3 = new ContextInfo(1, newRange);
        return new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, eContextInfo_3, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
      }

    case 2:
      if (!equals(env.eContextInfo.data, oldRange)) {
        return env;
      } else {
        const eContextInfo_4 = new ContextInfo(2, newRange);
        return new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, eContextInfo_4, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
      }

    case 3:
      if (!equals(env.eContextInfo.data, oldRange)) {
        return env;
      } else {
        const eContextInfo_5 = new ContextInfo(3, newRange);
        return new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, eContextInfo_5, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
      }

    default:
      return env;
  }
}
export function UnifyRefTupleType(contextInfo, cenv_1, denv, m, ty, ps) {
  let ptys_1;

  if (isRefTupleTy(cenv_1.g, ty)) {
    const ptys = destRefTupleTy(cenv_1.g, ty);

    if (ps.length === ptys.length) {
      ptys_1 = ptys;
    } else {
      ptys_1 = NewInferenceTypes(ps);
    }
  } else {
    ptys_1 = NewInferenceTypes(ps);
  }

  const contextInfo_1 = contextInfo.tag === 4 ? new ContextInfo(5) : contextInfo;
  AddCxTypeEqualsType(contextInfo_1, denv, cenv_1.css, m, ty, new TType(2, [tupInfoRef, ptys_1]));
  return ptys_1;
}
export function UnifyStructTupleType(contextInfo, cenv_1, denv, m, ty, ps) {
  let ptys_1;

  if (isStructTupleTy(cenv_1.g, ty)) {
    const ptys = destStructTupleTy(cenv_1.g, ty);

    if (ps.length === ptys.length) {
      ptys_1 = ptys;
    } else {
      ptys_1 = NewInferenceTypes(ps);
    }
  } else {
    ptys_1 = NewInferenceTypes(ps);
  }

  AddCxTypeEqualsType(contextInfo, denv, cenv_1.css, m, ty, new TType(2, [tupInfoStruct, ptys_1]));
  return ptys_1;
}
export function UnifyFunctionTypeUndoIfFailed(cenv_1, denv, m, ty) {
  const matchValue = tryDestFunTy(cenv_1.g, ty);

  if (matchValue == null) {
    const domainTy = NewInferenceType();
    const resultTy = NewInferenceType();

    if (AddCxTypeEqualsTypeUndoIfFailed(denv, cenv_1.css, m, ty, op_MinusMinusGreater(domainTy, resultTy))) {
      return [domainTy, resultTy];
    } else {
      return null;
    }
  } else {
    return matchValue;
  }
}
export function UnifyFunctionType(extraInfo, cenv_1, denv, mFunExpr, ty) {
  const matchValue = UnifyFunctionTypeUndoIfFailed(cenv_1, denv, mFunExpr, ty);

  if (matchValue == null) {
    if (extraInfo == null) {
      return error_1(new FunctionExpected(denv, ty, mFunExpr));
    } else {
      return error_1(new NotAFunction(denv, ty, mFunExpr, getValue(extraInfo)));
    }
  } else {
    return getValue(matchValue);
  }
}
export function ReportImplicitlyIgnoredBoolExpression(denv, m, ty, expr) {
  const checkExpr = function (m_1, expr_1) {
    var vf_1;
    var vf;
    var methodRef;
    const $var23 = expr_1.tag === 5 ? expr_1.data[0].tag === 1 ? (vf_1 = expr_1.data[0].data[0], vf_1.LogicalName === opNameEquals) ? [0, expr_1.data[3], expr_1.data[0].data[0]] : [1] : [1] : [1];

    switch ($var23[0]) {
      case 0:
        const $var24 = $var23[1].tail != null ? $var23[1].head.tag === 5 ? $var23[1].head.data[0].tag === 1 ? $var23[1].head.data[3].tail != null ? $var23[1].head.data[3].head.tag === 1 ? [0, $var23[1].head.data[0].data[0], $var23[1].head.data[3].head.data[0]] : [2] : [2] : [2] : $var23[1].head.tag === 11 ? $var23[1].head.data[0].tag === 31 ? $var23[1].head.data[2].tail != null ? $var23[1].head.data[2].head.tag === 1 ? (vf = $var23[1].head.data[2].head.data[0], methodRef = $var23[1].head.data[0].data[7], methodRef.Name.indexOf("get_") === 0) ? [1, $var23[1].head.data[0].data[7], $var23[1].head.data[2].head.data[0]] : [2] : [2] : [2] : [2] : [2] : [2];

        switch ($var24[0]) {
          case 0:
            if ($var24[1].IsPropertyGetterMethod) {
              const propertyName = $var24[1].PropertyName;
              let hasCorrespondingSetter;
              const matchValue = $var24[1].DeclaringEntity;

              if (matchValue.tag === 0) {
                hasCorrespondingSetter = exists_1(function (valRef) {
                  return valRef.IsPropertySetterMethod ? valRef.PropertyName === propertyName : false;
                }, matchValue.data.MembersOfFSharpTyconSorted);
              } else {
                hasCorrespondingSetter = false;
              }

              if (hasCorrespondingSetter) {
                return new UnitTypeExpectedWithPossiblePropertySetter(denv, ty, $var24[2].DisplayName, propertyName, m_1);
              } else {
                return new UnitTypeExpectedWithEquality(denv, ty, m_1);
              }
            } else {
              return new UnitTypeExpectedWithEquality(denv, ty, m_1);
            }

          case 1:
            return new UnitTypeExpectedWithPossiblePropertySetter(denv, ty, $var24[2].DisplayName, ChopPropertyName($var24[1].Name), m_1);

          case 2:
            const $var25 = $var23[1].tail != null ? $var23[1].head.tag === 1 ? [0, $var23[1].head.data[0]] : [1] : [1];

            switch ($var25[0]) {
              case 0:
                return new UnitTypeExpectedWithPossibleAssignment(denv, ty, $var25[1].IsMutable, $var25[1].DisplayName, m_1);

              case 1:
                return new UnitTypeExpectedWithEquality(denv, ty, m_1);
            }

        }

      case 1:
        return new UnitTypeExpected(denv, ty, m_1);
    }
  };

  const $var26 = expr.tag === 7 ? expr.data[1].tag === 2 ? [0, expr.data[1].data[1]] : [1, expr] : expr.tag === 2 ? [0, expr.data[1]] : [1, expr];

  switch ($var26[0]) {
    case 0:
      const extractNext = function (expr_2) {
        extractNext: while (true) {
          if (expr_2.tag === 2) {
            expr_2 = expr_2.data[1];
            continue extractNext;
          } else {
            return checkExpr(Expr_get_Range.bind(expr_2)(), expr_2);
          }
        }
      };

      return extractNext($var26[1]);

    case 1:
      return checkExpr(m, $var26[1]);
  }
}
export function UnifyUnitType(cenv_1, env, m, ty, expr) {
  const denv = env.DisplayEnv;

  if (AddCxTypeEqualsTypeUndoIfFailed(denv, cenv_1.css, m, ty, cenv_1.g.unit_ty)) {
    return true;
  } else {
    const domainTy = NewInferenceType();
    const resultTy = NewInferenceType();

    if (AddCxTypeEqualsTypeUndoIfFailed(denv, cenv_1.css, m, ty, op_MinusMinusGreater(domainTy, resultTy))) {
      warning(new FunctionValueUnexpected(denv, ty, m));
    } else {
      const reportImplicitlyDiscardError = function () {
        if (typeEquiv(cenv_1.g, cenv_1.g.bool_ty, ty)) {
          warning(ReportImplicitlyIgnoredBoolExpression(denv, m, ty, expr));
        } else {
          warning(new UnitTypeExpected(denv, ty, m));
        }
      };

      if (env.eContextInfo.tag === 13) {
        const lifted = mkSeqTy(cenv_1.g, ty);

        if (typeEquiv(cenv_1.g, env.eContextInfo.data, lifted)) {
          warning(new _Error(SR.implicitlyDiscardedInSequenceExpression(prettyStringOfTy(denv, ty)), m));
        } else if ((isListTy(cenv_1.g, ty) ? true : isArrayTy(cenv_1.g, ty)) ? true : typeEquiv(cenv_1.g, env.eContextInfo.data, ty)) {
          warning(new _Error(SR.implicitlyDiscardedSequenceInSequenceExpression(prettyStringOfTy(denv, ty)), m));
        } else {
          reportImplicitlyDiscardError();
        }
      } else {
        reportImplicitlyDiscardError();
      }
    }

    return false;
  }
}
export const AttributeTargets = function (__exports) {
  const FieldDecl = __exports.FieldDecl = 256 | 128;
  const FieldDeclRestricted = __exports.FieldDeclRestricted = 256;
  const UnionCaseDecl = __exports.UnionCaseDecl = 64 | 128;
  const TyconDecl = __exports.TyconDecl = 4 | 1024 | 4096 | 8 | 16;
  const ExnDecl = __exports.ExnDecl = 4;
  const ModuleDecl = __exports.ModuleDecl = 4;
  const Top = __exports.Top = 1 | 2 | 64;
  return __exports;
}({});
export function ForNewConstructors(tcSink, env, mObjTy, methodName, meths) {
  const origItem = new Item(11, [methodName, meths]);

  const callSink = function (tupledArg) {
    CallNameResolutionSink(tcSink, mObjTy, env.NameEnv, tupledArg[0], origItem, tupledArg[1], new ItemOccurence(1), env.DisplayEnv, env.eAccessRights);
  };

  const sendToSink = function (minst, refinedMeths) {
    callSink([new Item(11, [methodName, refinedMeths]), minst]);
  };

  if (meths.tail != null) {
    if (meths.tail.tail == null) {
      sendToSink(emptyTyparInst, meths);
      return new AfterResolution(0);
    } else {
      return new AfterResolution(1, [null, function (tpinst) {
        callSink([origItem, tpinst]);
      }, function (tupledArg_1) {
        sendToSink(tupledArg_1[2], ofArray([tupledArg_1[0]]));
      }, function () {
        callSink([origItem, emptyTyparInst]);
      }]);
    }
  } else {
    return new AfterResolution(0);
  }
}
export function TcSynRationalConst(c) {
  if (c.tag === 2) {
    return NegRational(TcSynRationalConst(c.data));
  } else if (c.tag === 1) {
    return DivRational(intToRational(c.data[0]), intToRational(c.data[1]));
  } else {
    return intToRational(c.data);
  }
}
export function TcConst(cenv_1, ty, m, env, c) {
  const tcMeasure = function (ms) {
    const $var27 = ms.tag === 0 ? [1, ms.data[1], ms.data[0]] : ms.tag === 4 ? [2, ms.data[1], ms.data[0]] : ms.tag === 1 ? [3, ms.data[0], ms.data[1]] : ms.tag === 3 ? ms.data[1].tag === 2 ? ms.data[1].data[0].tail != null ? ms.data[1].data[0].tail.tail != null ? [4, ms.data[2], ms.data[0], ms.data[1]] : [5, ms.data[0], ms.data[1]] : [5, ms.data[0], ms.data[1]] : [5, ms.data[0], ms.data[1]] : ms.tag === 2 ? [6, ms.data[0]] : ms.tag === 6 ? [7] : ms.tag === 7 ? [8, ms.data[1]] : [0];

    switch ($var27[0]) {
      case 0:
        return new Measure(4);

      case 1:
        const tcref = ResultOrExceptionModule.ForceRaise(ResolveTypeLongIdent(cenv_1.tcSink, cenv_1.nameResolver, new ItemOccurence(1), new FullyQualifiedFlag(1), env.eNameResEnv, env.eAccessRights, $var27[2], TypeNameResolutionStaticArgsInfo.DefiniteEmpty, new PermitDirectReferenceToGeneratedType(1)));
        const matchValue = tcref.TypeOrMeasureKind;

        if (matchValue.tag === 1) {
          return new Measure(1, tcref);
        } else {
          return error_1(new _Error(SR.tcExpectedUnitOfMeasureNotType(), $var27[1]));
        }

      case 2:
        return new Measure(5, [tcMeasure($var27[2]), TcSynRationalConst($var27[1])]);

      case 3:
        return new Measure(2, [tcMeasure($var27[1]), tcMeasure($var27[2])]);

      case 4:
        warning(new _Error(SR.tcImplicitMeasureFollowingSlash(), $var27[1]));
        return new Measure(2, [tcMeasure($var27[2]), new Measure(3, tcMeasure($var27[3]))]);

      case 5:
        return new Measure(2, [tcMeasure($var27[1]), new Measure(3, tcMeasure($var27[2]))]);

      case 6:
        return ProdMeasures(map_1(tcMeasure, $var27[1]));

      case 7:
        return error_1(new _Error(SR.tcUnexpectedMeasureAnon(), m));

      case 8:
        return error_1(new _Error(SR.tcNonZeroConstantCannotHaveGenericUnit(), $var27[1]));
    }
  };

  const unif = function (ty2) {
    UnifyTypes(cenv_1, env, m, ty, ty2);
  };

  const unif_measure_arg = function (iszero, tcr, c_1) {
    const measureTy = c_1.tag === 20 ? c_1.data[1].tag === 6 ? mkAppTy(tcr, ofArray([new TType(6, new Measure(0, NewAnonTypar(new TyparKind(1), m, new TyparRigidity(4), iszero ? new TyparStaticReq(0) : new TyparStaticReq(1), new TyparDynamicReq(0))))])) : mkAppTy(tcr, ofArray([new TType(6, tcMeasure(c_1.data[1]))])) : mkAppTy(tcr, ofArray([new TType(6, new Measure(4))]));
    unif(measureTy);
  };

  const $var28 = c.tag === 1 ? [1, c.data] : c.tag === 2 ? [2, c.data] : c.tag === 4 ? [3, c.data] : c.tag === 6 ? [4, c.data] : c.tag === 8 ? [5, c.data] : c.tag === 10 ? [6, c.data] : c.tag === 3 ? [7, c.data] : c.tag === 5 ? [8, c.data] : c.tag === 7 ? [9, c.data] : c.tag === 9 ? [10, c.data] : c.tag === 11 ? [11, c.data] : c.tag === 20 ? c.data[0].tag === 12 ? [12, c.data[0].data] : c.data[0].tag === 13 ? [13, c.data[0].data] : c.data[0].tag === 15 ? [14, c.data[0].data] : c.data[0].tag === 2 ? [15, c.data[0].data] : c.data[0].tag === 4 ? [16, c.data[0].data] : c.data[0].tag === 6 ? [17, c.data[0].data] : c.data[0].tag === 8 ? [18, c.data[0].data] : [22] : c.tag === 12 ? [12, c.data] : c.tag === 13 ? [13, c.data] : c.tag === 15 ? [14, c.data] : c.tag === 14 ? [19, c.data] : c.tag === 17 ? [20, c.data[0]] : c.tag === 16 ? [21] : c.tag === 19 ? [23] : c.tag === 18 ? [24] : [0];

  switch ($var28[0]) {
    case 0:
      unif(cenv_1.g.unit_ty);
      return new Const(16);

    case 1:
      unif(cenv_1.g.bool_ty);
      return new Const(0, $var28[1]);

    case 2:
      unif(cenv_1.g.sbyte_ty);
      return new Const(1, $var28[1]);

    case 3:
      unif(cenv_1.g.int16_ty);
      return new Const(3, $var28[1]);

    case 4:
      unif(cenv_1.g.int_ty);
      return new Const(5, $var28[1]);

    case 5:
      unif(cenv_1.g.int64_ty);
      return new Const(7, $var28[1]);

    case 6:
      unif(cenv_1.g.nativeint_ty);
      return new Const(9, $var28[1]);

    case 7:
      unif(cenv_1.g.byte_ty);
      return new Const(2, $var28[1]);

    case 8:
      unif(cenv_1.g.uint16_ty);
      return new Const(4, $var28[1]);

    case 9:
      unif(cenv_1.g.uint32_ty);
      return new Const(6, $var28[1]);

    case 10:
      unif(cenv_1.g.uint64_ty);
      return new Const(8, $var28[1]);

    case 11:
      unif(cenv_1.g.unativeint_ty);
      return new Const(10, $var28[1]);

    case 12:
      unif_measure_arg($var28[1] === Math.fround(0), cenv_1.g.pfloat32_tcr, c);
      return new Const(11, $var28[1]);

    case 13:
      unif_measure_arg($var28[1] === 0, cenv_1.g.pfloat_tcr, c);
      return new Const(12, $var28[1]);

    case 14:
      unif_measure_arg(false, cenv_1.g.pdecimal_tcr, c);
      return new Const(15, $var28[1]);

    case 15:
      unif_measure_arg($var28[1] === 0, cenv_1.g.pint8_tcr, c);
      return new Const(1, $var28[1]);

    case 16:
      unif_measure_arg($var28[1] === 0, cenv_1.g.pint16_tcr, c);
      return new Const(3, $var28[1]);

    case 17:
      unif_measure_arg($var28[1] === 0, cenv_1.g.pint_tcr, c);
      return new Const(5, $var28[1]);

    case 18:
      unif_measure_arg($var28[1].Equals(fromBits(0, 0, false)), cenv_1.g.pint64_tcr, c);
      return new Const(7, $var28[1]);

    case 19:
      unif(cenv_1.g.char_ty);
      return new Const(13, $var28[1]);

    case 20:
      unif(cenv_1.g.string_ty);
      return new Const(14, $var28[1]);

    case 21:
      return error_1(new InternalError(SR.tcUnexpectedBigRationalConstant(), m));

    case 22:
      return error_1(new _Error(SR.tcInvalidTypeForUnitsOfMeasure(), m));

    case 23:
      return error_1(new InternalError(SR.tcUnexpectedConstUint16Array(), m));

    case 24:
      return error_1(new InternalError(SR.tcUnexpectedConstByteArray(), m));
  }
}
export function TcFieldInit(_m, lit) {
  switch (lit.tag) {
    case 13:
      return new Const(17);

    case 1:
      return new Const(0, lit.data);

    case 2:
      return new Const(13, String.fromCharCode(~~lit.data));

    case 3:
      return new Const(1, lit.data);

    case 4:
      return new Const(3, lit.data);

    case 5:
      return new Const(5, lit.data);

    case 6:
      return new Const(7, lit.data);

    case 7:
      return new Const(2, lit.data);

    case 8:
      return new Const(4, lit.data);

    case 9:
      return new Const(6, lit.data);

    case 10:
      return new Const(8, lit.data);

    case 11:
      return new Const(11, lit.data);

    case 12:
      return new Const(12, lit.data);

    default:
      return new Const(14, lit.data);
  }
}
export function AdjustValSynInfoInSignature(g, ty, _arg1) {
  if (((_arg1.data[0].length === 1 ? _arg1.data[0].head.length === 1 : false) ? isFunTy(g, ty) : false) ? typeEquiv(g, g.unit_ty, domainOfFunTy(g, ty)) : false) {
    return new SynValInfo(0, [new List(_arg1.data[0].head.tail, _arg1.data[0].tail), _arg1.data[1]]);
  } else {
    return _arg1;
  }
}
export class PartialValReprInfo {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.PartialValReprInfo",
      interfaces: ["FSharpUnion"],
      cases: [["PartialValReprInfo", makeGeneric(List, {
        T: makeGeneric(List, {
          T: ArgReprInfo
        })
      }), ArgReprInfo]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.PartialValReprInfo", PartialValReprInfo);
export function TranslateTopArgSynInfo(isArg, m, tcAttributes, _arg1) {
  const optAttrs = _arg1.data[1] ? ofArray([new SynAttribute(new LongIdentWithDots(0, [pathToSynLid(m, ofArray(["Microsoft", "FSharp", "Core", "OptionalArgument"])), new List()]), mkSynUnit(m), null, false, m)]) : new List();

  if ((isArg ? !(_arg1.data[0].tail == null) : false) ? _arg1.data[2] == null : false) {
    errorR(new _Error(SR.tcParameterRequiresName(), m));
  }

  if (!isArg ? _arg1.data[2] != null : false) {
    errorR(new _Error(SR.tcReturnValuesCannotHaveNames(), m));
  }

  const attribs = tcAttributes(append(optAttrs, _arg1.data[0]));
  return new ArgReprInfo(attribs, _arg1.data[2]);
}
export function TranslateTopValSynInfo(m, tcAttributes, _arg1) {
  var tcAttributes_1;
  var tcAttributes_2;
  return new PartialValReprInfo(0, [List_1.mapSquared((tcAttributes_1 = CurriedLambda(tcAttributes)(2048), function (arg30_) {
    return TranslateTopArgSynInfo(true, m, tcAttributes_1, arg30_);
  }), _arg1.data[0]), (tcAttributes_2 = CurriedLambda(tcAttributes)(8192), function (arg30__1) {
    return TranslateTopArgSynInfo(false, m, tcAttributes_2, arg30__1);
  })(_arg1.data[1])]);
}
export function TranslatePartialArity(tps, _arg1) {
  return new ValReprInfo(0, [ValReprInfoModule.InferTyparInfo(tps), _arg1.data[0], _arg1.data[1]]);
}
export function ComputeLogicalName(id, memberFlags) {
  switch (memberFlags.MemberKind.tag) {
    case 1:
      return ".ctor";

    case 2:
      const matchValue = id.idText;
      const $var29 = matchValue === ".ctor" ? [0, matchValue] : matchValue === ".cctor" ? [0, matchValue] : [1];

      switch ($var29[0]) {
        case 0:
          errorR(new _Error(SR.tcInvalidMemberNameCtor(), id.idRange));
          return $var29[1];

        case 1:
          return matchValue;
      }

    case 5:
      return error_1(new InternalError(SR.tcMemberKindPropertyGetSetNotExpected(), id.idRange));

    case 3:
      return "get_" + id.idText;

    case 4:
      return "set_" + id.idText;

    default:
      return ".cctor";
  }
}
export class ValMemberInfoTransient {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.ValMemberInfoTransient",
      interfaces: ["FSharpUnion"],
      cases: [["ValMemberInfoTransient", ValMemberInfo, "string", "string"]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.ValMemberInfoTransient", ValMemberInfoTransient);
export function MakeMemberDataAndMangledNameForMemberVal(g, tcref, isExtrinsic, attrs, optImplSlotTys, memberFlags, valSynData, id, isCompGen) {
  const logicalName = ComputeLogicalName(id, memberFlags);
  const optIntfSlotTys = forAll(function (arg10_) {
    return isInterfaceTy(g, arg10_);
  }, optImplSlotTys) ? optImplSlotTys : new List();
  const memberInfo = new ValMemberInfo(tcref, map_1(function (ity) {
    return new SlotSig(0, [logicalName, ity, new List(), new List(), new List(), null]);
  }, optImplSlotTys), false, memberFlags);
  const isInstance = MemberIsCompiledAsInstance(g, tcref, isExtrinsic, memberInfo, attrs);

  if (memberFlags.IsDispatchSlot ? true : !(optIntfSlotTys.tail == null)) {
    if (!isInstance) {
      errorR(new VirtualAugmentationOnNullValuedType(id.idRange));
    }
  } else if (!memberFlags.IsOverrideOrExplicitImpl ? memberFlags.IsInstance : false) {
    if (!isExtrinsic ? !isInstance : false) {
      warning(new NonVirtualAugmentationOnNullValuedType(id.idRange));
    }
  }

  let compiledName;

  if (isExtrinsic) {
    const tname = tcref.LogicalName;
    const text = tname + "." + logicalName;
    const text_1 = ((!memberFlags.MemberKind.Equals(new MemberKind_2(1)) ? !memberFlags.MemberKind.Equals(new MemberKind_2(0)) : false) ? !memberFlags.IsInstance : false) ? text + ".Static" : text;
    const text_2 = memberFlags.IsOverrideOrExplicitImpl ? text_1 + ".Override" : text_1;
    compiledName = text_2;
  } else {
    compiledName = foldBack(($var33, $var34) => ($var32 => ($var30 => $var31 => function (arg00_, arg10__2) {
      return qualifiedMangledNameOfTyconRef(arg00_, arg10__2);
    }($var30, $var31))(function (arg10__1) {
      return tcrefOfAppTy(g, arg10__1);
    }($var32)))($var33)($var34), optIntfSlotTys, logicalName);
  }

  if ((!isCompGen ? IsMangledOpName(id.idText) : false) ? IsInfixOperator(id.idText) : false) {
    const m = id.idRange;
    const name = DecompileOpName(id.idText);
    const matchValue = SynInfo.AritiesOfArgs(valSynData);
    const $var35 = matchValue.tail != null ? matchValue.head === 0 ? matchValue.tail.tail == null ? [0] : [1, matchValue.head, matchValue.tail] : [1, matchValue.head, matchValue.tail] : [0];

    switch ($var35[0]) {
      case 0:
        warning(new _Error(SR.memberOperatorDefinitionWithNoArguments(name), m));
        break;

      case 1:
        const opTakesThreeArgs = IsTernaryOperator(name);

        if ($var35[1] !== 2 ? !opTakesThreeArgs : false) {
          warning(new _Error(SR.memberOperatorDefinitionWithNonPairArgument(name, $var35[1]), m));
        }

        if ($var35[1] !== 3 ? opTakesThreeArgs : false) {
          warning(new _Error(SR.memberOperatorDefinitionWithNonTripleArgument(name, $var35[1]), m));
        }

        if (!($var35[2].tail == null)) {
          warning(new _Error(SR.memberOperatorDefinitionWithCurriedArguments(name), m));
        }

        break;
    }
  }

  if (isExtrinsic ? IsMangledOpName(id.idText) : false) {
    warning(new _Error(SR.tcMemberOperatorDefinitionInExtrinsic(), id.idRange));
  }

  return new ValMemberInfoTransient(0, [memberInfo, logicalName, compiledName]);
}
export class OverridesOK {
  constructor(tag) {
    this.tag = tag | 0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.OverridesOK",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["OverridesOK"], ["WarnOnOverrides"], ["ErrorOnOverrides"]]
    };
  }

  Equals(other) {
    return this.tag === other.tag;
  }

  CompareTo(other) {
    return comparePrimitives(this.tag, other.tag);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.OverridesOK", OverridesOK);
export class ExplicitTyparInfo {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.ExplicitTyparInfo",
      interfaces: ["FSharpUnion"],
      cases: [["ExplicitTyparInfo", makeGeneric(List, {
        T: Typar
      }), makeGeneric(List, {
        T: Typar
      }), "boolean"]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.ExplicitTyparInfo", ExplicitTyparInfo);
export const permitInferTypars = new ExplicitTyparInfo(0, [new List(), new List(), true]);
export const dontInferTypars = new ExplicitTyparInfo(0, [new List(), new List(), false]);
export class ArgAndRetAttribs {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.ArgAndRetAttribs",
      interfaces: ["FSharpUnion"],
      cases: [["ArgAndRetAttribs", makeGeneric(List, {
        T: makeGeneric(List, {
          T: makeGeneric(List, {
            T: Attrib
          })
        })
      }), makeGeneric(List, {
        T: Attrib
      })]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.ArgAndRetAttribs", ArgAndRetAttribs);
export const noArgOrRetAttribs = new ArgAndRetAttribs(0, [new List(), new List()]);
export class DeclKind {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.DeclKind",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["ModuleOrMemberBinding"], ["IntrinsicExtensionBinding"], ["ExtrinsicExtensionBinding"], ["ClassLetBinding", "boolean"], ["ObjectExpressionOverrideBinding"], ["ExpressionBinding"]]
    };
  }

  Equals(other) {
    return this === other || this.tag === other.tag && equals(this.data, other.data);
  }

  CompareTo(other) {
    return compareUnions(this, other) | 0;
  }

  static IsModuleOrMemberOrExtensionBinding(x) {
    switch (x.tag) {
      case 1:
        return true;

      case 2:
        return true;

      case 3:
        return false;

      case 4:
        return false;

      case 5:
        return false;

      default:
        return true;
    }
  }

  static MustHaveArity(x) {
    return DeclKind.IsModuleOrMemberOrExtensionBinding(x);
  }

  get CanBeDllImport() {
    return this.tag === 1 ? true : this.tag === 2 ? true : this.tag === 3 ? true : this.tag === 4 ? false : this.tag === 5 ? false : true;
  }

  static IsAccessModifierPermitted(x) {
    return DeclKind.IsModuleOrMemberOrExtensionBinding(x);
  }

  static ImplicitlyStatic(x) {
    return DeclKind.IsModuleOrMemberOrExtensionBinding(x);
  }

  static AllowedAttribTargets(memberFlagsOpt, x) {
    switch (x.tag) {
      case 4:
        const $var36 = memberFlagsOpt != null ? getValue(memberFlagsOpt).MemberKind.Equals(new MemberKind_2(1)) ? [0, getValue(memberFlagsOpt)] : [1] : [1];

        switch ($var36[0]) {
          case 0:
            return 32;

          case 1:
            const $var37 = memberFlagsOpt != null ? getValue(memberFlagsOpt).MemberKind.Equals(new MemberKind_2(5)) ? [0, getValue(memberFlagsOpt)] : [1] : [1];

            switch ($var37[0]) {
              case 0:
                return 512 | 128 | 0;

              case 1:
                const $var38 = memberFlagsOpt != null ? getValue(memberFlagsOpt).MemberKind.Equals(new MemberKind_2(3)) ? [0, getValue(memberFlagsOpt)] : [1] : [1];

                switch ($var38[0]) {
                  case 0:
                    return 512 | 128 | 0;

                  case 1:
                    const $var39 = memberFlagsOpt != null ? getValue(memberFlagsOpt).MemberKind.Equals(new MemberKind_2(4)) ? [0, getValue(memberFlagsOpt)] : [1] : [1];

                    switch ($var39[0]) {
                      case 0:
                        return 128;

                      case 1:
                        if (memberFlagsOpt == null) {
                          return 256 | 64 | 128 | 0;
                        } else {
                          return 64;
                        }

                    }

                }

            }

        }

      case 1:
        return 64 | 128 | 0;

      case 2:
        return 64 | 128 | 0;

      case 3:
        return 256 | 64 | 0;

      case 5:
        return 0;

      default:
        const $var40 = memberFlagsOpt != null ? getValue(memberFlagsOpt).MemberKind.Equals(new MemberKind_2(1)) ? [0, getValue(memberFlagsOpt)] : [1] : [1];

        switch ($var40[0]) {
          case 0:
            return 32;

          case 1:
            const $var41 = memberFlagsOpt != null ? getValue(memberFlagsOpt).MemberKind.Equals(new MemberKind_2(5)) ? [0, getValue(memberFlagsOpt)] : [1] : [1];

            switch ($var41[0]) {
              case 0:
                return 512 | 128 | 0;

              case 1:
                const $var42 = memberFlagsOpt != null ? getValue(memberFlagsOpt).MemberKind.Equals(new MemberKind_2(3)) ? [0, getValue(memberFlagsOpt)] : [1] : [1];

                switch ($var42[0]) {
                  case 0:
                    return 512 | 128 | 0;

                  case 1:
                    const $var43 = memberFlagsOpt != null ? getValue(memberFlagsOpt).MemberKind.Equals(new MemberKind_2(4)) ? [0, getValue(memberFlagsOpt)] : [1] : [1];

                    switch ($var43[0]) {
                      case 0:
                        return 128;

                      case 1:
                        if (memberFlagsOpt == null) {
                          return 256 | 64 | 128 | 0;
                        } else {
                          return 64;
                        }

                    }

                }

            }

        }

    }
  }

  static CanGeneralizeConstrainedTypars(x) {
    switch (x.tag) {
      case 1:
        return true;

      case 2:
        return true;

      case 3:
        return true;

      case 4:
        return true;

      case 5:
        return true;

      default:
        return true;
    }
  }

  static ConvertToLinearBindings(x) {
    switch (x.tag) {
      case 1:
        return true;

      case 2:
        return true;

      case 3:
        return true;

      case 4:
        return true;

      case 5:
        return false;

      default:
        return true;
    }
  }

  static CanOverrideOrImplement(x) {
    switch (x.tag) {
      case 1:
        return new OverridesOK(1);

      case 2:
        return new OverridesOK(2);

      case 3:
        return new OverridesOK(2);

      case 4:
        return new OverridesOK(0);

      case 5:
        return new OverridesOK(2);

      default:
        return new OverridesOK(0);
    }
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.DeclKind", DeclKind);
export class PrelimValScheme1 {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.PrelimValScheme1",
      interfaces: ["FSharpUnion"],
      cases: [["PrelimValScheme1", Ident, ExplicitTyparInfo, TType, Option(PartialValReprInfo), Option(ValMemberInfoTransient), "boolean", ValInline, ValBaseOrThisInfo, ArgAndRetAttribs, Option(SynAccess), "boolean"]]
    };
  }

  get Type() {
    return this.data[2];
  }

  get Ident() {
    return this.data[0];
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.PrelimValScheme1", PrelimValScheme1);
export class PrelimValScheme2 {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.PrelimValScheme2",
      interfaces: ["FSharpUnion"],
      cases: [["PrelimValScheme2", Ident, TypeScheme, Option(PartialValReprInfo), Option(ValMemberInfoTransient), "boolean", ValInline, ValBaseOrThisInfo, ArgAndRetAttribs, Option(SynAccess), "boolean", "boolean"]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.PrelimValScheme2", PrelimValScheme2);
export class ValScheme {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.ValScheme",
      interfaces: ["FSharpUnion"],
      cases: [["ValScheme", Ident, TypeScheme, Option(ValReprInfo), Option(ValMemberInfoTransient), "boolean", ValInline, ValBaseOrThisInfo, Option(SynAccess), "boolean", "boolean", "boolean", "boolean"]]
    };
  }

  get GeneralizedTypars() {
    const gtps = this.data[1].data[0];
    return gtps;
  }

  get TypeScheme() {
    return this.data[1];
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.ValScheme", ValScheme);
export class TcPatPhase2Input {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.TcPatPhase2Input",
      interfaces: ["FSharpUnion"],
      cases: [["TcPatPhase2Input", makeGeneric(_Map, {
        Key: "string",
        Value: Tuple([Val, TypeScheme])
      }), "boolean"]]
    };
  }

  get RightPath() {
    return new TcPatPhase2Input(0, [this.data[0], false]);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.TcPatPhase2Input", TcPatPhase2Input);
export class CheckedBindingInfo {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.CheckedBindingInfo",
      interfaces: ["FSharpUnion"],
      cases: [["CheckedBindingInfo", ValInline, makeGeneric(List, {
        T: Attrib
      }), XmlDoc, _Function([TcPatPhase2Input, Pattern]), ExplicitTyparInfo, makeGeneric(_Map, {
        Key: "string",
        Value: PrelimValScheme1
      }), Expr, ArgAndRetAttribs, TType, range, SequencePointInfoForBinding, "boolean", Option(Const), "boolean"]]
    };
  }

  get Expr() {
    return this.data[6];
  }

  get SeqPoint() {
    return this.data[10];
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.CheckedBindingInfo", CheckedBindingInfo);
export function GeneralizedTypeForTypeScheme(typeScheme) {
  return tryMkForallTy(typeScheme.data[0], typeScheme.data[1]);
}
export function NonGenericTypeScheme(ty) {
  return new TypeScheme(0, [new List(), ty]);
}
export function UpdateAccModuleOrNamespaceType(cenv_1, env, f) {
  if (cenv_1.compilingCanonicalFslibModuleType) {
    const nleref = mkNonLocalEntityRef(cenv_1.topCcu, arrPathOfLid(env.ePath));
    const modul = nleref.Deref;
    modul.entity_modul_contents = new MaybeLazy(0, f(true, modul.ModuleOrNamespaceType));
  }

  SetCurrAccumulatedModuleOrNamespaceType(env, f(false, GetCurrAccumulatedModuleOrNamespaceType(env)));
}
export function PublishModuleDefn(cenv_1, env, mspec) {
  UpdateAccModuleOrNamespaceType(cenv_1, env, function (intoFslibCcu, mty) {
    return intoFslibCcu ? mty : mty.AddEntity(mspec);
  });
  const item = new Item(18, ofArray([mkLocalModRef(mspec)]));
  CallNameResolutionSink(cenv_1.tcSink, mspec.Range, env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(0), env.DisplayEnv, env.eAccessRights);
}
export function PublishTypeDefn(cenv_1, env, tycon) {
  UpdateAccModuleOrNamespaceType(cenv_1, env, function (_arg1, mty) {
    return mty.AddEntity(tycon);
  });
}
export function PublishValueDefnPrim(cenv_1, env, vspec) {
  UpdateAccModuleOrNamespaceType(cenv_1, env, function (_arg1, mty) {
    return mty.AddVal(vspec);
  });
}
export function PublishValueDefn(cenv_1, env, declKind, vspec) {
  if ((declKind.Equals(new DeclKind(0)) ? GetCurrAccumulatedModuleOrNamespaceType(env).ModuleOrNamespaceKind.Equals(new ModuleOrNamespaceKind(2)) : false) ? vspec.MemberInfo == null : false) {
    errorR(new NumberedError(SR.tcNamespaceCannotContainValues(), vspec.Range));
  }

  if (declKind.Equals(new DeclKind(2)) ? GetCurrAccumulatedModuleOrNamespaceType(env).ModuleOrNamespaceKind.Equals(new ModuleOrNamespaceKind(2)) : false) {
    errorR(new _Error(SR.tcNamespaceCannotContainExtensionMembers(), vspec.Range));
  }

  const $var44 = declKind.tag === 0 ? [0] : declKind.tag === 2 ? [0] : declKind.tag === 1 ? [0] : [1];

  switch ($var44[0]) {
    case 0:
      PublishValueDefnPrim(cenv_1, env, vspec);
      break;

    case 1:
      break;
  }

  const matchValue = vspec.MemberInfo;
  const $var45 = matchValue != null ? (!vspec.IsCompilerGenerated ? !declKind.Equals(new DeclKind(2)) : false) ? [0] : [1] : [1];

  switch ($var45[0]) {
    case 0:
      const tcaug = vspec.MemberApparentEntity.TypeContents;
      const vref = mkLocalValRef(vspec);
      tcaug.tcaug_adhoc = NameMultiMapModule.add(vspec.LogicalName, vref, tcaug.tcaug_adhoc);
      tcaug.tcaug_adhoc_list.push([ValRefIsExplicitImpl(cenv_1.g, vref), vref]);
      break;

    case 1:
      break;
  }
}
export function CombineVisibilityAttribs(vis1, vis2, m) {
  if (vis1 != null) {
    if (vis2 != null) {
      errorR(new _Error(SR.tcMultipleVisibilityAttributes(), m));
    }

    return vis1;
  } else {
    return vis2;
  }
}
export function ComputeAccessAndCompPath(env, declKindOpt, m, vis, overrideVis, actualParent) {
  const accessModPermitted = declKindOpt != null ? DeclKind.IsAccessModifierPermitted(getValue(declKindOpt)) : true;

  if (vis != null ? !accessModPermitted : false) {
    errorR(new _Error(SR.tcMultipleVisibilityAttributesWithLet(), m));
  }

  let vis_1;
  const matchValue = [overrideVis, vis];

  if (matchValue[0] != null) {
    vis_1 = getValue(matchValue[0]);
  } else if (matchValue[1] != null) {
    if (getValue(matchValue[1]).tag === 2) {
      vis_1 = taccessPrivate(env.eAccessPath);
    } else if (getValue(matchValue[1]).tag === 1) {
      vis_1 = taccessInternal;
    } else {
      vis_1 = taccessPublic;
    }
  } else {
    vis_1 = taccessPublic;
  }

  const vis_2 = actualParent.tag === 0 ? combineAccess(vis_1, actualParent.data.Accessibility) : vis_1;
  const cpath = accessModPermitted ? env.eCompPath : null;
  return [vis_2, cpath];
}
export function CheckForAbnormalOperatorNames(cenv_1, idRange, coreDisplayName, memberInfoOpt) {
  if (idRange.EndColumn - idRange.StartColumn <= 5 ? !cenv_1.g.compilingFslib : false) {
    const opName = DecompileOpName(coreDisplayName);
    const isMember = CurriedLambda(() => memberInfoOpt != null)();

    const activePatternResult40281 = _Control_Equality_Relational_Indexer_FixedTypes_Other_(opName);

    if (activePatternResult40281.tag === 1) {
      if (isMember) {
        warning(new StandardOperatorRedefinitionWarning(SR.tcInvalidMethodNameForEquality(opName, coreDisplayName), idRange));
      } else {
        warning(new StandardOperatorRedefinitionWarning(SR.tcInvalidOperatorDefinitionEquality(opName), idRange));
      }
    } else if (activePatternResult40281.tag === 0) {
      if (isMember) {
        warning(new StandardOperatorRedefinitionWarning(SR.tcInvalidMemberName(opName, coreDisplayName), idRange));
      } else {
        warning(new StandardOperatorRedefinitionWarning(SR.tcInvalidOperatorDefinition(opName), idRange));
      }
    } else if (activePatternResult40281.tag === 3) {
      if (!isMember) {
        error_1(new StandardOperatorRedefinitionWarning(SR.tcInvalidIndexOperatorDefinition(opName), idRange));
      }
    } else if (activePatternResult40281.tag === 4) {
      if (isMember) {
        warning(new StandardOperatorRedefinitionWarning(SR.tcInvalidMemberNameFixedTypes(opName), idRange));
      }
    } else if (activePatternResult40281.tag === 5) {} else if (isMember) {
      warning(new StandardOperatorRedefinitionWarning(SR.tcInvalidMethodNameForRelationalOperator(opName, coreDisplayName), idRange));
    } else {
      warning(new StandardOperatorRedefinitionWarning(SR.tcInvalidOperatorDefinitionRelational(opName), idRange));
    }
  }
}
export function MakeAndPublishVal(cenv_1, env, altActualParent, inSig, declKind, vrec, _arg1, attrs, doc, konst, isGeneratedEventVal) {
  var memberInfo;
  const ty = GeneralizedTypeForTypeScheme(_arg1.data[1]);
  const m = _arg1.data[0].idRange;
  const isTopBinding = declKind.tag === 0 ? true : declKind.tag === 2 ? true : declKind.tag === 1 ? true : false;
  const isExtrinsic = declKind.Equals(new DeclKind(2));
  let patternInput;
  const $var46 = _arg1.data[3] != null ? (memberInfo = getValue(_arg1.data[3]).data[0], !isExtrinsic) ? [0, getValue(_arg1.data[3]).data[0]] : [1] : [1];

  switch ($var46[0]) {
    case 0:
      if ($var46[1].ApparentEnclosingEntity.IsModuleOrNamespace) {
        errorR(new InternalError(SR.tcExpectModuleOrNamespaceParent(_arg1.data[0].idText), m));
      }

      let vis;

      if (MemberIsExplicitImpl(cenv_1.g, $var46[1])) {
        const slotSig = $var46[1].ImplementedSlotSigs.head;
        const matchValue = slotSig.ImplementedType;

        if (matchValue.tag === 1) {
          vis = matchValue.data[0].Accessibility;
        } else {
          vis = null;
        }
      } else {
        vis = null;
      }

      patternInput = [new ParentRef(0, $var46[1].ApparentEnclosingEntity), vis];
      break;

    case 1:
      patternInput = [altActualParent, null];
      break;
  }

  const patternInput_1 = ComputeAccessAndCompPath(env, declKind, _arg1.data[0].idRange, _arg1.data[7], patternInput[1], patternInput[0]);
  let inlineFlag;

  if (HasFSharpAttributeOpt(cenv_1.g, cenv_1.g.attrib_DllImportAttribute, attrs)) {
    if (_arg1.data[5].Equals(new ValInline(0)) ? true : _arg1.data[5].Equals(new ValInline(1))) {
      errorR(new _Error(SR.tcDllImportStubsCannotBeInlined(), m));
    }

    inlineFlag = new ValInline(3);
  } else {
    let implflags;
    const matchValue_1 = TryFindFSharpAttribute(cenv_1.g, cenv_1.g.attrib_MethodImplAttribute, attrs);
    let $var47;

    if (matchValue_1 != null) {
      if (getValue(matchValue_1).data[2].tail != null) {
        const activePatternResult40286 = _AttribInt32Arg___(getValue(matchValue_1).data[2].head);

        if (activePatternResult40286 != null) {
          if (getValue(matchValue_1).data[2].tail.tail == null) {
            $var47 = [0, getValue(activePatternResult40286)];
          } else {
            $var47 = [1];
          }
        } else {
          $var47 = [1];
        }
      } else {
        $var47 = [1];
      }
    } else {
      $var47 = [1];
    }

    switch ($var47[0]) {
      case 0:
        implflags = $var47[1] | 0;
        break;

      case 1:
        implflags = 0;
        break;
    }

    if ((implflags & 8) !== 0) {
      inlineFlag = new ValInline(3);
    } else {
      inlineFlag = _arg1.data[5];
    }
  }

  const compiledNameAttrib = TryFindFSharpStringAttribute(cenv_1.g, cenv_1.g.attrib_CompiledNameAttribute, attrs);

  if (compiledNameAttrib != null) {
    if (_arg1.data[3] == null) {
      if (altActualParent.tag === 1) {
        errorR(new _Error(SR.tcCompiledNameAttributeMisused(), m));
      }
    } else {
      const memberInfo_1 = getValue(_arg1.data[3]).data[0];

      if (memberInfo_1.MemberFlags.IsDispatchSlot ? true : memberInfo_1.MemberFlags.IsOverrideOrExplicitImpl) {
        errorR(new _Error(SR.tcCompiledNameAttributeMisused(), m));
      }
    }
  }

  let compiledNameIsOnProp;

  if (_arg1.data[3] != null) {
    const memberInfo_2 = getValue(_arg1.data[3]).data[0];

    if (memberInfo_2.MemberFlags.MemberKind.Equals(new MemberKind_2(3)) ? true : memberInfo_2.MemberFlags.MemberKind.Equals(new MemberKind_2(4))) {
      compiledNameIsOnProp = true;
    } else {
      compiledNameIsOnProp = memberInfo_2.MemberFlags.MemberKind.Equals(new MemberKind_2(5));
    }
  } else {
    compiledNameIsOnProp = false;
  }

  let compiledName_1;
  const $var48 = compiledNameAttrib != null ? !compiledNameIsOnProp ? [0] : [1] : [1];

  switch ($var48[0]) {
    case 0:
      compiledName_1 = compiledNameAttrib;
      break;

    case 1:
      if (_arg1.data[3] == null) {
        compiledName_1 = null;
      } else {
        const compiledName = getValue(_arg1.data[3]).data[2];
        compiledName_1 = compiledName;
      }

      break;
  }

  let logicalName_1;

  if (_arg1.data[3] == null) {
    logicalName_1 = _arg1.data[0].idText;
  } else {
    const logicalName = getValue(_arg1.data[3]).data[1];
    logicalName_1 = logicalName;
  }

  let memberInfoOpt;

  if (_arg1.data[3] == null) {
    memberInfoOpt = null;
  } else {
    const memberInfo_3 = getValue(_arg1.data[3]).data[0];
    memberInfoOpt = memberInfo_3;
  }

  const vspec = NewVal(logicalName_1, _arg1.data[0].idRange, compiledName_1, ty, _arg1.data[4] ? new ValMutability(1) : new ValMutability(0), _arg1.data[8], _arg1.data[2], patternInput_1[0], vrec, memberInfoOpt, _arg1.data[6], attrs, inlineFlag, doc, isTopBinding, isExtrinsic, _arg1.data[9], _arg1.data[10], _arg1.data[11] ? true : inSig, isGeneratedEventVal, konst, patternInput[0]);
  CheckForAbnormalOperatorNames(cenv_1, _arg1.data[0].idRange, vspec.CoreDisplayName, memberInfoOpt);
  PublishValueDefn(cenv_1, env, declKind, vspec);
  const matchValue_2 = cenv_1.tcSink.CurrentSink;

  if (matchValue_2 != null) {
    if (!vspec.IsCompilerGenerated) {
      const matchValue_3 = vspec.MemberInfo;
      const $var49 = matchValue_3 == null ? (vspec.BaseOrThisInfo.Equals(new ValBaseOrThisInfo(3)) ? vspec.LogicalName === "__" : false) ? [0] : [1] : [1];

      switch ($var49[0]) {
        case 0:
          break;

        case 1:
          const nenv = AddFakeNamedValRefToNameEnv(vspec.DisplayName, env.NameEnv, mkLocalValRef(vspec));
          CallEnvSink(cenv_1.tcSink, vspec.Range, nenv, env.eAccessRights);
          const item = new Item(0, mkLocalValRef(vspec));
          CallNameResolutionSink(cenv_1.tcSink, vspec.Range, nenv, item, item, emptyTyparInst, new ItemOccurence(0), env.DisplayEnv, env.eAccessRights);
          break;
      }
    }
  }

  return vspec;
}
export function MakeAndPublishVals(cenv_1, env, altActualParent, inSig, declKind, vrec, valSchemes, attrs, doc, konst) {
  return foldBack_1(function (name, valscheme, values) {
    return add_1(name, [MakeAndPublishVal(cenv_1, env, altActualParent, inSig, declKind, vrec, valscheme, attrs, doc, konst, false), valscheme.TypeScheme], values);
  }, valSchemes, create(null, new Comparer(compare)));
}
export function MakeAndPublishBaseVal(cenv_1, env, baseIdOpt, ty) {
  return defaultArg(baseIdOpt, null, function (id) {
    const valscheme = new ValScheme(0, [id, NonGenericTypeScheme(ty), null, null, false, new ValInline(3), new ValBaseOrThisInfo(1), null, false, false, false, false]);
    return MakeAndPublishVal(cenv_1, env, new ParentRef(1), false, new DeclKind(5), new ValRecursiveScopeInfo(1), valscheme, new List(), XmlDoc.Empty, null, false);
  });
}
export function InstanceMembersNeedSafeInitCheck(cenv_1, m, thisTy) {
  return ExistsInEntireHierarchyOfType(function (ty) {
    if (!isStructTy(cenv_1.g, ty)) {
      const matchValue = tryDestAppTy(cenv_1.g, ty);
      const $var50 = matchValue != null ? getValue(matchValue).HasSelfReferentialConstructor ? [0, getValue(matchValue)] : [1] : [1];

      switch ($var50[0]) {
        case 0:
          return true;

        case 1:
          return false;
      }
    } else {
      return false;
    }
  }, cenv_1.g, cenv_1.amap, m, new AllowMultiIntfInstantiations(0), thisTy);
}
export function MakeSafeInitField(g, env, m, isStatic) {
  const id = ident(globalNng.FreshCompilerGeneratedName("init", m), m);
  const taccess = new Accessibility(0, ofArray([env.eAccessPath]));
  return NewRecdField(isStatic, null, id, false, g.int_ty, true, true, new List(), new List(), XmlDoc.Empty, taccess, true);
}
export function ComputeInstanceSafeInitInfo(cenv_1, env, m, thisTy) {
  if (InstanceMembersNeedSafeInitCheck(cenv_1, m, thisTy)) {
    const rfield = MakeSafeInitField(cenv_1.g, env, m, false);
    const tcref = tcrefOfAppTy(cenv_1.g, thisTy);
    return new SafeInitData(0, [mkRecdFieldRef(tcref, rfield.Name), rfield]);
  } else {
    return new SafeInitData(1);
  }
}
export function MakeAndPublishSafeThisVal(cenv_1, env, thisIdOpt, thisTy) {
  if (thisIdOpt == null) {
    return null;
  } else {
    if (!isFSharpObjModelTy(cenv_1.g, thisTy)) {
      errorR(new _Error(SR.tcStructsCanOnlyBindThisAtMemberDeclaration(), getValue(thisIdOpt).idRange));
    }

    const valScheme = new ValScheme(0, [getValue(thisIdOpt), NonGenericTypeScheme(mkRefCellTy(cenv_1.g, thisTy)), null, null, false, new ValInline(3), new ValBaseOrThisInfo(0), null, false, false, false, false]);
    return MakeAndPublishVal(cenv_1, env, new ParentRef(1), false, new DeclKind(5), new ValRecursiveScopeInfo(1), valScheme, new List(), XmlDoc.Empty, null, false);
  }
}
export function AdjustAndForgetUsesOfRecValue(cenv_1, vrefTgt, valScheme) {
  const patternInput = valScheme.TypeScheme;
  const fty = GeneralizedTypeForTypeScheme(valScheme.TypeScheme);
  const lvrefTgt = vrefTgt.Deref;

  if (!(patternInput.data[0].tail == null)) {
    const recUses = cenv_1.recUses.Find(lvrefTgt);
    iterate(function (tupledArg) {
      if (!tupledArg[2]) {
        let fixedUpExpr;
        let patternInput_1;
        const matchValue = tupledArg[0].contents;
        const $var51 = matchValue.tag === 5 ? matchValue.data[0].tag === 1 ? matchValue.data[3].tail == null ? [0, matchValue.data[2], matchValue.data[0].data[1]] : [2] : [2] : matchValue.tag === 1 ? [1, matchValue.data[1]] : [2];

        switch ($var51[0]) {
          case 0:
            patternInput_1 = [$var51[2], $var51[1]];
            break;

          case 1:
            patternInput_1 = [$var51[1], new List()];
            break;

          case 2:
            errorR(new _Error(SR.tcUnexpectedExprAtRecInfPoint(), tupledArg[1]));
            patternInput_1 = [new ValUseFlag(1), new List()];
            break;
        }

        const ityargs = generalizeTypars(List_1.drop(patternInput_1[1].length, patternInput.data[0]));
        fixedUpExpr = primMkApp([new Expr(1, [vrefTgt, patternInput_1[0], tupledArg[1]]), fty], append(patternInput_1[1], ityargs), new List(), tupledArg[1]);
        tupledArg[0].contents = fixedUpExpr;
      }
    }, recUses);
  }

  vrefTgt.Deref.SetValRec(new ValRecursiveScopeInfo(1));
  cenv_1.recUses = cenv_1.recUses.Remove(vrefTgt.Deref);
}
export function AdjustRecType(_cenv, vspec, _arg1) {
  const fty = GeneralizedTypeForTypeScheme(_arg1.data[1]);
  vspec.SetType(fty);
  vspec.SetValReprInfo(_arg1.data[2]);
  vspec.SetValRec(new ValRecursiveScopeInfo(0, true));
}
export function RecordUseOfRecValue(cenv_1, vrec, vrefTgt, vexp, m) {
  if (vrec.tag === 1) {
    return vexp;
  } else {
    const fixupPoint = {
      contents: vexp
    };
    cenv_1.recUses = cenv_1.recUses.Add(vrefTgt.Deref, [fixupPoint, m, vrec.data]);
    return new Expr(14, fixupPoint);
  }
}
export class RecursiveUseFixupPoints {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.RecursiveUseFixupPoints",
      interfaces: ["FSharpUnion"],
      cases: [["RecursiveUseFixupPoints", makeGeneric(List, {
        T: Tuple([Any, range])
      })]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.RecursiveUseFixupPoints", RecursiveUseFixupPoints);
export function GetAllUsesOfRecValue(cenv_1, vrefTgt) {
  return new RecursiveUseFixupPoints(0, map_1(function (tupledArg) {
    return [tupledArg[0], tupledArg[1]];
  }, cenv_1.recUses.Find(vrefTgt)));
}
export function ChooseCanonicalDeclaredTyparsAfterInference(g, denv, declaredTypars, m) {
  iterate(function (tp) {
    const ty = mkTyparTy(tp);

    if (!isAnyParTy(g, ty)) {
      error_1(new _Error(SR.tcLessGenericBecauseOfAnnotation(tp.Name, prettyStringOfTy(denv, ty)), tp.Range));
    }
  }, declaredTypars);
  const declaredTypars_1 = NormalizeDeclaredTyparsForEquiRecursiveInference(g, declaredTypars);

  if (ListSet.setify(function (lv1, lv2) {
    return typarEq(lv1, lv2);
  }, declaredTypars_1).length !== declaredTypars_1.length) {
    errorR(new _Error(SR.tcConstrainedTypeVariableCannotBeGeneralized(), m));
  }

  return declaredTypars_1;
}
export function ChooseCanonicalValSchemeAfterInference(g, denv, valscheme, m) {
  const generalizedTypars = ChooseCanonicalDeclaredTyparsAfterInference(g, denv, valscheme.data[1].data[0], m);
  const typeScheme = new TypeScheme(0, [generalizedTypars, valscheme.data[1].data[1]]);
  const valscheme_1 = new ValScheme(0, [valscheme.data[0], typeScheme, valscheme.data[2], valscheme.data[3], valscheme.data[4], valscheme.data[5], valscheme.data[6], valscheme.data[7], valscheme.data[8], valscheme.data[9], valscheme.data[10], valscheme.data[11]]);
  return valscheme_1;
}
export function PlaceTyparsInDeclarationOrder(declaredTypars, generalizedTypars) {
  return append(declaredTypars, filter(function (tp) {
    return !exists_1(CurriedLambda(function (lv1, lv2) {
      return typarEq(lv1, lv2);
    })(tp), declaredTypars);
  }, generalizedTypars));
}
export function SetTyparRigid(_g, denv, m, tp) {
  const matchValue = tp.Solution;

  if (matchValue != null) {
    if (tp.IsCompilerGenerated) {
      errorR(new _Error(SR.tcGenericParameterHasBeenConstrained(prettyStringOfTy(denv, getValue(matchValue))), m));
    } else {
      errorR(new _Error(SR.tcTypeParameterHasBeenConstrained(prettyStringOfTy(denv, getValue(matchValue))), tp.Range));
    }
  }

  tp.SetRigidity(new TyparRigidity(0));
}
export function GeneralizeVal(cenv_1, denv, enclosingDeclaredTypars, generalizedTyparsForThisBinding, _arg1) {
  const m = _arg1.data[0].idRange;
  const allDeclaredTypars = append(enclosingDeclaredTypars, _arg1.data[1].data[1]);
  const allDeclaredTypars_1 = ChooseCanonicalDeclaredTyparsAfterInference(cenv_1.g, denv, allDeclaredTypars, m);

  const computeRelevantTypars = function (thruFlag) {
    const ftps = freeInTypeLeftToRight(cenv_1.g, thruFlag, _arg1.data[2]);
    const generalizedTypars = filter(function (tp) {
      return exists_1(CurriedLambda(function (lv1, lv2) {
        return typarEq(lv1, lv2);
      })(tp), ftps);
    }, generalizedTyparsForThisBinding);
    const generalizedTypars_1 = PlaceTyparsInDeclarationOrder(allDeclaredTypars_1, generalizedTypars);
    return generalizedTypars_1;
  };

  const generalizedTypars_2 = computeRelevantTypars(false);
  const generalizedTyparsLookingThroughTypeAbbreviations = computeRelevantTypars(true);

  if (!(generalizedTypars_2.length === generalizedTyparsLookingThroughTypeAbbreviations.length ? forAll2(function (lv1_1, lv2_1) {
    return typarEq(lv1_1, lv2_1);
  }, generalizedTypars_2, generalizedTyparsLookingThroughTypeAbbreviations) : false)) {
    warning(new _Error(SR.tcTypeParametersInferredAreNotStable(), m));
  }

  const hasDeclaredTypars = !(_arg1.data[1].data[1].tail == null);
  const tyScheme = new TypeScheme(0, [generalizedTypars_2, _arg1.data[2]]);
  return new PrelimValScheme2(0, [_arg1.data[0], tyScheme, _arg1.data[3], _arg1.data[4], _arg1.data[5], _arg1.data[6], _arg1.data[7], _arg1.data[8], _arg1.data[9], _arg1.data[10], hasDeclaredTypars]);
}
export function GeneralizeVals(cenv_1, denv, enclosingDeclaredTypars, generalizedTypars, types) {
  return NameMapModule.map(function (arg40_) {
    return GeneralizeVal(cenv_1, denv, enclosingDeclaredTypars, generalizedTypars, arg40_);
  }, types);
}
export function DontGeneralizeVals(types) {
  const dontGeneralizeVal = function (_arg1) {
    return new PrelimValScheme2(0, [_arg1.data[0], NonGenericTypeScheme(_arg1.data[2]), _arg1.data[3], _arg1.data[4], _arg1.data[5], _arg1.data[6], _arg1.data[7], _arg1.data[8], _arg1.data[9], _arg1.data[10], false]);
  };

  return NameMapModule.map(dontGeneralizeVal, types);
}
export function InferGenericArityFromTyScheme(_arg1, partialValReprInfo) {
  return TranslatePartialArity(_arg1.data[0], partialValReprInfo);
}
export function ComputeIsTyFunc(id, hasDeclaredTypars, arityInfo) {
  if (hasDeclaredTypars) {
    if (arityInfo != null) {
      return getValue(arityInfo).NumCurriedArgs === 0;
    } else {
      return error_1(new _Error(SR.tcExplicitTypeParameterInvalid(), id.idRange));
    }
  } else {
    return false;
  }
}
export function UseSyntacticArity(declKind, typeScheme, partialValReprInfo) {
  if (DeclKind.MustHaveArity(declKind)) {
    return InferGenericArityFromTyScheme(typeScheme, partialValReprInfo);
  } else {
    return null;
  }
}
export function CombineSyntacticAndInferredArities(g, declKind, rhsExpr, prelimScheme) {
  const retAttribs = prelimScheme.data[7].data[1];
  const argAttribs = prelimScheme.data[7].data[0];
  const matchValue = [prelimScheme.data[2], DeclKind.MustHaveArity(declKind)];

  if (matchValue[1]) {
    if (matchValue[0] == null) {
      return new PartialValReprInfo(0, [new List(), ValReprInfoModule.unnamedRetVal]);
    } else if (CurriedLambda(() => prelimScheme.data[3] != null)()) {
      return prelimScheme.data[2];
    } else {
      const $var52 = matchValue[0] != null ? matchValue[1] ? [0, getValue(matchValue[0])] : [1] : [1];

      switch ($var52[0]) {
        case 0:
          let partialArityInfo;

          if (prelimScheme.data[4]) {
            partialArityInfo = new PartialValReprInfo(0, [new List(), $var52[1].data[1]]);
          } else {
            const patternInput = InferArityOfExpr(g, new AllowTypeDirectedDetupling(0), GeneralizedTypeForTypeScheme(prelimScheme.data[1]), argAttribs, retAttribs, rhsExpr);

            const choose = function (ai1, ai2) {
              const matchValue_1 = [ai1, ai2];

              if (matchValue_1[0].tail == null) {
                return new List();
              } else if (matchValue_1[1].tail == null) {
                return matchValue_1[0];
              } else if (ai1.length < ai2.length) {
                return ai2;
              } else {
                return ai1;
              }
            };

            const loop = function (ais1, ais2) {
              const matchValue_2 = [ais1, ais2];
              const $var53 = matchValue_2[0].tail != null ? matchValue_2[1].tail != null ? [1, matchValue_2[0].head, matchValue_2[1].head, matchValue_2[0].tail, matchValue_2[1].tail] : [0, matchValue_2[0]] : [0, matchValue_2[1]];

              switch ($var53[0]) {
                case 0:
                  return $var53[1];

                case 1:
                  return new List(choose($var53[1], $var53[2]), loop($var53[3], $var53[4]));
              }
            };

            const curriedArgInfos = loop($var52[1].data[0], patternInput.data[1]);
            partialArityInfo = new PartialValReprInfo(0, [curriedArgInfos, $var52[1].data[1]]);
          }

          return partialArityInfo;

        case 1:
          throw new Error("C:/projects/fcs/src/fsharp/TypeChecker.fs", 1816, 10);
      }
    }
  } else {
    return null;
  }
}
export function BuildValScheme(declKind, partialArityInfoOpt, prelimScheme) {
  const topValInfo = DeclKind.MustHaveArity(declKind) ? defaultArg(partialArityInfoOpt, null, function (partialValReprInfo) {
    return InferGenericArityFromTyScheme(prelimScheme.data[1], partialValReprInfo);
  }) : null;
  const isTyFunc = ComputeIsTyFunc(prelimScheme.data[0], prelimScheme.data[10], topValInfo);
  return new ValScheme(0, [prelimScheme.data[0], prelimScheme.data[1], topValInfo, prelimScheme.data[3], prelimScheme.data[4], prelimScheme.data[5], prelimScheme.data[6], prelimScheme.data[8], prelimScheme.data[9], false, isTyFunc, prelimScheme.data[10]]);
}
export function UseCombinedArity(g, declKind, rhsExpr, prelimScheme) {
  const partialArityInfoOpt = CombineSyntacticAndInferredArities(g, declKind, rhsExpr, prelimScheme);
  return BuildValScheme(declKind, partialArityInfoOpt, prelimScheme);
}
export function UseNoArity(prelimScheme) {
  return BuildValScheme(new DeclKind(5), null, prelimScheme);
}
export function MakeSimpleVals(cenv_1, env, names) {
  const tyschemes = DontGeneralizeVals(names);
  const valSchemes = NameMapModule.map(function (prelimScheme) {
    return UseNoArity(prelimScheme);
  }, tyschemes);
  const values = MakeAndPublishVals(cenv_1, env, new ParentRef(1), false, new DeclKind(5), new ValRecursiveScopeInfo(1), valSchemes, new List(), XmlDoc.Empty, null);
  const vspecMap = NameMapModule.map(function (tuple) {
    return tuple[0];
  }, values);
  return [values, vspecMap];
}
export function MakeAndPublishSimpleVals(cenv_1, env, m, names, mergeNamesInOneNameresEnv) {
  var folder;
  let patternInput_3;

  if (!mergeNamesInOneNameresEnv) {
    patternInput_3 = MakeSimpleVals(cenv_1, env, names);
  } else {
    const nameResolutions = [];
    let patternInput;
    const sink = {
      NotifyEnvWithScope(_arg1, _arg2, _arg3) {},

      NotifyNameResolution(pos, item, itemGroup, itemTyparInst, occurence, denv, nenv, ad, m_1, replacing) {
        if (!m_1.IsSynthetic) {
          nameResolutions.push([pos, item, itemGroup, itemTyparInst, occurence, denv, nenv, ad, m_1, replacing]);
        }
      },

      NotifyExprHasType(_arg4, _arg5, _arg6, _arg7, _arg8, _arg9) {},

      NotifyFormatSpecifierLocation(_arg10, _arg11) {},

      NotifyOpenDeclaration(_arg12) {},

      get CurrentSource() {
        return null;
      },

      [_Symbol.reflection]() {
        return {
          interfaces: ["Microsoft.FSharp.Compiler.NameResolution.ITypecheckResultsSink"]
        };
      }

    };

    const _h = WithNewTypecheckResultsSink(sink, cenv_1.tcSink);

    try {
      patternInput = MakeSimpleVals(cenv_1, env, names);
    } finally {
      if (hasInterface(_h, "System.IDisposable")) {
        _h.Dispose();
      }
    }

    if (nameResolutions.length !== 0) {
      const patternInput_1 = nameResolutions[0];
      const patternInput_2 = (folder = function (tupledArg, tupledArg_1) {
        let item;

        if (tupledArg_1[1].tag === 0) {
          item = tupledArg_1[1].data;
        } else {
          throw new Error("impossible");
        }

        return [AddFakeNamedValRefToNameEnv(item.DisplayName, tupledArg[0], item), unionRanges(tupledArg_1[8], tupledArg[1])];
      }, function (tupledArg_2, source) {
        return fold(folder, [tupledArg_2[0], tupledArg_2[1]], source);
      })([env.NameEnv, patternInput_1[8]], nameResolutions);
      CallEnvSink(cenv_1.tcSink, patternInput_2[1], patternInput_2[0], patternInput_1[7]);

      for (let forLoopVar of nameResolutions) {
        CallNameResolutionSink(cenv_1.tcSink, forLoopVar[8], patternInput_2[0], forLoopVar[1], forLoopVar[2], forLoopVar[3], forLoopVar[4], forLoopVar[5], forLoopVar[7]);
      }
    }

    patternInput_3 = [patternInput[0], patternInput[1]];
  }

  const envinner = AddLocalValMap(cenv_1.tcSink, m, patternInput_3[1], env);
  return [envinner, patternInput_3[0], patternInput_3[1]];
}
export function FreshenTyconRef(m, rigid, tcref, declaredTyconTypars) {
  const tps = copyTypars(declaredTyconTypars);

  if (!rigid.Equals(new TyparRigidity(0))) {
    iterate(function (tp) {
      tp.SetRigidity(rigid);
    }, tps);
  }

  const patternInput = FixupNewTypars(m, new List(), new List(), declaredTyconTypars, tps);
  return [new TType(1, [tcref, map_1(function (tp_1) {
    return mkTyparTy(tp_1);
  }, declaredTyconTypars)]), tps, patternInput[0], new TType(1, [tcref, patternInput[1]])];
}
export function FreshenPossibleForallTy(g, m, rigid, ty) {
  const patternInput = tryDestForallTy(g, ty);

  if (patternInput[0].tail == null) {
    return [new List(), new List(), new List(), patternInput[1]];
  } else {
    const tpsorig = NormalizeDeclaredTyparsForEquiRecursiveInference(g, patternInput[0]);
    const patternInput_1 = CopyAndFixupTypars(m, rigid, tpsorig);
    return [tpsorig, patternInput_1[0], patternInput_1[2], instType(patternInput_1[1], patternInput[1])];
  }
}
export function infoOfTyconRef(m, tcref) {
  const patternInput = FreshenTypeInst(m, tcref.Typars(m));
  return [patternInput[0], patternInput[1], patternInput[2], new TType(1, [tcref, patternInput[2]])];
}
export function FreshenAbstractSlot(g, amap, m, synTyparDecls, absMethInfo) {
  let typarsFromAbsSlotAreRigid;

  if (synTyparDecls.data[1] ? !(synTyparDecls.data[0].tail == null) : false) {
    errorR(new _Error(SR.tcOverridingMethodRequiresAllOrNoTypeParameters(), m));
  }

  typarsFromAbsSlotAreRigid = synTyparDecls.data[0].tail == null;
  const patternInput = CompiledSigOfMeth(g, amap, m, absMethInfo);
  let patternInput_1;
  const ttps = absMethInfo.GetFormalTyparsOfDeclaringType(m);
  const ttinst = argsOfAppTy(g, absMethInfo.ApparentEnclosingType);
  const rigid = typarsFromAbsSlotAreRigid ? new TyparRigidity(0) : new TyparRigidity(3);
  patternInput_1 = FreshenAndFixupTypars(m, rigid, ttps, ttinst, patternInput.data[2]);
  const argTysFromAbsSlot = List_1.mapSquared(function (arg10_) {
    return instType(patternInput_1[1], arg10_);
  }, patternInput.data[0]);

  const retTyFromAbsSlot = function (arg10__1) {
    return instType(patternInput_1[1], arg10__1);
  }(function (arg10__2) {
    return GetFSharpViewOfReturnType(g, arg10__2);
  }(patternInput.data[1]));

  return [typarsFromAbsSlotAreRigid, patternInput_1[0], argTysFromAbsSlot, retTyFromAbsSlot];
}
export function BuildFieldMap(cenv_1, env, isPartial, ty, flds, m) {
  var f;

  if (flds.tail == null) {
    throw new Error("BuildFieldMap" + "\nParameter name: " + "flds");
  }

  let frefSets;
  const allFields = map_1(function (tupledArg) {
    return tupledArg[0][1];
  }, flds);
  frefSets = map_1(function (tupledArg_1) {
    const frefSet = ResolveField(cenv_1.tcSink, cenv_1.nameResolver, env.eNameResEnv, env.eAccessRights, ty, tupledArg_1[0][0], tupledArg_1[0][1], allFields);
    return [tupledArg_1[0], frefSet, tupledArg_1[1]];
  }, flds);
  const relevantTypeSets = map_1(function (tupledArg_2) {
    return map_1(function (_arg3) {
      return _arg3.data[0].TyconRef;
    }, tupledArg_2[1]);
  }, frefSets);
  let tcref;
  const matchValue = fold((f = function (arg10_, arg20_) {
    return tyconRefEq(cenv_1.g, arg10_, arg20_);
  }, function (l1, l2) {
    return ListSet.intersect(f, l1, l2);
  }), relevantTypeSets.head, relevantTypeSets.tail);
  const $var54 = matchValue.tail != null ? matchValue.tail.tail == null ? [0, matchValue.head] : [1, matchValue] : [1, matchValue];

  switch ($var54[0]) {
    case 0:
      tcref = $var54[1];
      break;

    case 1:
      if (isPartial) {
        warning(new _Error(SR.tcFieldsDoNotDetermineUniqueRecordType(), m));
      }

      const matchValue_1 = tryFind(function (tc) {
        return tc.TrueFieldsAsList.length === flds.length;
      }, $var54[1]);

      if (matchValue_1 != null) {
        tcref = getValue(matchValue_1);
      } else {
        const patternInput = frefSets.head;
        const patternInput_1 = patternInput[1].head;
        tcref = patternInput_1.data[0].TyconRef;
      }

      break;
  }

  const patternInput_4 = fold(function (tupledArg_3, tupledArg_4) {
    var copyOfStruct;
    const matchValue_2 = filter(function (_arg6) {
      return tyconRefEq(cenv_1.g, tcref, _arg6.data[0].TyconRef);
    }, tupledArg_4[1]);
    const $var55 = matchValue_2.tail != null ? matchValue_2.tail.tail == null ? [0, matchValue_2.head.data[0], matchValue_2.head.data[1]] : [1] : [1];

    switch ($var55[0]) {
      case 0:
        const item = FreshenRecdFieldRef(cenv_1.nameResolver, m, $var55[1]);
        CallNameResolutionSink(cenv_1.tcSink, (copyOfStruct = tupledArg_4[0][1], copyOfStruct.idRange), env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, env.eAccessRights);
        CheckRecdFieldAccessible(cenv_1.amap, m, env.eAccessRights, $var55[1]);
        CommitOperationResult(CheckFSharpAttributes(cenv_1.g, $var55[1].PropertyAttribs, m));

        if (tupledArg_3[0].has($var55[1].FieldName)) {
          errorR(new _Error(SR.tcFieldAppearsTwiceInRecord($var55[1].FieldName), m));
        }

        if ($var55[2]) {
          warning(new Deprecated(SR.nrRecordTypeNeedsQualifiedAccess($var55[1].FieldName, $var55[1].Tycon.DisplayName)[1], m));
        }

        if (!tyconRefEq(cenv_1.g, tcref, $var55[1].TyconRef)) {
          const patternInput_2 = frefSets.head;
          const patternInput_3 = patternInput_2[1].head;
          errorR(new FieldsFromDifferentTypes(env.DisplayEnv, patternInput_3.data[0], $var55[1], m));
          return [tupledArg_3[0], tupledArg_3[1]];
        } else {
          return [add_1($var55[1].FieldName, tupledArg_4[2], tupledArg_3[0]), new List([$var55[1].FieldName, tupledArg_4[2]], tupledArg_3[1])];
        }

      case 1:
        return error_1(new _Error(SR.tcRecordFieldInconsistentTypes(), m));
    }
  }, [create(null, new Comparer(comparePrimitives)), new List()], frefSets);
  return [tcref, patternInput_4[0], reverse(patternInput_4[1])];
}
export function ApplyUnionCaseOrExn(makerForUnionCase, makerForExnTag, m, cenv_1, env, overallTy, item) {
  if (item.tag === 4) {
    CommitOperationResult(CheckEntityAttributes(cenv_1.g, item.data, m));
    UnifyTypes(cenv_1, env, m, overallTy, cenv_1.g.exn_ty);
    CheckTyconAccessible(cenv_1.amap, m, env.eAccessRights, item.data);
    const mkf = makerForExnTag(item.data);
    return [mkf, recdFieldTysOfExnDefRef(item.data), toList(delay(function () {
      return map_2(function (f) {
        return f.Id;
      }, recdFieldsOfExnDefRef(item.data));
    }))];
  } else if (item.tag === 1) {
    if (item.data[1]) {
      warning(new Deprecated(SR.nrUnionTypeNeedsQualifiedAccess(item.data[0].Name, item.data[0].Tycon.DisplayName)[1], m));
    }

    const ucref = item.data[0].UnionCaseRef;
    CommitOperationResult(CheckUnionCaseAttributes(cenv_1.g, ucref, m));
    CheckUnionCaseAccessible(cenv_1.amap, m, env.eAccessRights, ucref);
    const gtyp2 = actualResultTyOfUnionCase(item.data[0].TypeInst, ucref);
    const inst = mkTyparInst(ucref.TyconRef.TyparsNoRange, item.data[0].TypeInst);
    UnifyTypes(cenv_1, env, m, overallTy, gtyp2);
    const mkf_1 = makerForUnionCase([ucref, item.data[0].TypeInst]);
    return [mkf_1, actualTysOfUnionCaseFields(inst, ucref), toList(delay(function () {
      return map_2(function (f_1) {
        return f_1.Id;
      }, ucref.AllFieldsAsList);
    }))];
  } else {
    throw new Error("not a union case or exception reference" + "\nParameter name: " + "item");
  }
}
export function ApplyUnionCaseOrExnTypes(m, cenv_1, env, overallTy, c) {
  return ApplyUnionCaseOrExn($var56 => CurriedLambda(function (tupledArg, mArgs, args) {
    return mkUnionCaseExpr(tupledArg[0], tupledArg[1], args, unionRanges(m, mArgs));
  })($var56), $var57 => CurriedLambda(function (a, mArgs_1, args_1) {
    return mkExnExpr(a, args_1, unionRanges(m, mArgs_1));
  })($var57), m, cenv_1, env, overallTy, c);
}
export function ApplyUnionCaseOrExnTypesForPat(m, cenv_1, env, overallTy, c) {
  return ApplyUnionCaseOrExn($var58 => CurriedLambda(function (tupledArg, mArgs, args) {
    return new Pattern(6, [tupledArg[0], tupledArg[1], args, unionRanges(m, mArgs)]);
  })($var58), $var59 => CurriedLambda(function (a, mArgs_1, args_1) {
    return new Pattern(7, [a, args_1, unionRanges(m, mArgs_1)]);
  })($var59), m, cenv_1, env, overallTy, c);
}
export function UnionCaseOrExnCheck(env, nargtys, nargs, m) {
  if (nargs !== nargtys) {
    error_1(new UnionCaseWrongArguments(env.DisplayEnv, nargtys, nargs, m));
  }
}
export function TcUnionCaseOrExnField(cenv_1, env, ty1, m, c, n, funcs_0, funcs_1) {
  const funcs = [funcs_0, funcs_1];
  let patternInput;
  const matchValue = ResolvePatternLongIdent(cenv_1.tcSink, cenv_1.nameResolver, new WarnOnUpperFlag(1), false, m, env.eAccessRights, env.eNameResEnv, TypeNameResolutionInfo.Default, c);
  const $var60 = matchValue.tag === 1 ? [0, matchValue] : matchValue.tag === 4 ? [0, matchValue] : [1];

  switch ($var60[0]) {
    case 0:
      patternInput = ApplyUnionCaseOrExn(funcs[0], funcs[1], m, cenv_1, env, ty1, $var60[1]);
      break;

    case 1:
      patternInput = error_1(new _Error(SR.tcUnknownUnion(), m));
      break;
  }

  const argstysLength = patternInput[1].length | 0;

  if (n >= argstysLength) {
    error_1(new UnionCaseWrongNumberOfArgs(env.DisplayEnv, argstysLength, n, m));
  }

  const ty2 = item_6(n, patternInput[1]);
  return [patternInput[0], ty2];
}
export class SyntacticUnscopedTyparEnv {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.SyntacticUnscopedTyparEnv",
      interfaces: ["FSharpUnion"],
      cases: [["UnscopedTyparEnv", makeGeneric(_Map, {
        Key: "string",
        Value: Typar
      })]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.SyntacticUnscopedTyparEnv", SyntacticUnscopedTyparEnv);
export const emptyUnscopedTyparEnv = new SyntacticUnscopedTyparEnv(0, create(null, new Comparer(comparePrimitives)));
export function AddUnscopedTypar(n, p, _arg1) {
  return new SyntacticUnscopedTyparEnv(0, add_1(n, p, _arg1.data));
}
export function TryFindUnscopedTypar(n, _arg1) {
  return tryFind_1(n, _arg1.data);
}
export function HideUnscopedTypars(typars, _arg1) {
  return new SyntacticUnscopedTyparEnv(0, fold(function (acc, tp) {
    return remove(tp.Name, acc);
  }, _arg1.data, typars));
}
export class GeneralizeConstrainedTyparOptions {
  constructor(tag) {
    this.tag = tag | 0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.GeneralizeConstrainedTyparOptions",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["CanGeneralizeConstrainedTypars"], ["DoNotGeneralizeConstrainedTypars"]]
    };
  }

  Equals(other) {
    return this.tag === other.tag;
  }

  CompareTo(other) {
    return comparePrimitives(this.tag, other.tag);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.GeneralizeConstrainedTyparOptions", GeneralizeConstrainedTyparOptions);
export const GeneralizationHelpers = function (__exports) {
  const ComputeUngeneralizableTypars = __exports.ComputeUngeneralizableTypars = function (env) {
    const acc = [];

    for (let item of env.eUngeneralizableItems) {
      if (!item.WillNeverHaveFreeTypars) {
        const ftps = item.GetFreeTyvars().FreeTypars;

        if (!ftps.IsEmpty) {
          for (let ftp of ftps) {
            acc.push(ftp);
          }
        }
      }
    }

    return _Set.Create(typarOrder, acc);
  };

  const ComputeUnabstractableTycons = __exports.ComputeUnabstractableTycons = function (env) {
    const acc_in_free_item = function (acc, item) {
      let ftycs;

      if (item.WillNeverHaveFreeTypars) {
        ftycs = item.CachedFreeLocalTycons;
      } else {
        const ftyvs = item.GetFreeTyvars();
        ftycs = ftyvs.FreeTycons;
      }

      if (ftycs.IsEmpty) {
        return acc;
      } else {
        return unionFreeTycons(ftycs, acc);
      }
    };

    return fold(acc_in_free_item, emptyFreeTycons, env.eUngeneralizableItems);
  };

  const ComputeUnabstractableTraitSolutions = __exports.ComputeUnabstractableTraitSolutions = function (env) {
    const acc_in_free_item = function (acc, item) {
      let ftycs;

      if (item.WillNeverHaveFreeTypars) {
        ftycs = item.CachedFreeTraitSolutions;
      } else {
        const ftyvs = item.GetFreeTyvars();
        ftycs = ftyvs.FreeTraitSolutions;
      }

      if (ftycs.IsEmpty) {
        return acc;
      } else {
        return unionFreeLocals(ftycs, acc);
      }
    };

    return fold(acc_in_free_item, emptyFreeLocals, env.eUngeneralizableItems);
  };

  const IsGeneralizableValue = __exports.IsGeneralizableValue = function (g, t) {
    var inputTy;
    var e1;
    var actualTy;
    var vref;

    IsGeneralizableValue: while (true) {
      const $var61 = t.tag === 3 ? [0] : t.tag === 4 ? [0] : t.tag === 0 ? [0] : t.tag === 1 ? [0] : t.tag === 11 ? t.data[0].tag === 24 ? t.data[1].tail != null ? t.data[1].tail.tail != null ? t.data[1].tail.tail.tail == null ? t.data[2].tail != null ? t.data[2].tail.tail == null ? (inputTy = t.data[1].head, e1 = t.data[2].head, actualTy = t.data[1].tail.head, isFunTy(g, actualTy) ? isFunTy(g, inputTy) : false) ? [1, t.data[1].tail.head, t.data[2].head, t.data[1].head] : [2] : [2] : [2] : [2] : [2] : [2] : [2] : [2];

      switch ($var61[0]) {
        case 0:
          return true;

        case 1:
          g = g;
          t = $var61[2];
          continue IsGeneralizableValue;

        case 2:
          const $var62 = t.tag === 11 ? [0, t.data[2], t.data[0]] : t.tag === 6 ? [1, t.data[0], t.data[1]] : t.tag === 7 ? [2, t.data[0], t.data[1]] : t.tag === 5 ? t.data[0].tag === 1 ? t.data[3].tail == null ? (vref = t.data[0].data[0], vref.IsTypeFunction) ? [3, t.data[0].data[0]] : [4] : [4] : [4] : [4];

          switch ($var62[0]) {
            case 0:
              if ((() => {
                const $var63 = $var62[2].tag === 2 ? [0] : $var62[2].tag === 0 ? [1, $var62[2].data] : $var62[2].tag === 10 ? [2, $var62[2].data[0], $var62[2].data[1]] : $var62[2].tag === 3 ? [3] : $var62[2].tag === 1 ? [4, $var62[2].data] : $var62[2].tag === 22 ? $var62[2].data[0].tail == null ? [5] : [6] : [6];

                switch ($var63[0]) {
                  case 0:
                    return true;

                  case 1:
                    return !isUnionCaseRefAllocObservable($var63[1]);

                  case 2:
                    if ($var63[1].tag === 0) {
                      return false;
                    } else {
                      return !isRecdOrUnionOrStructTyconRefAllocObservable(g, $var63[2]);
                    }

                  case 3:
                    return $var62[1].tail == null;

                  case 4:
                    return !isExnAllocObservable($var63[1]);

                  case 5:
                    return true;

                  case 6:
                    return false;
                }
              })()) {
                return forAll(function (t_1) {
                  return IsGeneralizableValue(g, t_1);
                }, $var62[1]);
              } else {
                return false;
              }

            case 1:
              if (forAll(function (b) {
                return !b.Var.IsMutable;
              }, $var62[1]) ? forAll(function (b_1) {
                return IsGeneralizableValue(g, b_1.Expr);
              }, $var62[1]) : false) {
                g = g;
                t = $var62[2];
                continue IsGeneralizableValue;
              } else {
                return false;
              }

            case 2:
              if (!$var62[1].Var.IsMutable ? IsGeneralizableValue(g, $var62[1].Expr) : false) {
                g = g;
                t = $var62[2];
                continue IsGeneralizableValue;
              } else {
                return false;
              }

            case 3:
              return HasFSharpAttribute(g, g.attrib_GeneralizableValueAttribute, $var62[1].Attribs);

            case 4:
              const $var64 = t.tag === 5 ? t.data[3].tail == null ? [0, t.data[0]] : [4] : t.tag === 13 ? [1, t.data[1]] : t.tag === 8 ? [2, t.data[1]] : t.tag === 14 ? [3, t.data] : [4];

              switch ($var64[0]) {
                case 0:
                  g = g;
                  t = $var64[1];
                  continue IsGeneralizableValue;

                case 1:
                  g = g;
                  t = $var64[1];
                  continue IsGeneralizableValue;

                case 2:
                  if (isInterfaceTy(g, $var64[1])) {
                    return true;
                  } else {
                    return isDelegateTy(g, $var64[1]);
                  }

                case 3:
                  g = g;
                  t = $var64[1].contents;
                  continue IsGeneralizableValue;

                case 4:
                  return false;
              }

          }

      }
    }
  };

  const CanGeneralizeConstrainedTyparsForDecl = __exports.CanGeneralizeConstrainedTyparsForDecl = function (declKind) {
    if (DeclKind.CanGeneralizeConstrainedTypars(declKind)) {
      return new GeneralizeConstrainedTyparOptions(0);
    } else {
      return new GeneralizeConstrainedTyparOptions(1);
    }
  };

  const TrimUngeneralizableTypars = __exports.TrimUngeneralizableTypars = function (genConstrainedTyparFlag, inlineFlag, generalizedTypars, freeInEnv) {
    TrimUngeneralizableTypars: while (true) {
      const patternInput = inlineFlag.Equals(new ValInline(0)) ? [generalizedTypars, new List()] : partition(function (tp) {
        return tp.StaticReq.Equals(new TyparStaticReq(0));
      }, generalizedTypars);
      const patternInput_1 = partition(function (x) {
        return !ZsetModule.contains(x, freeInEnv);
      }, patternInput[0]);
      const patternInput_2 = partition(function (tp_1) {
        return genConstrainedTyparFlag.Equals(new GeneralizeConstrainedTyparOptions(0)) ? true : tp_1.Constraints.tail == null;
      }, patternInput_1[0]);

      if ((patternInput[1].tail == null ? patternInput_1[1].tail == null : false) ? patternInput_2[1].tail == null : false) {
        return [patternInput_2[0], freeInEnv];
      } else {
        const freeInEnv_1 = unionFreeTypars(accFreeInTypars(CollectAllNoCaching, patternInput[1], accFreeInTypars(CollectAllNoCaching, patternInput_1[1], accFreeInTypars(CollectAllNoCaching, patternInput_2[1], emptyFreeTyvars))).FreeTypars, freeInEnv);
        genConstrainedTyparFlag = genConstrainedTyparFlag;
        inlineFlag = inlineFlag;
        generalizedTypars = patternInput_2[0];
        freeInEnv = freeInEnv_1;
        continue TrimUngeneralizableTypars;
      }
    }
  };

  const CondenseTypars = __exports.CondenseTypars = function (cenv_1, denv, generalizedTypars, tauTy, m) {
    const patternInput = stripFunTy(cenv_1.g, tauTy);
    const allUntupledArgTys = collect(function (arg10_) {
      return tryDestRefTupleTy(cenv_1.g, arg10_);
    }, patternInput[0]);
    const returnTypeFreeTypars = freeInTypeLeftToRight(cenv_1.g, false, patternInput[1]);
    const allUntupledArgTysWithFreeVars = map_1(function (ty) {
      return [ty, freeInTypeLeftToRight(cenv_1.g, false, ty)];
    }, allUntupledArgTys);

    const relevantUniqueSubtypeConstraint = function (tp) {
      const matchValue = partition(function (_arg1) {
        return _arg1.tag === 0 ? true : false;
      }, tp.Constraints);
      const $var65 = matchValue[0].tail != null ? matchValue[0].head.tag === 0 ? matchValue[0].tail.tail == null ? [0, matchValue[0].head.data[0], matchValue[1]] : [1] : [1] : [1];

      switch ($var65[0]) {
        case 0:
          if (exists_1(function (_arg2) {
            return _arg2.tag === 2 ? !TypeSatisfiesNullConstraint(cenv_1.g, m, $var65[1]) : true;
          }, $var65[2])) {
            return null;
          } else {
            return $var65[1];
          }

        case 1:
          return null;
      }
    };

    const lhsConstraintTypars = collect(function (ty_1) {
      const matchValue_1 = tryDestTyparTy(cenv_1.g, ty_1);

      if (matchValue_1 == null) {
        return new List();
      } else {
        const matchValue_2 = relevantUniqueSubtypeConstraint(getValue(matchValue_1));

        if (matchValue_2 == null) {
          return new List();
        } else {
          return freeInTypeLeftToRight(cenv_1.g, false, getValue(matchValue_2));
        }
      }
    }, allUntupledArgTys);

    const IsCondensationTypar = function (tp_1) {
      if (((tp_1.DynamicReq.Equals(new TyparDynamicReq(0)) ? relevantUniqueSubtypeConstraint(tp_1) != null : false) ? !exists_1(CurriedLambda(function (lv1, lv2) {
        return typarEq(lv1, lv2);
      })(tp_1), returnTypeFreeTypars) : false) ? !exists_1(CurriedLambda(function (lv1_1, lv2_1) {
        return typarEq(lv1_1, lv2_1);
      })(tp_1), lhsConstraintTypars) : false) {
        const matchValue_4 = partition(function (tupledArg) {
          const matchValue_3 = tryDestTyparTy(cenv_1.g, tupledArg[0]);

          if (matchValue_3 != null) {
            return typarEq(getValue(matchValue_3), tp_1);
          } else {
            return false;
          }
        }, allUntupledArgTysWithFreeVars);
        const $var66 = matchValue_4[0].tail != null ? matchValue_4[0].tail.tail == null ? [0, matchValue_4[1]] : [1] : [1];

        switch ($var66[0]) {
          case 0:
            return !exists_1(function (tupledArg_1) {
              return exists_1(CurriedLambda(function (lv1_2, lv2_2) {
                return typarEq(lv1_2, lv2_2);
              })(tp_1), tupledArg_1[1]);
            }, $var66[1]);

          case 1:
            return false;
        }
      } else {
        return false;
      }
    };

    const patternInput_1 = function (list) {
      return partition(IsCondensationTypar, list);
    }(generalizedTypars);

    iterate(function (tp_2) {
      ChooseTyparSolutionAndSolve(cenv_1.css, denv, tp_2);
    }, patternInput_1[0]);
    return patternInput_1[1];
  };

  const CanonicalizePartialInferenceProblem = __exports.CanonicalizePartialInferenceProblem = function (cenv_1, denv, m, tps) {
    const csenv = MakeConstraintSolverEnv(new ContextInfo(0), cenv_1.css, m, denv);
    RaiseOperationResult(TryD(function () {
      return CanonicalizeRelevantMemberConstraints(csenv, 0, new OptionalTrace(0), tps);
    }, function (res) {
      return ErrorD(new ErrorFromAddingConstraint(denv, res, m));
    }));
  };

  const ComputeAndGeneralizeGenericTypars = __exports.ComputeAndGeneralizeGenericTypars = function (cenv_1, denv, m, freeInEnv, canInferTypars, genConstrainedTyparFlag, inlineFlag, exprOpt, allDeclaredTypars, maxInferredTypars, tauTy, resultFirst) {
    const allDeclaredTypars_1 = NormalizeDeclaredTyparsForEquiRecursiveInference(cenv_1.g, allDeclaredTypars);
    const typarsToAttemptToGeneralize = (exprOpt != null ? IsGeneralizableValue(cenv_1.g, getValue(exprOpt)) : true) ? ListSet.unionFavourLeft(function (lv1, lv2) {
      return typarEq(lv1, lv2);
    }, allDeclaredTypars_1, maxInferredTypars) : allDeclaredTypars_1;
    const patternInput = TrimUngeneralizableTypars(genConstrainedTyparFlag, inlineFlag, typarsToAttemptToGeneralize, freeInEnv);
    iterate(function (tp) {
      if (ZsetModule.memberOf(patternInput[1], tp)) {
        const ty = mkTyparTy(tp);
        error_1(new _Error(SR.tcNotSufficientlyGenericBecauseOfScope(prettyStringOfTy(denv, ty)), m));
      }
    }, allDeclaredTypars_1);
    const generalizedTypars = CondenseTypars(cenv_1, denv, patternInput[0], tauTy, m);
    const generalizedTypars_1 = canInferTypars ? generalizedTypars : filter(function (tp_1) {
      return exists_1(CurriedLambda(function (lv1_1, lv2_1) {
        return typarEq(lv1_1, lv2_1);
      })(tp_1), allDeclaredTypars_1);
    }, generalizedTypars);
    const allConstraints = collect(function (tp_2) {
      return tp_2.Constraints;
    }, generalizedTypars_1);
    const generalizedTypars_2 = SimplifyMeasuresInTypeScheme(cenv_1.g, resultFirst, generalizedTypars_1, tauTy, allConstraints);
    iterate(function (tp_3) {
      SetTyparRigid(cenv_1.g, denv, m, tp_3);
    }, generalizedTypars_2);
    const csenv = MakeConstraintSolverEnv(new ContextInfo(0), cenv_1.css, m, denv);
    EliminateConstraintsForGeneralizedTypars(csenv, new OptionalTrace(0), generalizedTypars_2);
    return generalizedTypars_2;
  };

  const CheckDeclaredTyparsPermitted = __exports.CheckDeclaredTyparsPermitted = function (memFlagsOpt, declaredTypars, m) {
    if (memFlagsOpt != null) {
      const $var67 = getValue(memFlagsOpt).MemberKind.tag === 3 ? [0] : getValue(memFlagsOpt).MemberKind.tag === 4 ? [0] : getValue(memFlagsOpt).MemberKind.tag === 1 ? [1] : [2];

      switch ($var67[0]) {
        case 0:
          if (!(declaredTypars.tail == null)) {
            errorR(new _Error(SR.tcPropertyRequiresExplicitTypeParameters(), m));
          }

          break;

        case 1:
          if (!(declaredTypars.tail == null)) {
            errorR(new _Error(SR.tcConstructorCannotHaveTypeParameters(), m));
          }

          break;

        case 2:
          break;
      }
    }
  };

  const ComputeCanInferExtraGeneralizableTypars = __exports.ComputeCanInferExtraGeneralizableTypars = function (parentRef, canInferTypars, memFlagsOpt) {
    if (canInferTypars ? memFlagsOpt != null ? (() => {
      switch (getValue(memFlagsOpt).MemberKind.tag) {
        case 3:
        case 4:
          return false;

        case 0:
          return false;

        case 1:
          return false;

        default:
          return true;
      }
    })() : true : false) {
      if (parentRef.tag === 0) {
        return !parentRef.data.IsFSharpDelegateTycon;
      } else {
        return true;
      }
    } else {
      return false;
    }
  };

  return __exports;
}({});
export function ComputeInlineFlag(memFlagsOption, isInline, isMutable, m) {
  const inlineFlag = (isMutable ? true : memFlagsOption != null ? (getValue(memFlagsOption).MemberKind.Equals(new MemberKind_2(1)) ? true : getValue(memFlagsOption).IsDispatchSlot) ? true : getValue(memFlagsOption).IsOverrideOrExplicitImpl : false) ? new ValInline(3) : isInline ? new ValInline(0) : new ValInline(2);

  if (isInline ? !inlineFlag.Equals(new ValInline(0)) : false) {
    errorR(new _Error(SR.tcThisValueMayNotBeInlined(), m));
  }

  return inlineFlag;
}
export class NormalizedBindingRhs {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.NormalizedBindingRhs",
      interfaces: ["FSharpUnion"],
      cases: [["NormalizedBindingRhs", makeGeneric(List, {
        T: SynSimplePats
      }), Option(SynBindingReturnInfo), SynExpr]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.NormalizedBindingRhs", NormalizedBindingRhs);
export function PushOnePatternToRhs(cenv_1, isMember, p, _arg1) {
  const patternInput = PushPatternToExpr(cenv_1.synArgNameGenerator, isMember, p, _arg1.data[2]);
  return new NormalizedBindingRhs(0, [new List(patternInput[0], _arg1.data[0]), _arg1.data[1], patternInput[1]]);
}
export class NormalizedBindingPatternInfo {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.NormalizedBindingPatternInfo",
      interfaces: ["FSharpUnion"],
      cases: [["NormalizedBindingPat", SynPat, NormalizedBindingRhs, SynValData, SynValTyparDecls]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.NormalizedBindingPatternInfo", NormalizedBindingPatternInfo);
export class NormalizedBinding {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.NormalizedBinding",
      interfaces: ["FSharpUnion"],
      cases: [["NormalizedBinding", Option(SynAccess), SynBindingKind, "boolean", "boolean", makeGeneric(List, {
        T: SynAttribute
      }), XmlDoc, SynValTyparDecls, SynValData, SynPat, NormalizedBindingRhs, range, SequencePointInfoForBinding]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.NormalizedBinding", NormalizedBinding);
export class IsObjExprBinding {
  constructor(tag) {
    this.tag = tag | 0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.IsObjExprBinding",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["ObjExprBinding"], ["ValOrMemberBinding"]]
    };
  }

  Equals(other) {
    return this.tag === other.tag;
  }

  CompareTo(other) {
    return comparePrimitives(this.tag, other.tag);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.IsObjExprBinding", IsObjExprBinding);
export const BindingNormalization = function (__exports) {
  const PushMultiplePatternsToRhs = function (cenv_1, isMember, ps, _arg1) {
    const patternInput = PushCurriedPatternsToExpr(cenv_1.synArgNameGenerator, _arg1.data[2].Range, isMember, ps, _arg1.data[2]);
    return new NormalizedBindingRhs(0, [append(patternInput[0], _arg1.data[0]), _arg1.data[1], patternInput[1]]);
  };

  const MakeNormalizedStaticOrValBinding = function (cenv_1, isObjExprBinding, id, vis, typars, args, rhsExpr, valSynData) {
    return new NormalizedBindingPatternInfo(0, [mkSynPatVar(vis, id), PushMultiplePatternsToRhs(cenv_1, isObjExprBinding.Equals(new IsObjExprBinding(0)) ? true : valSynData.data[0] != null, args, rhsExpr), valSynData, typars]);
  };

  const MakeNormalizedInstanceMemberBinding = function (cenv_1, thisId, memberId, toolId, vis, m, typars, args, rhsExpr, valSynData) {
    return new NormalizedBindingPatternInfo(0, [new SynPat(18, [thisId, memberId, toolId, vis, m]), PushMultiplePatternsToRhs(cenv_1, true, args, rhsExpr), valSynData, typars]);
  };

  const NormalizeStaticMemberBinding = function (cenv_1, memberFlags, valSynData, id, vis, typars, args, m, rhsExpr) {
    if (memberFlags.IsInstance) {
      error_1(new _Error(SR.tcInstanceMemberRequiresTarget(), m));
    }

    const matchValue = [args, memberFlags.MemberKind];
    const $var68 = matchValue[1].tag === 5 ? [0] : matchValue[1].tag === 0 ? matchValue[0].tail != null ? matchValue[0].tail.tail == null ? [3] : [5] : [1] : matchValue[1].tag === 1 ? matchValue[0].tail != null ? matchValue[0].tail.tail == null ? [3] : [5] : [2] : matchValue[1].tag === 2 ? matchValue[0].tail == null ? [4] : [5] : [5];

    switch ($var68[0]) {
      case 0:
        return error_1(new _Error(SR.tcUnexpectedPropertyInSyntaxTree(), m));

      case 1:
        return error_1(new _Error(SR.tcStaticInitializerRequiresArgument(), m));

      case 2:
        return error_1(new _Error(SR.tcObjectConstructorRequiresArgument(), m));

      case 3:
        return MakeNormalizedStaticOrValBinding(cenv_1, new IsObjExprBinding(1), id, vis, typars, args, rhsExpr, valSynData);

      case 4:
        let memberFlags_1;
        const MemberKind = new MemberKind_2(3);
        memberFlags_1 = new MemberFlags(memberFlags.IsInstance, memberFlags.IsDispatchSlot, memberFlags.IsOverrideOrExplicitImpl, memberFlags.IsFinal, MemberKind);
        const valSynData_1 = new SynValData(0, [memberFlags_1, valSynData.data[1], valSynData.data[2]]);
        return new NormalizedBindingPatternInfo(0, [mkSynPatVar(vis, id), PushOnePatternToRhs(cenv_1, true, new SynPat(0, [new SynConst(0), m]), rhsExpr), valSynData_1, typars]);

      case 5:
        return MakeNormalizedStaticOrValBinding(cenv_1, new IsObjExprBinding(1), id, vis, typars, args, rhsExpr, valSynData);
    }
  };

  const NormalizeInstanceMemberBinding = function (cenv_1, memberFlags, valSynData, thisId, memberId, toolId, vis, typars, args, m, rhsExpr) {
    if (!memberFlags.IsInstance) {
      error_1(new _Error(SR.tcStaticMemberShouldNotHaveThis(), m));
    }

    const matchValue = [args, memberFlags.MemberKind];
    const $var69 = matchValue[1].tag === 0 ? [0] : matchValue[1].tag === 1 ? [1] : matchValue[1].tag === 5 ? [2] : matchValue[1].tag === 2 ? matchValue[0].tail == null ? [3] : [4] : [4];

    switch ($var69[0]) {
      case 0:
        return error_1(new _Error(SR.tcExplicitStaticInitializerSyntax(), m));

      case 1:
        return error_1(new _Error(SR.tcExplicitObjectConstructorSyntax(), m));

      case 2:
        return error_1(new _Error(SR.tcUnexpectedPropertySpec(), m));

      case 3:
        let memberFlags_1;
        const MemberKind = new MemberKind_2(3);
        memberFlags_1 = new MemberFlags(memberFlags.IsInstance, memberFlags.IsDispatchSlot, memberFlags.IsOverrideOrExplicitImpl, memberFlags.IsFinal, MemberKind);
        return new NormalizedBindingPatternInfo(0, [new SynPat(18, [thisId, memberId, toolId, vis, m]), PushOnePatternToRhs(cenv_1, true, new SynPat(0, [new SynConst(0), m]), rhsExpr), new SynValData(0, [memberFlags_1, valSynData.data[1], valSynData.data[2]]), typars]);

      case 4:
        return MakeNormalizedInstanceMemberBinding(cenv_1, thisId, memberId, toolId, vis, m, typars, args, rhsExpr, valSynData);
    }
  };

  const NormalizeBindingPattern = function (cenv_1, nameResolver, isObjExprBinding, env, valSynData, pat, rhsExpr) {
    const normPattern = function (pat_1) {
      normPattern: while (true) {
        const $var70 = pat_1.tag === 19 ? [0, pat_1.data[0]] : pat_1.tag === 7 ? pat_1.data[3].tag === 0 ? [1, pat_1.data[3].data, pat_1.data[0].data[0], pat_1.data[5], pat_1.data[1], pat_1.data[2], pat_1.data[4]] : [3] : pat_1.tag === 2 ? pat_1.data[0].tag === 1 ? pat_1.data[2] ? [3] : (valSynData.data[0] != null ? !getValue(valSynData.data[0]).MemberKind.Equals(new MemberKind_2(1)) ? !getValue(valSynData.data[0]).MemberKind.Equals(new MemberKind_2(0)) : false : false) ? [2, pat_1.data[1], pat_1.data[4], pat_1.data[3]] : [3] : [3] : [3];

        switch ($var70[0]) {
          case 0:
            pat_1 = $var70[1];
            continue normPattern;

          case 1:
            const typars = $var70[5] != null ? getValue($var70[5]) : inferredTyparDecls;

            if (valSynData.data[0] != null) {
              const $var71 = $var70[2].tail != null ? $var70[2].tail.tail == null ? [1, $var70[2].head] : $var70[2].tail.tail.tail == null ? [0, $var70[2].tail.head, $var70[2].head] : [2] : [2];

              switch ($var71[0]) {
                case 0:
                  return NormalizeInstanceMemberBinding(cenv_1, getValue(valSynData.data[0]), valSynData, $var71[2], $var71[1], $var70[4], $var70[6], typars, $var70[1], $var70[3], rhsExpr);

                case 1:
                  return NormalizeStaticMemberBinding(cenv_1, getValue(valSynData.data[0]), valSynData, $var71[1], $var70[6], typars, $var70[1], $var70[3], rhsExpr);

                case 2:
                  return new NormalizedBindingPatternInfo(0, [pat_1, rhsExpr, valSynData, typars]);
              }
            } else {
              const matchValue = ResolvePatternLongIdent(cenv_1.tcSink, nameResolver, new WarnOnUpperFlag(1), true, $var70[3], env.eAccessRights, env.eNameResEnv, TypeNameResolutionInfo.Default, $var70[2]);

              if (matchValue.tag === 6) {
                if (matchValue.data.idText === opNameCons) {
                  return new NormalizedBindingPatternInfo(0, [pat_1, rhsExpr, valSynData, typars]);
                } else {
                  if (isObjExprBinding.Equals(new IsObjExprBinding(0))) {
                    errorR(new Deprecated(SR.tcObjectExpressionFormDeprecated(), $var70[3]));
                  }

                  return MakeNormalizedStaticOrValBinding(cenv_1, isObjExprBinding, matchValue.data, $var70[6], typars, $var70[1], rhsExpr, valSynData);
                }
              } else {
                return error_1(new _Error(SR.tcInvalidDeclaration(), $var70[3]));
              }
            }

          case 2:
            return NormalizeStaticMemberBinding(cenv_1, getValue(valSynData.data[0]), valSynData, $var70[1], $var70[3], inferredTyparDecls, new List(), $var70[2], rhsExpr);

          case 3:
            if (pat_1.tag === 3) {
              const patternInput = normPattern(pat_1.data[0]);
              return new NormalizedBindingPatternInfo(0, [new SynPat(3, [patternInput.data[0], pat_1.data[1], pat_1.data[2]]), patternInput.data[1], patternInput.data[2], patternInput.data[3]]);
            } else if (pat_1.tag === 4) {
              return error_1(new _Error(SR.tcAttributesInvalidInPatterns(), pat_1.data[2]));
            } else {
              return new NormalizedBindingPatternInfo(0, [pat_1, rhsExpr, valSynData, inferredTyparDecls]);
            }

        }
      }
    };

    return normPattern(pat);
  };

  const NormalizeBinding = __exports.NormalizeBinding = function (isObjExprBinding, cenv_1, env, b) {
    const patternInput = NormalizeBindingPattern(cenv_1, cenv_1.nameResolver, isObjExprBinding, env, b.data[6], b.data[7], new NormalizedBindingRhs(0, [new List(), b.data[8], b.data[9]]));
    return new NormalizedBinding(0, [b.data[0], b.data[1], b.data[2], b.data[3], b.data[4], b.data[5].ToXmlDoc(), patternInput.data[3], patternInput.data[2], patternInput.data[0], patternInput.data[1], b.data[10], b.data[11]]);
  };

  return __exports;
}({});
export const EventDeclarationNormalization = function (__exports) {
  const ConvertSynInfo = __exports.ConvertSynInfo = function (m, _arg1) {
    let argInfos;
    const $var72 = _arg1.data[0].tail != null ? _arg1.data[0].head.tail == null ? _arg1.data[0].tail.tail == null ? [1] : [2] : _arg1.data[0].head.tail.tail == null ? _arg1.data[0].tail.tail != null ? _arg1.data[0].tail.head.tail == null ? _arg1.data[0].tail.tail.tail == null ? [0, _arg1.data[0].head.head] : [2] : [2] : [2] : [2] : [2];

    switch ($var72[0]) {
      case 0:
        argInfos = ofArray([ofArray([$var72[1]]), SynInfo.unnamedTopArg]);
        break;

      case 1:
        argInfos = ofArray([SynInfo.unnamedTopArg]);
        break;

      case 2:
        argInfos = error_1(new BadEventTransformation(m));
        break;
    }

    return new SynValInfo(0, [argInfos, _arg1.data[1]]);
  };

  const ConvertMemberFlags = __exports.ConvertMemberFlags = function (memberFlags) {
    const MemberKind = new MemberKind_2(2);
    return new MemberFlags(memberFlags.IsInstance, memberFlags.IsDispatchSlot, memberFlags.IsOverrideOrExplicitImpl, memberFlags.IsFinal, MemberKind);
  };

  const ConvertMemberFlagsOpt = function (m, memberFlagsOpt) {
    if (memberFlagsOpt != null) {
      return ConvertMemberFlags(getValue(memberFlagsOpt));
    } else {
      return error_1(new BadEventTransformation(m));
    }
  };

  const ConvertSynData = function (m, valSynData) {
    const memberFlagsOpt = ConvertMemberFlagsOpt(m, valSynData.data[0]);
    const valSynInfo = ConvertSynInfo(m, valSynData.data[1]);
    return new SynValData(0, [memberFlagsOpt, valSynInfo, valSynData.data[2]]);
  };

  const RenameBindingPattern = function ($var482, $var483) {
    RenameBindingPattern: while (true) {
      const f = $var482;
      const declPattern = $var483;
      const $var73 = declPattern.tag === 19 ? [0, declPattern.data[0]] : declPattern.tag === 3 ? [1, declPattern.data[0]] : declPattern.tag === 2 ? declPattern.data[0].tag === 1 ? [2, declPattern.data[1], declPattern.data[4], declPattern.data[0].data, declPattern.data[3], declPattern.data[2]] : [4] : declPattern.tag === 18 ? [3, declPattern.data[1], declPattern.data[4], declPattern.data[0], declPattern.data[2], declPattern.data[3]] : [4];

      switch ($var73[0]) {
        case 0:
          $var482 = f;
          $var483 = $var73[1];
          continue RenameBindingPattern;

        case 1:
          $var482 = f;
          $var483 = $var73[1];
          continue RenameBindingPattern;

        case 2:
          return new SynPat(2, [new SynPat(1, $var73[3]), ident(f($var73[1].idText), $var73[1].idRange), $var73[5], $var73[4], $var73[2]]);

        case 3:
          return new SynPat(18, [$var73[3], ident(f($var73[1].idText), $var73[1].idRange), $var73[4], $var73[5], $var73[2]]);

        case 4:
          return error_1(new _Error(SR.tcOnlySimplePatternsInLetRec(), declPattern.Range));
      }
    }
  };

  const GenerateExtraBindings = __exports.GenerateExtraBindings = function (cenv_1, bindingAttribs, binding) {
    if (CompileAsEvent(cenv_1.g, bindingAttribs)) {
      const MakeOne = function (tupledArg) {
        const declPattern = RenameBindingPattern(function (s) {
          return tupledArg[0] + s;
        }, binding.data[8]);
        let patternInput;
        const m = binding.data[9].data[2].Range;
        const valSynData = ConvertSynData(m, binding.data[7]);
        const $var74 = binding.data[9].data[2].tag === 15 ? binding.data[9].data[2].data[2].tag === 0 ? binding.data[9].data[2].data[2].data[0].tail == null ? [0, binding.data[9].data[2].data[4], binding.data[9].data[2].data[3]] : [1] : [1] : [1];

        switch ($var74[0]) {
          case 0:
            const rhsExpr = mkSynApp1(new SynExpr(31, [new SynExpr(0, [$var74[2], range0, null, $var74[1]]), range0, new LongIdentWithDots(0, [ofArray([ident(tupledArg[1], $var74[1])]), new List()]), $var74[1]]), new SynExpr(28, ident("handler", $var74[1])), $var74[1]);
            const bindingRhs = new NormalizedBindingRhs(0, [new List(), null, rhsExpr]);
            const bindingRhs_1 = PushOnePatternToRhs(cenv_1, true, mkSynPatVar(null, ident("handler", binding.data[10])), bindingRhs);
            patternInput = [bindingRhs_1, valSynData];
            break;

          case 1:
            patternInput = error_1(new BadEventTransformation(m));
            break;
        }

        return new NormalizedBinding(0, [binding.data[0], binding.data[1], binding.data[2], binding.data[3], new List(), binding.data[5], noInferredTypars, patternInput[1], declPattern, patternInput[0], binding.data[10], binding.data[11]]);
      };

      return ofArray([MakeOne(["add_", "AddHandler"]), MakeOne(["remove_", "RemoveHandler"])]);
    } else {
      return new List();
    }
  };

  return __exports;
}({});
export function FreshenObjectArgType(cenv_1, m, rigid, tcref, isExtrinsic, declaredTyconTypars) {
  const patternInput = FreshenTyconRef(m, rigid, tcref, declaredTyconTypars);
  const thisTy = (!isExtrinsic ? tcref.IsStructOrEnumTycon : false) ? mkByrefTy(cenv_1.g, patternInput[3]) : patternInput[3];
  return [patternInput[0], patternInput[1], patternInput[2], patternInput[3], thisTy];
}
export function TcValEarlyGeneralizationConsistencyCheck(cenv_1, env, v, vrec, tinst, vty, tau, m) {
  const $var75 = vrec.tag === 0 ? (vrec.data ? !(tinst.tail == null) : false) ? [0, vrec.data] : [1] : [1];

  switch ($var75[0]) {
    case 0:
      cenv_1.postInferenceChecks.push(function () {
        const patternInput = tryDestForallTy(cenv_1.g, vty);

        if (!(patternInput[0].tail == null)) {
          const tpsorig = NormalizeDeclaredTyparsForEquiRecursiveInference(cenv_1.g, patternInput[0]);
          const tau3 = instType(mkTyparInst(tpsorig, tinst), patternInput[1]);

          if (!AddCxTypeEqualsTypeUndoIfFailed(env.DisplayEnv, cenv_1.css, m, tau, tau3)) {
            const txt = bufs(function (buf) {
              outputQualifiedValSpec(env.DisplayEnv, buf, v);
            });
            error_1(new _Error(SR.tcInferredGenericTypeGivesRiseToInconsistency(v.DisplayName, txt), m));
          }
        }
      });
      break;

    case 1:
      break;
  }
}
export function TcVal(checkAttributes, cenv_1, env, tpenv, vref, optInst, optAfterResolution, m) {
  let res;
  const v = vref.Deref;
  const vrec = v.RecursiveValInfo;
  v.SetHasBeenReferenced();
  CheckValAccessible(m, env.eAccessRights, vref);

  if (checkAttributes) {
    CommitOperationResult(CheckValAttributes(cenv_1.g, vref, m));
  }

  const vty = vref.Type;

  if (isByrefTy(cenv_1.g, vty)) {
    res = [new List(), mkAddrGet(m, vref), true, destByrefTy(cenv_1.g, vty), new List(), tpenv];
  } else {
    const matchValue = v.LiteralValue;

    if (matchValue == null) {
      if (v.BaseOrThisInfo.Equals(new ValBaseOrThisInfo(0)) ? isRefCellTy(cenv_1.g, vty) : false) {
        const exprForVal = exprForValRef(m, vref);
        const ty = destRefCellTy(cenv_1.g, vty);
        res = [new List(), mkCallCheckThis(cenv_1.g, m, ty, mkRefCellGet(cenv_1.g, m, ty, exprForVal)), true, ty, new List(), tpenv];
      } else {
        let patternInput_6;

        if (optInst != null) {
          const vrefFlags = getValue(optInst)[0];
          const checkTys = getValue(optInst)[1];

          const checkInst = function (tinst) {
            if (((!v.IsMember ? !v.PermitsExplicitTypeInstantiation : false) ? !(tinst.tail == null) : false) ? !(v.Typars.tail == null) : false) {
              warning(new _Error(SR.tcDoesNotAllowExplicitTypeArguments(v.DisplayName), m));
            }
          };

          const $var76 = vrec.tag === 1 ? [1] : vrec.data ? [1] : [0];

          switch ($var76[0]) {
            case 0:
              const patternInput = vref.TypeScheme;
              const patternInput_1 = checkTys(tpenv, map_1(function (tp) {
                return tp.Kind;
              }, patternInput[0]));
              checkInst(patternInput_1[0]);

              if (patternInput[0].length !== patternInput_1[0].length) {
                error_1(new _Error(SR.tcTypeParameterArityMismatch(patternInput[0].length, patternInput_1[0].length), m));
              }

              const tau2 = instType(mkTyparInst(patternInput[0], patternInput_1[0]), patternInput[1]);
              iterate2(function (tp_1, ty_1) {
                try {
                  UnifyTypes(cenv_1, env, m, mkTyparTy(tp_1), ty_1);
                } catch (matchValue_1) {
                  error_1(new Recursion(env.DisplayEnv, v.Id, tau2, patternInput[1], m));
                }
              }, patternInput[0], patternInput_1[0]);
              patternInput_6 = [patternInput[0], vrefFlags, patternInput_1[0], tau2, patternInput_1[1]];
              break;

            case 1:
              const patternInput_2 = FreshenPossibleForallTy(cenv_1.g, m, new TyparRigidity(3), vty);
              const patternInput_3 = checkTys(tpenv, map_1(function (tp_2) {
                return tp_2.Kind;
              }, patternInput_2[1]));
              checkInst(patternInput_3[0]);

              if (patternInput_2[2].length !== patternInput_3[0].length) {
                error_1(new _Error(SR.tcTypeParameterArityMismatch(patternInput_2[1].length, patternInput_3[0].length), m));
              }

              iterate2(function (expectedTy, actualTy) {
                UnifyTypes(cenv_1, env, m, expectedTy, actualTy);
              }, patternInput_2[2], patternInput_3[0]);
              TcValEarlyGeneralizationConsistencyCheck(cenv_1, env, v, vrec, patternInput_3[0], vty, patternInput_2[3], m);
              patternInput_6 = [patternInput_2[0], vrefFlags, patternInput_3[0], patternInput_2[3], patternInput_3[1]];
              break;
          }
        } else {
          if (HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_RequiresExplicitTypeArgumentsAttribute, v.Attribs)) {
            errorR(new _Error(SR.tcFunctionRequiresExplicitTypeArguments(v.DisplayName), m));
          }

          const $var77 = vrec.tag === 1 ? [1] : vrec.data ? [1] : [0];

          switch ($var77[0]) {
            case 0:
              const patternInput_4 = vref.TypeScheme;

              const tinst_1 = function (list) {
                return map_1(function (tp_3) {
                  return mkTyparTy(tp_3);
                }, list);
              }(patternInput_4[0]);

              patternInput_6 = [patternInput_4[0], new ValUseFlag(1), tinst_1, patternInput_4[1], tpenv];
              break;

            case 1:
              const patternInput_5 = FreshenPossibleForallTy(cenv_1.g, m, new TyparRigidity(3), vty);
              patternInput_6 = [patternInput_5[0], new ValUseFlag(1), patternInput_5[2], patternInput_5[3], tpenv];
              break;
          }
        }

        const exprForVal_1 = new Expr(1, [vref, patternInput_6[1], m]);
        const exprForVal_2 = mkTyAppExpr(m, exprForVal_1, vty, patternInput_6[2]);
        const isSpecial = ((() => {
          const $var78 = patternInput_6[1].tag === 1 ? [0] : patternInput_6[1].tag === 0 ? [0] : [1];

          switch ($var78[0]) {
            case 0:
              return false;

            case 1:
              return true;
          }
        })() ? true : valRefEq(cenv_1.g, vref, cenv_1.g.splice_expr_vref)) ? true : valRefEq(cenv_1.g, vref, cenv_1.g.splice_raw_expr_vref);
        const exprForVal_3 = RecordUseOfRecValue(cenv_1, vrec, vref, exprForVal_2, m);
        res = [patternInput_6[0], exprForVal_3, isSpecial, patternInput_6[3], patternInput_6[2], patternInput_6[4]];
      }
    } else {
      const patternInput_7 = FreshenPossibleForallTy(cenv_1.g, m, new TyparRigidity(3), vty);
      res = [patternInput_7[0], new Expr(0, [getValue(matchValue), m, patternInput_7[3]]), true, patternInput_7[3], patternInput_7[2], tpenv];
    }
  }

  const $var79 = optAfterResolution == null ? [1] : getValue(optAfterResolution).tag === 0 ? [1] : [0, getValue(optAfterResolution).data[1]];

  switch ($var79[0]) {
    case 0:
      $var79[1](mkTyparInst(res[0], res[4]));
      break;

    case 1:
      break;
  }

  return res;
}
export function LightweightTcValForUsingInBuildMethodCall(g, vref, vrefFlags, vrefTypeInst, m) {
  const v = vref.Deref;
  const vty = vref.Type;

  if (isByrefTy(g, vty)) {
    return [mkAddrGet(m, vref), destByrefTy(g, vty)];
  } else {
    const matchValue = v.LiteralValue;

    if (matchValue == null) {
      let tau;
      const patternInput = FreshenPossibleForallTy(g, m, new TyparRigidity(3), vty);

      if (patternInput[2].length !== vrefTypeInst.length) {
        error_1(new _Error(SR.tcTypeParameterArityMismatch(patternInput[1].length, vrefTypeInst.length), m));
      }

      tau = instType(mkTyparInst(patternInput[1], vrefTypeInst), patternInput[3]);
      const exprForVal = new Expr(1, [vref, vrefFlags, m]);
      const exprForVal_1 = mkTyAppExpr(m, exprForVal, vty, vrefTypeInst);
      return [exprForVal_1, tau];
    } else {
      const patternInput_1 = FreshenPossibleForallTy(g, m, new TyparRigidity(3), vty);
      return [new Expr(0, [getValue(matchValue), m, patternInput_1[3]]), patternInput_1[3]];
    }
  }
}
export class ApplicableExpr {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.ApplicableExpr",
      interfaces: ["FSharpUnion"],
      cases: [["ApplicableExpr", cenv, Expr, "boolean"]]
    };
  }

  get Range() {
    return Expr_get_Range.bind(this.data[1])();
  }

  get Type() {
    return tyOfExpr(this.data[0].g, this.data[1]);
  }

  SupplyArgument(e2, m) {
    var $var81;
    let combinedExpr;
    const $var80 = this.data[1].tag === 5 ? ((!this.data[2] ? true : ($var81 = this.data[1].data[3], $var81.tail == null)) ? !isForallTy(this.data[0].g, this.data[1].data[1]) ? true : isFunTy(this.data[0].g, applyTys(this.data[0].g, this.data[1].data[1], this.data[1].data[2], this.data[1].data[3])) : false) ? [0, this.data[1].data[3], this.data[1].data[0], this.data[1].data[4], this.data[1].data[1], this.data[1].data[2]] : [1] : [1];

    switch ($var80[0]) {
      case 0:
        combinedExpr = new Expr(5, [$var80[2], $var80[4], $var80[5], append($var80[1], ofArray([e2])), unionRanges($var80[3], m)]);
        break;

      case 1:
        combinedExpr = new Expr(5, [this.data[1], tyOfExpr(this.data[0].g, this.data[1]), new List(), ofArray([e2]), m]);
        break;
    }

    return new ApplicableExpr(0, [this.data[0], combinedExpr, false]);
  }

  get Expr() {
    return this.data[1];
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.ApplicableExpr", ApplicableExpr);
export function MakeApplicableExprNoFlex(cenv_1, expr) {
  return new ApplicableExpr(0, [cenv_1, expr, true]);
}
export function MakeApplicableExprWithFlex(cenv_1, env, expr) {
  var predicate;
  const exprTy = tyOfExpr(cenv_1.g, expr);
  const m = Expr_get_Range.bind(expr)();

  const isNonFlexibleType = function (ty) {
    return isSealedTy(cenv_1.g, ty);
  };

  const patternInput = stripFunTy(cenv_1.g, exprTy);
  const curriedActualTypes = map_1(function (arg10_) {
    return tryDestRefTupleTy(cenv_1.g, arg10_);
  }, patternInput[0]);

  if ((curriedActualTypes.tail == null ? true : exists_1((predicate = function (arg10__1) {
    return isByrefTy(cenv_1.g, arg10__1);
  }, function (list) {
    return exists_1(predicate, list);
  }), curriedActualTypes)) ? true : forAll(function (list_1) {
    return forAll(isNonFlexibleType, list_1);
  }, curriedActualTypes)) {
    return new ApplicableExpr(0, [cenv_1, expr, true]);
  } else {
    const curriedFlexibleTypes = List_1.mapSquared(function (actualType) {
      if (isNonFlexibleType(actualType)) {
        return actualType;
      } else {
        const flexibleType = NewInferenceType();
        AddCxTypeMustSubsumeType(new ContextInfo(0), env.DisplayEnv, cenv_1.css, m, new OptionalTrace(0), actualType, flexibleType);
        return flexibleType;
      }
    }, curriedActualTypes);
    const expr_1 = mkCoerceExpr(expr, mkIteratedFunTy(map_1(function (arg10__2) {
      return mkRefTupledTy(cenv_1.g, arg10__2);
    }, curriedFlexibleTypes), patternInput[1]), m, exprTy);
    return new ApplicableExpr(0, [cenv_1, expr_1, true]);
  }
}
export function TcRuntimeTypeTest(isCast, isOperator, cenv_1, denv, m, tgty, srcTy) {
  if (TypeDefinitelySubsumesTypeNoCoercion(0, cenv_1.g, cenv_1.amap, m, tgty, srcTy)) {
    warning(new TypeTestUnnecessary(m));
  }

  if (isTyparTy(cenv_1.g, srcTy)) {
    error_1(new IndeterminateRuntimeCoercion(denv, srcTy, tgty, m));
  }

  if (isSealedTy(cenv_1.g, srcTy)) {
    error_1(new RuntimeCoercionSourceSealed(denv, srcTy, m));
  }

  if ((isSealedTy(cenv_1.g, tgty) ? true : isTyparTy(cenv_1.g, tgty)) ? true : !isInterfaceTy(cenv_1.g, srcTy)) {
    if (isCast) {
      AddCxTypeMustSubsumeType(new ContextInfo(9, isOperator), denv, cenv_1.css, m, new OptionalTrace(0), srcTy, tgty);
    } else {
      AddCxTypeMustSubsumeType(new ContextInfo(0), denv, cenv_1.css, m, new OptionalTrace(0), srcTy, tgty);
    }
  }

  if (isErasedType(cenv_1.g, tgty)) {
    if (isCast) {
      warning(new _Error(SR.tcTypeCastErased(minimalStringOfType(denv, tgty), minimalStringOfType(denv, stripTyEqnsWrtErasure(new Erasure(0), cenv_1.g, tgty))), m));
    } else {
      error_1(new _Error(SR.tcTypeTestErased(minimalStringOfType(denv, tgty), minimalStringOfType(denv, stripTyEqnsWrtErasure(new Erasure(0), cenv_1.g, tgty))), m));
    }
  } else {
    iterate(function (ety) {
      if (isMeasureTy(cenv_1.g, ety)) {
        warning(new _Error(SR.tcTypeTestLosesMeasures(minimalStringOfType(denv, ety)), m));
      } else {
        warning(new _Error(SR.tcTypeTestLossy(minimalStringOfType(denv, ety), minimalStringOfType(denv, stripTyEqnsWrtErasure(new Erasure(0), cenv_1.g, ety))), m));
      }
    }, getErasedTypes(cenv_1.g, tgty));
  }
}
export function TcStaticUpcast(cenv_1, denv, m, tgty, srcTy) {
  if (isTyparTy(cenv_1.g, tgty)) {
    error_1(new IndeterminateStaticCoercion(denv, srcTy, tgty, m));
  }

  if (isSealedTy(cenv_1.g, tgty)) {
    warning(new CoercionTargetSealed(denv, tgty, m));
  }

  if (typeEquiv(cenv_1.g, srcTy, tgty)) {
    warning(new UpcastUnnecessary(m));
  }

  AddCxTypeMustSubsumeType(new ContextInfo(0), denv, cenv_1.css, m, new OptionalTrace(0), tgty, srcTy);
}
export function BuildPossiblyConditionalMethodCall(cenv_1, env, isMutable, m, isProp, minfo, valUseFlags, minst, objArgs, args) {
  const conditionalCallDefineOpt = TryFindMethInfoStringAttribute(cenv_1.g, m, cenv_1.g.attrib_ConditionalAttribute, minfo);
  const $var82 = conditionalCallDefineOpt != null ? !exists_1($var83 => equals(getValue(conditionalCallDefineOpt), $var83), cenv_1.conditionalDefines) ? [0, getValue(conditionalCallDefineOpt)] : [1] : [1];

  switch ($var82[0]) {
    case 0:
      UnifyTypes(cenv_1, env, m, cenv_1.g.unit_ty, minfo.GetFSharpReturnTy(cenv_1.amap, m, minst));
      return [mkUnit(cenv_1.g, m), cenv_1.g.unit_ty];

    case 1:
      const tcVal = function (valref, valUse, ttypes, m_1) {
        const patternInput = TcVal(true, cenv_1, env, emptyUnscopedTyparEnv, valref, [valUse, function (x, _arg1) {
          return [ttypes, x];
        }], null, m_1);
        return [patternInput[1], patternInput[3]];
      };

      return BuildMethodCall(tcVal, cenv_1.g, cenv_1.amap, isMutable, m, isProp, minfo, valUseFlags, minst, objArgs, args);
  }
}
export function TryFindIntrinsicOrExtensionMethInfo(cenv_1, env, m, ad, nm, ty) {
  return AllMethInfosOfTypeInScope(cenv_1.infoReader, env.NameEnv, nm, ad, new FindMemberFlag(0), m, ty);
}
export function BuildDisposableCleanup(cenv_1, env, m, v) {
  v.SetHasBeenReferenced();
  let disposeMethod;
  const matchValue = TryFindIntrinsicOrExtensionMethInfo(cenv_1, env, m, env.eAccessRights, "Dispose", cenv_1.g.system_IDisposable_typ);
  const $var84 = matchValue.tail != null ? matchValue.tail.tail == null ? [0, matchValue.head] : [1] : [1];

  switch ($var84[0]) {
    case 0:
      disposeMethod = $var84[1];
      break;

    case 1:
      disposeMethod = error_1(new InternalError(SR.tcCouldNotFindIDisposable(), m));
      break;
  }

  if (isStructTy(cenv_1.g, v.Type)) {
    if (TypeFeasiblySubsumesType(0, cenv_1.g, cenv_1.amap, m, cenv_1.g.system_IDisposable_typ, new CanCoerce(0), v.Type)) {
      const patternInput = BuildPossiblyConditionalMethodCall(cenv_1, env, new Mutates(2), m, false, disposeMethod, new ValUseFlag(1), new List(), ofArray([exprForVal_4(v.Range, v)]), new List());
      return patternInput[0];
    } else {
      return mkUnit(cenv_1.g, m);
    }
  } else {
    const patternInput_1 = mkCompGenLocal(m, "objectToDispose", cenv_1.g.system_IDisposable_typ);
    const patternInput_2 = BuildPossiblyConditionalMethodCall(cenv_1, env, new Mutates(1), m, false, disposeMethod, new ValUseFlag(1), new List(), ofArray([patternInput_1[1]]), new List());
    const inpe = mkCoerceExpr(exprForVal_4(v.Range, v), cenv_1.g.obj_ty, m, v.Type);
    return mkIsInstConditional(cenv_1.g, m, cenv_1.g.system_IDisposable_typ, inpe, patternInput_1[0], patternInput_2[0], mkUnit(cenv_1.g, m));
  }
}
export function BuildOffsetToStringData(cenv_1, env, m) {
  let offsetToStringDataMethod;
  const matchValue = TryFindIntrinsicOrExtensionMethInfo(cenv_1, env, m, env.eAccessRights, "get_OffsetToStringData", cenv_1.g.system_RuntimeHelpers_typ);
  const $var85 = matchValue.tail != null ? matchValue.tail.tail == null ? [0, matchValue.head] : [1] : [1];

  switch ($var85[0]) {
    case 0:
      offsetToStringDataMethod = $var85[1];
      break;

    case 1:
      offsetToStringDataMethod = error_1(new _Error(SR.tcCouldNotFindOffsetToStringData(), m));
      break;
  }

  const patternInput = BuildPossiblyConditionalMethodCall(cenv_1, env, new Mutates(2), m, false, offsetToStringDataMethod, new ValUseFlag(1), new List(), new List(), new List());
  return patternInput[0];
}
export function BuildILFieldGet(g, amap, m, objExpr, finfo) {
  const fref = finfo.ILFieldRef;
  const isValueType = finfo.IsValueType;
  const valu = isValueType ? new ILBoxity(1) : new ILBoxity(0);
  const tinst = finfo.TypeInst;
  const fieldType = finfo.FieldType(amap, m);
  const patternInput = mkExprAddrOfExpr(g, isValueType, false, new Mutates(2), objExpr, null, m);
  const fspec = mkILFieldSpec(fref, mkILNamedTy(valu, fref.DeclaringTypeRef, new List()));
  return patternInput[0](mkAsmExpr(append(ofArray([mkNormalLdfld(fspec)]), finfo.IsInitOnly ? ofArray([new ILInstr(33)]) : new List()), tinst, ofArray([patternInput[1]]), ofArray([fieldType]), m));
}
export function BuildILFieldSet(g, m, objExpr, finfo, argExpr) {
  const fref = finfo.ILFieldRef;
  const isValueType = finfo.IsValueType;
  const valu = isValueType ? new ILBoxity(1) : new ILBoxity(0);
  const tinst = finfo.TypeInst;
  const fspec = mkILFieldSpec(fref, mkILNamedTy(valu, fref.DeclaringTypeRef, new List()));

  if (finfo.IsInitOnly) {
    error_1(new _Error(SR.tcFieldIsReadonly(), m));
  }

  const patternInput = mkExprAddrOfExpr(g, isValueType, false, new Mutates(0), objExpr, null, m);
  return patternInput[0](mkAsmExpr(ofArray([mkNormalStfld(fspec)]), tinst, ofArray([patternInput[1], argExpr]), new List(), m));
}
export function BuildILStaticFieldSet(m, finfo, argExpr) {
  const fref = finfo.ILFieldRef;
  const isValueType = finfo.IsValueType;
  const valu = isValueType ? new ILBoxity(1) : new ILBoxity(0);
  const tinst = finfo.TypeInst;
  const fspec = mkILFieldSpec(fref, mkILNamedTy(valu, fref.DeclaringTypeRef, new List()));

  if (finfo.IsInitOnly) {
    error_1(new _Error(SR.tcFieldIsReadonly(), m));
  }

  return mkAsmExpr(ofArray([mkNormalStsfld(fspec)]), tinst, ofArray([argExpr]), new List(), m);
}
export function BuildRecdFieldSet(g, m, objExpr, rfinfo, argExpr) {
  const tgty = rfinfo.DeclaringType;
  const valu = isStructTy(g, tgty);
  const objExpr_1 = valu ? objExpr : mkCoerceExpr(objExpr, tgty, m, tyOfExpr(g, objExpr));
  const patternInput = mkExprAddrOfExpr(g, valu, false, new Mutates(0), objExpr_1, null, m);
  return patternInput[0](mkRecdFieldSetViaExprAddr(patternInput[1], rfinfo.RecdFieldRef, rfinfo.TypeInst, argExpr, m));
}

function _BinOpExpr___(e) {
  let $var86;

  if (e.tag === 20) {
    if (e.data[2].tag === 20) {
      const activePatternResult40766 = _SingleIdent___(e.data[2].data[2]);

      if (activePatternResult40766 != null) {
        $var86 = [0, e.data[2].data[3], e.data[3], getValue(activePatternResult40766)];
      } else {
        $var86 = [1];
      }
    } else {
      $var86 = [1];
    }
  } else {
    $var86 = [1];
  }

  switch ($var86[0]) {
    case 0:
      return [$var86[3], $var86[1], $var86[2]];

    case 1:
      return null;
  }
}

export { _BinOpExpr___ as $7C$BinOpExpr$7C$_$7C$ };

function _SimpleEqualsExpr___(e) {
  var opId;
  var b;
  var a;
  let $var87;

  const activePatternResult40768 = _BinOpExpr___(e);

  if (activePatternResult40768 != null) {
    if (opId = getValue(activePatternResult40768)[0], b = getValue(activePatternResult40768)[2], a = getValue(activePatternResult40768)[1], opId.idText === opNameEquals) {
      $var87 = [0, getValue(activePatternResult40768)[1], getValue(activePatternResult40768)[2], getValue(activePatternResult40768)[0]];
    } else {
      $var87 = [1];
    }
  } else {
    $var87 = [1];
  }

  switch ($var87[0]) {
    case 0:
      return [$var87[1], $var87[2]];

    case 1:
      return null;
  }
}

export { _SimpleEqualsExpr___ as $7C$SimpleEqualsExpr$7C$_$7C$ };

function _JoinRelation___(cenv_1, env, e) {
  var opId_3;
  var b_4;
  var a_4;
  var opId_2;
  var b_3;
  var a_3;
  var opId_1;
  var b_2;
  var a_2;
  var opId;
  var b_1;
  var a_1;
  const m = e.Range;

  const isOpName = function (opName, vref, s) {
    if (s === opName) {
      const matchValue = ResolveExprLongIdent(cenv_1.tcSink, cenv_1.nameResolver, m, env.eAccessRights, env.eNameResEnv, TypeNameResolutionInfo.Default, ofArray([ident(opName, m)]));
      const $var88 = matchValue[0].tag === 0 ? matchValue[1].tail == null ? [0, matchValue[0].data] : [1] : [1];

      switch ($var88[0]) {
        case 0:
          return valRefEq(cenv_1.g, vref, $var88[1]);

        case 1:
          return false;
      }
    } else {
      return false;
    }
  };

  let $var89;

  const activePatternResult40776 = _BinOpExpr___(e);

  if (activePatternResult40776 != null) {
    if (opId_3 = getValue(activePatternResult40776)[0], b_4 = getValue(activePatternResult40776)[2], a_4 = getValue(activePatternResult40776)[1], isOpName(opNameEquals, cenv_1.g.equals_operator_vref, opId_3.idText)) {
      $var89 = [0, getValue(activePatternResult40776)[1], getValue(activePatternResult40776)[2], getValue(activePatternResult40776)[0]];
    } else {
      $var89 = [1];
    }
  } else {
    $var89 = [1];
  }

  switch ($var89[0]) {
    case 0:
      return [$var89[1], $var89[2]];

    case 1:
      let $var90;

      const activePatternResult40775 = _BinOpExpr___(e);

      if (activePatternResult40775 != null) {
        if (opId_2 = getValue(activePatternResult40775)[0], b_3 = getValue(activePatternResult40775)[2], a_3 = getValue(activePatternResult40775)[1], isOpName(opNameEqualsNullable, cenv_1.g.equals_nullable_operator_vref, opId_2.idText)) {
          $var90 = [0, getValue(activePatternResult40775)[1], getValue(activePatternResult40775)[2], getValue(activePatternResult40775)[0]];
        } else {
          $var90 = [1];
        }
      } else {
        $var90 = [1];
      }

      switch ($var90[0]) {
        case 0:
          const a = new SynExpr(20, [0, false, mkSynLidGet($var90[1].Range, ofArray(["`global`", "System"]), "Nullable"), $var90[1], $var90[1].Range]);
          return [a, $var90[2]];

        case 1:
          let $var91;

          const activePatternResult40774 = _BinOpExpr___(e);

          if (activePatternResult40774 != null) {
            if (opId_1 = getValue(activePatternResult40774)[0], b_2 = getValue(activePatternResult40774)[2], a_2 = getValue(activePatternResult40774)[1], isOpName(opNameNullableEquals, cenv_1.g.nullable_equals_operator_vref, opId_1.idText)) {
              $var91 = [0, getValue(activePatternResult40774)[1], getValue(activePatternResult40774)[2], getValue(activePatternResult40774)[0]];
            } else {
              $var91 = [1];
            }
          } else {
            $var91 = [1];
          }

          switch ($var91[0]) {
            case 0:
              const b = new SynExpr(20, [0, false, mkSynLidGet($var91[2].Range, ofArray(["`global`", "System"]), "Nullable"), $var91[2], $var91[2].Range]);
              return [$var91[1], b];

            case 1:
              let $var92;

              const activePatternResult40773 = _BinOpExpr___(e);

              if (activePatternResult40773 != null) {
                if (opId = getValue(activePatternResult40773)[0], b_1 = getValue(activePatternResult40773)[2], a_1 = getValue(activePatternResult40773)[1], isOpName(opNameNullableEqualsNullable, cenv_1.g.nullable_equals_nullable_operator_vref, opId.idText)) {
                  $var92 = [0, getValue(activePatternResult40773)[1], getValue(activePatternResult40773)[2], getValue(activePatternResult40773)[0]];
                } else {
                  $var92 = [1];
                }
              } else {
                $var92 = [1];
              }

              switch ($var92[0]) {
                case 0:
                  return [$var92[1], $var92[2]];

                case 1:
                  return null;
              }

          }

      }

  }
}

export { _JoinRelation___ as $7C$JoinRelation$7C$_$7C$ };
export function TryGetNamedArg(e) {
  let $var93;

  const activePatternResult40780 = _SimpleEqualsExpr___(e);

  if (activePatternResult40780 != null) {
    const activePatternResult40781 = _LongOrSingleIdent___(getValue(activePatternResult40780)[0]);

    if (activePatternResult40781 != null) {
      if (getValue(activePatternResult40781)[1].data[0].tail != null) {
        if (getValue(activePatternResult40781)[1].data[0].tail.tail == null) {
          if (getValue(activePatternResult40781)[2] == null) {
            $var93 = [0, getValue(activePatternResult40781)[1].data[0].head, getValue(activePatternResult40780)[1], getValue(activePatternResult40781)[0]];
          } else {
            $var93 = [1];
          }
        } else {
          $var93 = [1];
        }
      } else {
        $var93 = [1];
      }
    } else {
      $var93 = [1];
    }
  } else {
    $var93 = [1];
  }

  switch ($var93[0]) {
    case 0:
      return [$var93[3], $var93[1], $var93[2]];

    case 1:
      return null;
  }
}
export function GetMethodArgs(arg) {
  let args;
  let $var94;

  if (arg.tag === 2) {
    if (arg.data[0].tag === 0) {
      $var94 = [0];
    } else {
      const activePatternResult40787 = _SynExprParen___(arg);

      if (activePatternResult40787 != null) {
        if (getValue(activePatternResult40787)[0].tag === 4) {
          $var94 = [1, getValue(activePatternResult40787)[0].data[0]];
        } else {
          $var94 = [2];
        }
      } else {
        $var94 = [2];
      }
    }
  } else if (arg.tag === 4) {
    const activePatternResult40788 = _SynExprParen___(arg);

    if (activePatternResult40788 != null) {
      if (getValue(activePatternResult40788)[0].tag === 4) {
        $var94 = [1, getValue(activePatternResult40788)[0].data[0]];
      } else {
        $var94 = [1, arg.data[0]];
      }
    } else {
      $var94 = [1, arg.data[0]];
    }
  } else {
    const activePatternResult40789 = _SynExprParen___(arg);

    if (activePatternResult40789 != null) {
      if (getValue(activePatternResult40789)[0].tag === 4) {
        $var94 = [1, getValue(activePatternResult40789)[0].data[0]];
      } else {
        $var94 = [2];
      }
    } else {
      $var94 = [2];
    }
  }

  switch ($var94[0]) {
    case 0:
      args = new List();
      break;

    case 1:
      args = $var94[1];
      break;

    case 2:
      let $var95;

      const activePatternResult40786 = _SynExprParen___(arg);

      if (activePatternResult40786 != null) {
        $var95 = [0, getValue(activePatternResult40786)[0]];
      } else {
        $var95 = [0, arg];
      }

      switch ($var95[0]) {
        case 0:
          args = ofArray([$var95[1]]);
          break;
      }

      break;
  }

  const patternInput = function (l) {
    return List_1.takeUntil(function (e) {
      let $var96;

      const activePatternResult40783 = _SimpleEqualsExpr___(e);

      if (activePatternResult40783 != null) {
        const activePatternResult40784 = _LongOrSingleIdent___(getValue(activePatternResult40783)[0]);

        if (activePatternResult40784 != null) {
          if (getValue(activePatternResult40784)[1].data[0].tail != null) {
            if (getValue(activePatternResult40784)[1].data[0].tail.tail == null) {
              if (getValue(activePatternResult40784)[2] == null) {
                $var96 = [0];
              } else {
                $var96 = [1];
              }
            } else {
              $var96 = [1];
            }
          } else {
            $var96 = [1];
          }
        } else {
          $var96 = [1];
        }
      } else {
        $var96 = [1];
      }

      switch ($var96[0]) {
        case 0:
          return true;

        case 1:
          return false;
      }
    }, l);
  }(args);

  const namedCallerArgs = choose_1(function (e_1) {
    const matchValue = TryGetNamedArg(e_1);

    if (matchValue == null) {
      if (e_1.tag === 55) {
        return null;
      } else {
        return error_1(new _Error(SR.tcNameArgumentsMustAppearLast(), e_1.Range));
      }
    } else {
      return matchValue;
    }
  }, patternInput[1]);
  return [patternInput[0], namedCallerArgs];
}
export function CompilePatternForMatch(cenv_1, env, mExpr, matchm, warnOnUnused, actionOnFailure, v, generalizedTypars, clauses, inputTy, resultTy) {
  const patternInput = CompilePattern(cenv_1.g, env.DisplayEnv, cenv_1.amap, mExpr, matchm, warnOnUnused, actionOnFailure, v, generalizedTypars, clauses, inputTy, resultTy);
  return mkAndSimplifyMatch(new SequencePointInfoForBinding(4), mExpr, matchm, resultTy, patternInput[0], patternInput[1]);
}
export function CompilePatternForMatchClauses(cenv_1, env, mExpr, matchm, warnOnUnused, actionOnFailure, inputTy, resultTy, tclauses) {
  const $var97 = tclauses.tail != null ? tclauses.head.data[0].tag === 2 ? tclauses.head.data[1] == null ? tclauses.tail.tail == null ? [0, tclauses.head.data[2].data[1], tclauses.head.data[0].data[1].data[1].data[0], tclauses.head.data[3], tclauses.head.data[0].data[0], tclauses.head.data[2].data[2], tclauses.head.data[0].data[1].data[0], tclauses.head.data[2].data[0]] : [1] : [1] : [1] : [1];

  switch ($var97[0]) {
    case 0:
      const expr = CompilePatternForMatch(cenv_1, env, mExpr, matchm, warnOnUnused, actionOnFailure, $var97[6], $var97[2], ofArray([new TypedMatchClause(0, [$var97[4], null, new DecisionTreeTarget(0, [ListSet.remove(function (lv1, lv2) {
        return valEq(lv1, lv2);
      }, $var97[6], $var97[7]), $var97[1], $var97[5]]), $var97[3]])]), inputTy, resultTy);
      return [$var97[6], expr];

    case 1:
      const patternInput = mkCompGenLocal(mExpr, "matchValue", inputTy);
      const expr_1 = CompilePatternForMatch(cenv_1, env, mExpr, matchm, warnOnUnused, actionOnFailure, patternInput[0], new List(), tclauses, inputTy, resultTy);
      return [patternInput[0], expr_1];
  }
}
export function AnalyzeArbitraryExprAsEnumerable(cenv_1, env, localAlloc, m, exprty, expr) {
  const err = function (k, ty) {
    const txt = minimalStringOfType(env.DisplayEnv, ty);
    const msg = k ? SR.tcTypeCannotBeEnumerated(txt) : SR.tcEnumTypeCannotBeEnumerated(txt);
    return new ResultOrException(1, new _Error(msg, m));
  };

  const findMethInfo = function (k_1, m_1, nm, ty_1) {
    const matchValue = TryFindIntrinsicOrExtensionMethInfo(cenv_1, env, m_1, env.eAccessRights, nm, ty_1);

    if (matchValue.tail != null) {
      return new ResultOrException(0, matchValue.head);
    } else {
      return err(k_1, ty_1);
    }
  };

  const hasArgs = function (minfo, minst) {
    const matchValue_1 = minfo.GetParamTypes(cenv_1.amap, m, minst);
    const $var98 = matchValue_1.tail != null ? matchValue_1.head.tail == null ? matchValue_1.tail.tail == null ? [0] : [1] : [1] : [1];

    switch ($var98[0]) {
      case 0:
        return false;

      case 1:
        return true;
    }
  };

  const tryType = function (tupledArg) {
    const matchValue_2 = findMethInfo(true, m, "GetEnumerator", tupledArg[1]);

    if (matchValue_2.tag === 0) {
      const getEnumerator_minst = FreshenMethInfo(m, matchValue_2.data);
      const retTypeOfGetEnumerator = matchValue_2.data.GetFSharpReturnTy(cenv_1.amap, m, getEnumerator_minst);

      if (hasArgs(matchValue_2.data, getEnumerator_minst)) {
        return err(true, tupledArg[1]);
      } else {
        const matchValue_3 = findMethInfo(false, m, "MoveNext", retTypeOfGetEnumerator);

        if (matchValue_3.tag === 0) {
          const moveNext_minst = FreshenMethInfo(m, matchValue_3.data);
          const retTypeOfMoveNext = matchValue_3.data.GetFSharpReturnTy(cenv_1.amap, m, moveNext_minst);

          if (!typeEquiv(cenv_1.g, cenv_1.g.bool_ty, retTypeOfMoveNext)) {
            return err(false, retTypeOfGetEnumerator);
          } else if (hasArgs(matchValue_3.data, moveNext_minst)) {
            return err(false, retTypeOfGetEnumerator);
          } else {
            const matchValue_4 = findMethInfo(false, m, "get_Current", retTypeOfGetEnumerator);

            if (matchValue_4.tag === 0) {
              const get_Current_minst = FreshenMethInfo(m, matchValue_4.data);

              if (hasArgs(matchValue_4.data, get_Current_minst)) {
                return err(false, retTypeOfGetEnumerator);
              } else {
                const enumElemTy = matchValue_4.data.GetFSharpReturnTy(cenv_1.amap, m, get_Current_minst);
                let enumElemTy_1;

                if (isObjTy(cenv_1.g, enumElemTy)) {
                  const allEquivReturnTypes = function (minfo_1, others) {
                    const returnTy = minfo_1.GetFSharpReturnTy(cenv_1.amap, m, new List());
                    return forAll(function (other) {
                      return typeEquiv(cenv_1.g, other.GetFSharpReturnTy(cenv_1.amap, m, new List()), returnTy);
                    }, others);
                  };

                  const isInt32OrObjectIndexer = function (minfo_2) {
                    const matchValue_5 = minfo_2.GetParamTypes(cenv_1.amap, m, new List());
                    const $var99 = matchValue_5.tail != null ? matchValue_5.head.tail != null ? matchValue_5.head.tail.tail == null ? matchValue_5.tail.tail == null ? [0, matchValue_5.head.head] : [1] : [1] : [1] : [1];

                    switch ($var99[0]) {
                      case 0:
                        if (typeEquiv(cenv_1.g, cenv_1.g.int32_ty, $var99[1])) {
                          return true;
                        } else {
                          return typeEquiv(cenv_1.g, cenv_1.g.obj_ty, $var99[1]);
                        }

                      case 1:
                        return false;
                    }
                  };

                  const matchValue_6 = TryFindIntrinsicOrExtensionMethInfo(cenv_1, env, m, env.eAccessRights, "get_Item", tupledArg[1]);
                  const $var100 = matchValue_6.tail != null ? (allEquivReturnTypes(matchValue_6.head, matchValue_6.tail) ? exists_1(isInt32OrObjectIndexer, new List(matchValue_6.head, matchValue_6.tail)) : false) ? [0, matchValue_6.head, matchValue_6.tail] : [1] : [1];

                  switch ($var100[0]) {
                    case 0:
                      enumElemTy_1 = $var100[1].GetFSharpReturnTy(cenv_1.amap, m, new List());
                      break;

                    case 1:
                      const matchValue_7 = TryFindIntrinsicOrExtensionMethInfo(cenv_1, env, m, env.eAccessRights, "Item", tupledArg[1]);
                      const $var101 = matchValue_7.tail != null ? (allEquivReturnTypes(matchValue_7.head, matchValue_7.tail) ? exists_1(isInt32OrObjectIndexer, new List(matchValue_7.head, matchValue_7.tail)) : false) ? [0, matchValue_7.head, matchValue_7.tail] : [1] : [1];

                      switch ($var101[0]) {
                        case 0:
                          enumElemTy_1 = $var101[1].GetFSharpReturnTy(cenv_1.amap, m, new List());
                          break;

                        case 1:
                          enumElemTy_1 = enumElemTy;
                          break;
                      }

                      break;
                  }
                } else {
                  enumElemTy_1 = enumElemTy;
                }

                const isEnumeratorTypeStruct = isStructTy(cenv_1.g, retTypeOfGetEnumerator);
                let patternInput_1;

                if (isEnumeratorTypeStruct) {
                  if (localAlloc) {
                    patternInput_1 = [mkMutableCompGenLocal(m, "enumerator", retTypeOfGetEnumerator), retTypeOfGetEnumerator];
                  } else {
                    const refCellTyForRetTypeOfGetEnumerator = mkRefCellTy(cenv_1.g, retTypeOfGetEnumerator);
                    const patternInput = mkMutableCompGenLocal(m, "enumerator", refCellTyForRetTypeOfGetEnumerator);
                    patternInput_1 = [[patternInput[0], mkRefCellGet(cenv_1.g, m, retTypeOfGetEnumerator, patternInput[1])], refCellTyForRetTypeOfGetEnumerator];
                  }
                } else {
                  patternInput_1 = [mkCompGenLocal(m, "enumerator", retTypeOfGetEnumerator), retTypeOfGetEnumerator];
                }

                const enumeratorVar = patternInput_1[0][0];
                const enumeratorExpr = patternInput_1[0][1];
                let patternInput_2;
                const res = BuildPossiblyConditionalMethodCall(cenv_1, env, new Mutates(1), m, false, matchValue_2.data, new ValUseFlag(1), getEnumerator_minst, ofArray([tupledArg[0]]), new List());

                if (!isEnumeratorTypeStruct ? true : localAlloc) {
                  patternInput_2 = res;
                } else {
                  const getEnumExpr = mkRefCell(cenv_1.g, m, retTypeOfGetEnumerator, res[0]);
                  const getEnumTy = mkRefCellTy(cenv_1.g, res[1]);
                  patternInput_2 = [getEnumExpr, getEnumTy];
                }

                const patternInput_3 = BuildPossiblyConditionalMethodCall(cenv_1, env, new Mutates(0), m, false, matchValue_3.data, new ValUseFlag(1), moveNext_minst, ofArray([enumeratorExpr]), new List());
                const patternInput_4 = BuildPossiblyConditionalMethodCall(cenv_1, env, new Mutates(0), m, true, matchValue_4.data, new ValUseFlag(1), get_Current_minst, ofArray([enumeratorExpr]), new List());
                const betterCurrentExpr = mkCoerceExpr(patternInput_4[0], enumElemTy_1, Expr_get_Range.bind(patternInput_4[0])(), patternInput_4[1]);
                return new ResultOrException(0, [enumeratorVar, enumeratorExpr, patternInput_1[1], enumElemTy_1, patternInput_2[0], patternInput_2[1], patternInput_3[0], patternInput_3[1], betterCurrentExpr]);
              }
            } else {
              return new ResultOrException(1, matchValue_4.data);
            }
          }
        } else {
          return new ResultOrException(1, matchValue_3.data);
        }
      }
    } else {
      return new ResultOrException(1, matchValue_2.data);
    }
  };

  const matchValue_8 = isArray1DTy(cenv_1.g, exprty) ? new ResultOrException(1, Microsoft.FSharp.Core.Operators.Failure("")) : tryType([expr, exprty]);

  if (matchValue_8.tag === 1) {
    const probe = function (ty_2) {
      if (AddCxTypeMustSubsumeTypeUndoIfFailed(env.DisplayEnv, cenv_1.css, m, ty_2, exprty)) {
        const matchValue_9 = tryType([mkCoerceExpr(expr, ty_2, Expr_get_Range.bind(expr)(), exprty), ty_2]);

        if (matchValue_9.tag === 1) {
          ErrorLoggerExtensions.PreserveStackTrace(matchValue_9.data);
          throw matchValue_9.data;
        } else {
          return matchValue_9.data;
        }
      } else {
        return null;
      }
    };

    const enumElemTy_2 = NewInferenceType();
    const exprTyAsSeq = mkSeqTy(cenv_1.g, enumElemTy_2);
    const matchValue_10 = probe(exprTyAsSeq);

    if (matchValue_10 == null) {
      const ienumerable = mkAppTy(cenv_1.g.tcref_System_Collections_IEnumerable, new List());
      const matchValue_11 = probe(ienumerable);

      if (matchValue_11 == null) {
        ErrorLoggerExtensions.PreserveStackTrace(matchValue_8.data);
        throw matchValue_8.data;
      } else {
        return getValue(matchValue_11);
      }
    } else {
      return getValue(matchValue_10);
    }
  } else {
    return matchValue_8.data;
  }
}
export function ConvertArbitraryExprToEnumerable(cenv_1, ty, env, expr) {
  const m = Expr_get_Range.bind(expr)();
  const enumElemTy = NewInferenceType();

  if (AddCxTypeMustSubsumeTypeUndoIfFailed(env.DisplayEnv, cenv_1.css, m, mkSeqTy(cenv_1.g, enumElemTy), ty)) {
    return [expr, enumElemTy];
  } else {
    const patternInput = mkCompGenLocal(m, "inputSequence", ty);
    const patternInput_1 = AnalyzeArbitraryExprAsEnumerable(cenv_1, env, false, m, ty, patternInput[1]);
    const expr_1 = mkCompGenLet(m, patternInput[0], expr, mkCallSeqOfFunctions(cenv_1.g, m, patternInput_1[2], patternInput_1[3], mkUnitDelayLambda(cenv_1.g, m, patternInput_1[4]), mkLambda_1(m, patternInput_1[0], patternInput_1[6], patternInput_1[7]), mkLambda_1(m, patternInput_1[0], patternInput_1[8], patternInput_1[3])));
    return [expr_1, patternInput_1[3]];
  }
}
export function mkSeqEmpty(cenv_1, env, m, genTy) {
  const genResultTy = NewInferenceType();
  UnifyTypes(cenv_1, env, m, genTy, mkSeqTy(cenv_1.g, genResultTy));
  return mkCallSeqEmpty(cenv_1.g, m, genResultTy);
}
export function mkSeqCollect(cenv_1, env, m, enumElemTy, genTy, lam, enumExpr) {
  const genResultTy = NewInferenceType();
  UnifyTypes(cenv_1, env, m, genTy, mkSeqTy(cenv_1.g, genResultTy));
  const enumExpr_1 = mkCoerceIfNeeded(cenv_1.g, mkSeqTy(cenv_1.g, enumElemTy), tyOfExpr(cenv_1.g, enumExpr), enumExpr);
  return mkCallSeqCollect(cenv_1.g, m, enumElemTy, genResultTy, lam, enumExpr_1);
}
export function mkSeqUsing(cenv_1, env, m, resourceTy, genTy, resourceExpr, lam) {
  AddCxTypeMustSubsumeType(new ContextInfo(0), env.DisplayEnv, cenv_1.css, m, new OptionalTrace(0), cenv_1.g.system_IDisposable_typ, resourceTy);
  const genResultTy = NewInferenceType();
  UnifyTypes(cenv_1, env, m, genTy, mkSeqTy(cenv_1.g, genResultTy));
  return mkCallSeqUsing(cenv_1.g, m, resourceTy, genResultTy, resourceExpr, lam);
}
export function mkSeqDelay(cenv_1, env, m, genTy, lam) {
  const genResultTy = NewInferenceType();
  UnifyTypes(cenv_1, env, m, genTy, mkSeqTy(cenv_1.g, genResultTy));
  return mkCallSeqDelay(cenv_1.g, m, genResultTy, mkUnitDelayLambda(cenv_1.g, m, lam));
}
export function mkSeqAppend(cenv_1, env, m, genTy, e1, e2) {
  const genResultTy = NewInferenceType();
  UnifyTypes(cenv_1, env, m, genTy, mkSeqTy(cenv_1.g, genResultTy));
  const e1_1 = mkCoerceIfNeeded(cenv_1.g, mkSeqTy(cenv_1.g, genResultTy), tyOfExpr(cenv_1.g, e1), e1);
  const e2_1 = mkCoerceIfNeeded(cenv_1.g, mkSeqTy(cenv_1.g, genResultTy), tyOfExpr(cenv_1.g, e2), e2);
  return mkCallSeqAppend(cenv_1.g, m, genResultTy, e1_1, e2_1);
}
export function mkSeqFromFunctions(cenv_1, env, m, genTy, e1, e2) {
  const genResultTy = NewInferenceType();
  UnifyTypes(cenv_1, env, m, genTy, mkSeqTy(cenv_1.g, genResultTy));
  const e2_1 = mkCoerceIfNeeded(cenv_1.g, mkSeqTy(cenv_1.g, genResultTy), tyOfExpr(cenv_1.g, e2), e2);
  return mkCallSeqGenerated(cenv_1.g, m, genResultTy, e1, e2_1);
}
export function mkSeqFinally(cenv_1, env, m, genTy, e1, e2) {
  const genResultTy = NewInferenceType();
  UnifyTypes(cenv_1, env, m, genTy, mkSeqTy(cenv_1.g, genResultTy));
  const e1_1 = mkCoerceIfNeeded(cenv_1.g, mkSeqTy(cenv_1.g, genResultTy), tyOfExpr(cenv_1.g, e1), e1);
  return mkCallSeqFinally(cenv_1.g, m, genResultTy, e1_1, e2);
}
export function mkSeqExprMatchClauses(pat_, vspecs, innerExpr) {
  return ofArray([new TypedMatchClause(0, [pat_, null, new DecisionTreeTarget(0, [vspecs, innerExpr, new SequencePointInfoForTarget(0)]), pat_.Range])]);
}
export function compileSeqExprMatchClauses(cenv_1, env, inputExprMark, pat_, vspecs, innerExpr, bindPatTy, genInnerTy) {
  const patMark = pat_.Range;
  const tclauses = mkSeqExprMatchClauses(pat_, vspecs, innerExpr);
  return CompilePatternForMatchClauses(cenv_1, env, inputExprMark, patMark, false, new ActionOnFailure(0), bindPatTy, genInnerTy, tclauses);
}
export function elimFastIntegerForLoop(spBind, id, start, dir, finish, innerExpr, m) {
  const pseudoEnumExpr = dir ? mkSynInfix(m, start, "..", finish) : mkSynTrifix(m, ".. ..", start, new SynExpr(2, [new SynConst(6, -1), start.Range]), finish);
  return new SynExpr(12, [spBind, new SeqExprOnly(0, false), true, mkSynPatVar(null, id), pseudoEnumExpr, innerExpr, m]);
}

function _ExprAsPat___(f) {
  let $var102;

  const activePatternResult40890 = _SingleIdent___(f);

  if (activePatternResult40890 != null) {
    $var102 = [0, getValue(activePatternResult40890)];
  } else {
    const activePatternResult40891 = _SynExprParen___(f);

    if (activePatternResult40891 != null) {
      const activePatternResult40892 = _SingleIdent___(getValue(activePatternResult40891)[0]);

      if (activePatternResult40892 != null) {
        $var102 = [0, getValue(activePatternResult40892)];
      } else {
        $var102 = [1];
      }
    } else {
      $var102 = [1];
    }
  }

  switch ($var102[0]) {
    case 0:
      return mkSynPatVar(null, $var102[1]);

    case 1:
      let $var103;

      const activePatternResult40889 = _SynExprParen___(f);

      if (activePatternResult40889 != null) {
        if (getValue(activePatternResult40889)[0].tag === 4) {
          $var103 = [0, getValue(activePatternResult40889)[0].data[0]];
        } else {
          $var103 = [1];
        }
      } else {
        $var103 = [1];
      }

      switch ($var103[0]) {
        case 0:
          const elems = function (list) {
            return map_1(function (inp) {
              return _SingleIdent___(inp);
            }, list);
          }($var103[1]);

          if (forAll(function (x) {
            return CurriedLambda(() => x != null)();
          }, elems)) {
            return new SynPat(8, [map_1(function (x_1) {
              return mkSynPatVar(null, getValue(x_1));
            }, elems), f.Range]);
          } else {
            return null;
          }

        case 1:
          return null;
      }

  }
}

export { _ExprAsPat___ as $7C$ExprAsPat$7C$_$7C$ };

function _SimpleSemicolonSequence___(acceptDeprecated, c) {
  const YieldFree = function (expr) {
    YieldFree: while (true) {
      const $var104 = expr.tag === 26 ? [0] : expr.tag === 27 ? [1] : expr.tag === 23 ? [2] : expr.tag === 17 ? [3] : expr.tag === 11 ? [4, expr.data[5]] : expr.tag === 24 ? [4, expr.data[0]] : expr.tag === 22 ? [4, expr.data[3]] : expr.tag === 10 ? [4, expr.data[2]] : expr.tag === 12 ? [4, expr.data[5]] : expr.tag === 48 ? [5] : expr.tag === 47 ? [5] : expr.tag === 49 ? [5] : expr.tag === 46 ? [5] : expr.tag === 18 ? [5] : [6];

      switch ($var104[0]) {
        case 0:
          if (YieldFree(expr.data[2])) {
            expr = expr.data[3];
            continue YieldFree;
          } else {
            return false;
          }

        case 1:
          if (YieldFree(expr.data[1])) {
            return forAll(YieldFree, defaultArg(expr.data[2], [], $var105 => [$var105]));
          } else {
            return false;
          }

        case 2:
          if (YieldFree(expr.data[0])) {
            return forAll(function (_arg1) {
              return YieldFree(_arg1.data[2]);
            }, expr.data[2]);
          } else {
            return false;
          }

        case 3:
          return forAll(function (_arg2) {
            return YieldFree(_arg2.data[2]);
          }, expr.data[2]);

        case 4:
          expr = $var104[1];
          continue YieldFree;

        case 5:
          return false;

        case 6:
          return true;
      }
    }
  };

  const IsSimpleSemicolonSequenceElement = function (expr_1) {
    const $var106 = expr_1.tag === 27 ? (acceptDeprecated ? YieldFree(expr_1) : false) ? [0] : [1] : [1];

    switch ($var106[0]) {
      case 0:
        return true;

      case 1:
        switch (expr_1.tag) {
          case 27:
          case 23:
          case 17:
          case 11:
          case 12:
          case 24:
          case 48:
          case 47:
          case 22:
          case 18:
          case 49:
          case 46:
          case 10:
            return false;

          default:
            return true;
        }

    }
  };

  const GetSimpleSemicolonSequenceOfComprehension = function (expr_2, acc) {
    GetSimpleSemicolonSequenceOfComprehension: while (true) {
      const $var107 = expr_2.tag === 26 ? expr_2.data[1] ? [0, expr_2.data[2], expr_2.data[3]] : [1, expr_2] : [1, expr_2];

      switch ($var107[0]) {
        case 0:
          if (IsSimpleSemicolonSequenceElement($var107[1])) {
            expr_2 = $var107[2];
            acc = new List($var107[1], acc);
            continue GetSimpleSemicolonSequenceOfComprehension;
          } else {
            return null;
          }

        case 1:
          if (IsSimpleSemicolonSequenceElement($var107[1])) {
            return reverse(new List($var107[1], acc));
          } else {
            return null;
          }

      }
    }
  };

  if (YieldFree(c)) {
    return GetSimpleSemicolonSequenceOfComprehension(c, new List());
  } else {
    return null;
  }
}

export { _SimpleSemicolonSequence___ as $7C$SimpleSemicolonSequence$7C$_$7C$ };
export class MutRecShape {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecShape",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["Tycon", GenericParam("TypeData")], ["Lets", GenericParam("LetsData")], ["Module", GenericParam("ModuleData"), makeGeneric(List, {
        T: makeGeneric(MutRecShape, {
          TypeData: GenericParam("TypeData"),
          LetsData: GenericParam("LetsData"),
          ModuleData: GenericParam("ModuleData"),
          ModuleAbbrevData: GenericParam("ModuleAbbrevData"),
          OpenData: GenericParam("OpenData")
        })
      })], ["ModuleAbbrev", GenericParam("ModuleAbbrevData")], ["Open", GenericParam("OpenData")]]
    };
  }

  Equals(other) {
    return this === other || this.tag === other.tag && equals(this.data, other.data);
  }

  CompareTo(other) {
    return compareUnions(this, other) | 0;
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecShape", MutRecShape);
export const MutRecShapes = function (__exports) {
  const map = __exports.map = function (f1, f2, f3, x) {
    return map_1(function (_arg1) {
      switch (_arg1.tag) {
        case 3:
          return new MutRecShape(3, _arg1.data);

        case 0:
          return new MutRecShape(0, f1(_arg1.data));

        case 1:
          return new MutRecShape(1, f2(_arg1.data));

        case 2:
          return new MutRecShape(2, [f3(_arg1.data[0]), map(f1, f2, f3, _arg1.data[1])]);

        default:
          return new MutRecShape(4, _arg1.data);
      }
    }, x);
  };

  const mapTycons = __exports.mapTycons = function (f1, xs) {
    return map(f1, function (x) {
      return x;
    }, function (x_1) {
      return x_1;
    }, xs);
  };

  const mapTyconsAndLets = __exports.mapTyconsAndLets = function (f1, f2, xs) {
    return map(f1, f2, function (x) {
      return x;
    }, xs);
  };

  const mapLets = __exports.mapLets = function (f2, xs) {
    return map(function (x) {
      return x;
    }, f2, function (x_1) {
      return x_1;
    }, xs);
  };

  const mapModules = __exports.mapModules = function (f1, xs) {
    return map(function (x) {
      return x;
    }, function (x_1) {
      return x_1;
    }, f1, xs);
  };

  const mapWithEnv = __exports.mapWithEnv = function (fTycon, fLets, env, x) {
    return map_1(function (_arg1) {
      switch (_arg1.tag) {
        case 3:
          return new MutRecShape(3, _arg1.data);

        case 0:
          return new MutRecShape(0, fTycon(env, _arg1.data));

        case 1:
          return new MutRecShape(1, fLets(env, _arg1.data));

        case 2:
          const env2 = _arg1.data[0][1];
          const c = _arg1.data[0][0];
          return new MutRecShape(2, [[c, env2], mapWithEnv(fTycon, fLets, env2, _arg1.data[1])]);

        default:
          return new MutRecShape(4, _arg1.data);
      }
    }, x);
  };

  const mapTyconsWithEnv = __exports.mapTyconsWithEnv = function (f1, env, xs) {
    return mapWithEnv(f1, function (_env, x) {
      return x;
    }, env, xs);
  };

  const mapWithParent = __exports.mapWithParent = function (parent, f1, f2, f3, xs) {
    return map_1(function (_arg1) {
      switch (_arg1.tag) {
        case 3:
          return new MutRecShape(3, _arg1.data);

        case 0:
          return new MutRecShape(0, f2(parent, _arg1.data));

        case 1:
          return new MutRecShape(1, f3(parent, _arg1.data));

        case 2:
          const patternInput = f1(parent, _arg1.data[0], _arg1.data[1]);
          return new MutRecShape(2, [patternInput[0], mapWithParent(patternInput[1], f1, f2, f3, _arg1.data[1])]);

        default:
          return new MutRecShape(4, _arg1.data);
      }
    }, xs);
  };

  const computeEnvs = __exports.computeEnvs = function (f1, f2, env, xs) {
    const env_1 = f2(env, xs);
    return [env_1, map_1(function (_arg1) {
      switch (_arg1.tag) {
        case 3:
          return new MutRecShape(3, _arg1.data);

        case 0:
          return new MutRecShape(0, _arg1.data);

        case 1:
          return new MutRecShape(1, _arg1.data);

        case 2:
          const env2 = f1(env_1, _arg1.data[0]);
          const patternInput = computeEnvs(f1, f2, env2, _arg1.data[1]);
          return new MutRecShape(2, [[_arg1.data[0], patternInput[0]], patternInput[1]]);

        default:
          return new MutRecShape(4, _arg1.data);
      }
    }, xs)];
  };

  const extendEnvs = __exports.extendEnvs = function (f1, env, xs) {
    const env_1 = f1(env, xs);
    return [env_1, map_1(function (_arg1) {
      if (_arg1.tag === 2) {
        const env_2 = _arg1.data[0][1];
        const c = _arg1.data[0][0];
        const patternInput = extendEnvs(f1, env_2, _arg1.data[1]);
        return new MutRecShape(2, [[c, patternInput[0]], patternInput[1]]);
      } else {
        return _arg1;
      }
    }, xs)];
  };

  const dropEnvs = __exports.dropEnvs = function (xs) {
    return mapModules(function (tuple) {
      return tuple[0];
    }, xs);
  };

  const expandTyconsWithEnv = __exports.expandTyconsWithEnv = function (f1, env, xs) {
    const patternInput = unzip(map_1(function (elem) {
      return elem.tag === 0 ? f1(env, elem.data) : [new List(), new List()];
    }, xs));
    return append(ofArray([new MutRecShape(1, concat(patternInput[0]))]), append(map_1(function (elem_1) {
      if (elem_1.tag === 2) {
        const env2 = elem_1.data[0][1];
        const c = elem_1.data[0][0];
        return new MutRecShape(2, [[c, env2], expandTyconsWithEnv(f1, env2, elem_1.data[1])]);
      } else {
        return elem_1;
      }
    }, xs), ofArray([new MutRecShape(1, concat(patternInput[1]))])));
  };

  const mapFoldWithEnv = __exports.mapFoldWithEnv = function (f1, z, env, xs) {
    return mapFold(function (z_1, x) {
      if (x.tag === 2) {
        const env2 = x.data[0][1];
        const c = x.data[0][0];
        const patternInput = mapFoldWithEnv(f1, z_1, env2, x.data[1]);
        return [new MutRecShape(2, [[c, env2], patternInput[0]]), patternInput[1]];
      } else {
        const patternInput_1 = f1(z_1, env, x);
        return [patternInput_1[0], patternInput_1[1]];
      }
    }, z, xs, ofArray);
  };

  const collectTycons = __exports.collectTycons = function (x) {
    return collect(function (_arg1) {
      return _arg1.tag === 0 ? ofArray([_arg1.data]) : _arg1.tag === 2 ? collectTycons(_arg1.data[1]) : new List();
    }, x);
  };

  const topTycons = __exports.topTycons = function (x) {
    return choose_1(function (_arg1) {
      return _arg1.tag === 0 ? makeSome(_arg1.data) : null;
    }, x);
  };

  const iter = __exports.iter = function (f1, f2, f3, f4, f5, x) {
    iterate(function (_arg1) {
      switch (_arg1.tag) {
        case 1:
          f2(_arg1.data);
          break;

        case 2:
          f3(_arg1.data[0]);
          iter(f1, f2, f3, f4, f5, _arg1.data[1]);
          break;

        case 4:
          f4(_arg1.data);
          break;

        case 3:
          f5(_arg1.data);
          break;

        default:
          f1(_arg1.data);
      }
    }, x);
  };

  const iterTycons = __exports.iterTycons = function (f1, x) {
    iter(f1, function (value) {
      value;
    }, function (value_1) {
      value_1;
    }, function (value_2) {
      value_2;
    }, function (value_3) {
      value_3;
    }, x);
  };

  const iterTyconsAndLets = __exports.iterTyconsAndLets = function (f1, f2, x) {
    iter(f1, f2, function (value) {
      value;
    }, function (value_1) {
      value_1;
    }, function (value_2) {
      value_2;
    }, x);
  };

  const iterModules = __exports.iterModules = function (f1, x) {
    iter(function (value) {
      value;
    }, function (value_1) {
      value_1;
    }, f1, function (value_2) {
      value_2;
    }, function (value_3) {
      value_3;
    }, x);
  };

  const iterWithEnv = __exports.iterWithEnv = function (f1, f2, f3, f4, env, x) {
    iterate(function (_arg1) {
      switch (_arg1.tag) {
        case 1:
          f2(env, _arg1.data);
          break;

        case 2:
          const env_1 = _arg1.data[0][1];
          iterWithEnv(f1, f2, f3, f4, env_1, _arg1.data[1]);
          break;

        case 4:
          f3(env, _arg1.data);
          break;

        case 3:
          f4(env, _arg1.data);
          break;

        default:
          f1(env, _arg1.data);
      }
    }, x);
  };

  const iterTyconsWithEnv = __exports.iterTyconsWithEnv = function (f1, env, xs) {
    iterWithEnv(f1, function (_env, _x) {}, function (_env_1, _x_1) {}, function (_env_2, _x_2) {}, env, xs);
  };

  return __exports;
}({});
export class InitializationGraphAnalysisState {
  constructor(tag) {
    this.tag = tag | 0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.InitializationGraphAnalysisState",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["Top"], ["InnerTop"], ["DefinitelyStrict"], ["MaybeLazy"], ["DefinitelyLazy"]]
    };
  }

  Equals(other) {
    return this.tag === other.tag;
  }

  CompareTo(other) {
    return comparePrimitives(this.tag, other.tag);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.InitializationGraphAnalysisState", InitializationGraphAnalysisState);
export class PreInitializationGraphEliminationBinding {
  constructor(fixupPoints, binding) {
    this.FixupPoints = fixupPoints;
    this.Binding = binding;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.PreInitializationGraphEliminationBinding",
      interfaces: ["FSharpRecord"],
      properties: {
        FixupPoints: RecursiveUseFixupPoints,
        Binding: Binding_1
      }
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.PreInitializationGraphEliminationBinding", PreInitializationGraphEliminationBinding);
export function EliminateInitializationGraphs(getTyconBinds, morphTyconBinds, getLetBinds, morphLetBinds, g, mustHaveArity, denv, fixupsAndBindingsWithoutLaziness, bindsm) {
  let recursiveVals;
  const hash = ValHash.Create();

  const add = function (pgrbind) {
    const c = pgrbind.Binding.Var;
    hash.Add(c, c);
  };

  MutRecShapes.iterTyconsAndLets($var108 => function (list) {
    iterate(add, list);
  }(getTyconBinds($var108)), $var109 => function (list_1) {
    iterate(add, list_1);
  }(getLetBinds($var109)), fixupsAndBindingsWithoutLaziness);
  recursiveVals = hash;
  const outOfOrder = {
    contents: false
  };
  const runtimeChecks = {
    contents: false
  };
  const directRecursiveData = {
    contents: false
  };
  const reportedEager = {
    contents: false
  };
  const definiteDependencies = {
    contents: new List()
  };

  const stripChooseAndExpr = function (e) {
    stripChooseAndExpr: while (true) {
      const matchValue = stripExpr(e);

      if (matchValue.tag === 13) {
        e = matchValue.data[1];
        continue stripChooseAndExpr;
      } else {
        return matchValue;
      }
    }
  };

  const availIfInOrder = ValHash.Create();

  const check = function (boundv, expr) {
    const strict = function (_arg1) {
      switch (_arg1.tag) {
        case 4:
          return new InitializationGraphAnalysisState(4);

        case 0:
        case 2:
        case 1:
          return new InitializationGraphAnalysisState(2);

        default:
          return new InitializationGraphAnalysisState(3);
      }
    };

    const lzy = function (_arg2) {
      switch (_arg2.tag) {
        case 1:
        case 4:
          return new InitializationGraphAnalysisState(4);

        case 3:
        case 2:
          return new InitializationGraphAnalysisState(3);

        default:
          return new InitializationGraphAnalysisState(4);
      }
    };

    const fixable = function (_arg3) {
      switch (_arg3.tag) {
        case 1:
          return new InitializationGraphAnalysisState(1);

        case 2:
          return new InitializationGraphAnalysisState(2);

        case 3:
          return new InitializationGraphAnalysisState(3);

        case 4:
          return new InitializationGraphAnalysisState(4);

        default:
          return new InitializationGraphAnalysisState(1);
      }
    };

    const CheckExpr = function (st, e_1) {
      const matchValue_1 = stripChooseAndExpr(e_1);
      const $var110 = matchValue_1.tag === 4 ? [1, matchValue_1.data[2]] : matchValue_1.tag === 8 ? [2, matchValue_1.data[3], matchValue_1.data[5], matchValue_1.data[4], matchValue_1.data[1]] : matchValue_1.tag === 1 ? [3, matchValue_1.data[2], matchValue_1.data[0]] : matchValue_1.tag === 11 ? matchValue_1.data[0].tag === 2 ? [4, matchValue_1.data[2]] : matchValue_1.data[0].tag === 0 ? [4, matchValue_1.data[2]] : matchValue_1.data[0].tag === 10 ? [4, matchValue_1.data[2]] : [11, matchValue_1.data[2], matchValue_1.data[3], matchValue_1.data[0]] : matchValue_1.tag === 0 ? [5] : matchValue_1.tag === 6 ? [6, matchValue_1.data[0], matchValue_1.data[1]] : matchValue_1.tag === 7 ? [7, matchValue_1.data[0], matchValue_1.data[1]] : matchValue_1.tag === 9 ? [8, matchValue_1.data[2], matchValue_1.data[3]] : matchValue_1.tag === 5 ? [9, matchValue_1.data[3], matchValue_1.data[0]] : matchValue_1.tag === 2 ? [10, matchValue_1.data[0], matchValue_1.data[1]] : matchValue_1.tag === 10 ? [10, matchValue_1.data[1], matchValue_1.data[2]] : matchValue_1.tag === 14 ? [12, matchValue_1.data] : matchValue_1.tag === 13 ? [13, matchValue_1.data[1]] : matchValue_1.tag === 12 ? [14] : [0, matchValue_1.data[4]];

      switch ($var110[0]) {
        case 0:
          checkDelayed(st, $var110[1]);
          break;

        case 1:
          CheckExpr(st, $var110[1]);
          break;

        case 2:
          if (isInterfaceTy(g, $var110[4])) {
            iterate(function (_arg1_1) {
              checkDelayed(st, _arg1_1.data[4]);
            }, $var110[3]);
            iterate($var111 => {
              iterate(function (_arg2_1) {
                checkDelayed(st, _arg2_1.data[4]);
              }, $var111[1]);
            }, $var110[2]);
          } else {
            CheckExpr(strict(st), $var110[1]);
            iterate(function (_arg3_1) {
              CheckExpr(lzy(strict(st)), _arg3_1.data[4]);
            }, $var110[3]);
            iterate($var112 => {
              iterate(function (_arg4) {
                CheckExpr(lzy(strict(st)), _arg4.data[4]);
              }, $var112[1]);
            }, $var110[2]);
          }

          break;

        case 3:
          CheckValRef(st, $var110[2], $var110[1]);
          break;

        case 4:
          iterate(CurriedLambda(CheckExpr)(fixable(st)), $var110[1]);
          break;

        case 5:
          break;

        case 6:
          iterate(CurriedLambda(CheckBinding)(strict(st)), $var110[1]);
          CheckExpr(strict(st), $var110[2]);
          break;

        case 7:
          CheckBinding(strict(st), $var110[1]);
          CheckExpr(strict(st), $var110[2]);
          break;

        case 8:
          CheckDecisionTree(strict(st), $var110[1]);
          $var110[2].forEach(CurriedLambda(CheckDecisionTreeTarget)(strict(st)));
          break;

        case 9:
          CheckExpr(strict(st), $var110[2]);
          iterate(CurriedLambda(CheckExpr)(strict(st)), $var110[1]);
          break;

        case 10:
          CheckExpr(strict(st), $var110[1]);
          CheckExpr(strict(st), $var110[2]);
          break;

        case 11:
          CheckExprOp(st, $var110[3], $var110[2]);
          iterate(CurriedLambda(CheckExpr)(strict(st)), $var110[1]);
          break;

        case 12:
          CheckExpr(st, $var110[1].contents);
          break;

        case 13:
          CheckExpr(st, $var110[1]);
          break;

        case 14:
          break;
      }
    };

    const CheckBinding = function (st_1, _arg4_1) {
      CheckExpr(st_1, _arg4_1.data[1]);
    };

    const CheckDecisionTree = function (st_2, _arg6) {
      if (_arg6.tag === 1) {
        iterate(CurriedLambda(CheckExpr)(st_2), _arg6.data[0]);
      } else if (_arg6.tag === 2) {
        CheckBinding(st_2, _arg6.data[0]);
        CheckDecisionTree(st_2, _arg6.data[1]);
      } else {
        CheckExpr(st_2, _arg6.data[0]);
        iterate(function (_arg5) {
          CheckDecisionTree(st_2, _arg5.data[1]);
        }, _arg6.data[1]);
        iterate(CurriedLambda(CheckDecisionTree)(st_2), defaultArg(_arg6.data[2], [], $var113 => [$var113]));
      }
    };

    const CheckDecisionTreeTarget = function (st_3, _arg5_1) {
      CheckExpr(st_3, _arg5_1.data[1]);
    };

    const CheckExprOp = function (st_4, op, m) {
      if (op.tag === 30) {
        CheckValRef(strict(st_4), op.data[1], m);
      }
    };

    const CheckValRef = function (st_5, v, m_1) {
      switch (st_5.tag) {
        case 0:
        case 2:
          if (recursiveVals.TryFind(v.Deref) != null) {
            if (availIfInOrder.TryFind(v.Deref) == null) {
              warning(new LetRecEvaluatedOutOfOrder(denv, boundv, v, m_1));
              outOfOrder.contents = true;

              if (!reportedEager.contents) {
                warning(new LetRecCheckedAtRuntime(m_1));
                reportedEager.contents = true;
              }
            }

            definiteDependencies.contents = new List([boundv, v], definiteDependencies.contents);
          }

          break;

        case 1:
          if (recursiveVals.TryFind(v.Deref) != null) {
            directRecursiveData.contents = true;
          }

          break;

        case 4:
          break;

        default:
          if (recursiveVals.TryFind(v.Deref) != null) {
            warning(new RecursiveUseCheckedAtRuntime(denv, v, m_1));

            if (!reportedEager.contents) {
              warning(new LetRecCheckedAtRuntime(m_1));
              reportedEager.contents = true;
            }

            runtimeChecks.contents = true;
          }

      }
    };

    const checkDelayed = function (st_6, b) {
      switch (st_6.tag) {
        case 2:
          CheckExpr(new InitializationGraphAnalysisState(3), b);
          break;

        case 4:
        case 0:
        case 1:
          break;

        default:
          CheckExpr(new InitializationGraphAnalysisState(3), b);
      }
    };

    CheckExpr(new InitializationGraphAnalysisState(0), expr);
  };

  const checkBind = function (pgrbind_1) {
    check(mkLocalValRef(pgrbind_1.Binding.data[0]), pgrbind_1.Binding.data[1]);
    availIfInOrder.Add(pgrbind_1.Binding.data[0], 1);
  };

  MutRecShapes.iterTyconsAndLets($var114 => function (list_2) {
    iterate(checkBind, list_2);
  }(getTyconBinds($var114)), $var115 => function (list_3) {
    iterate(checkBind, list_3);
  }(getLetBinds($var115)), fixupsAndBindingsWithoutLaziness);

  const ddgNodes = function (list_4) {
    return map_1(function (v_1) {
      return mkLocalValRef(v_1);
    }, list_4);
  }(toList(recursiveVals.Values));

  const ddg = new Graph(function (v_2) {
    return v_2.Stamp;
  }, ddgNodes, definiteDependencies.contents);
  ddg.IterateCycles(function (path) {
    error_1(new LetRecUnsound(denv, path, path.head.Range));
  });
  const requiresLazyBindings = runtimeChecks.contents ? true : outOfOrder.contents;

  if (directRecursiveData.contents ? requiresLazyBindings : false) {
    error_1(new _Error(SR.tcInvalidMixtureOfRecursiveForms(), bindsm));
  }

  if (requiresLazyBindings) {
    const morphBinding = function (pgrbind_2) {
      const matchValue_2 = stripChooseAndExpr(pgrbind_2.Binding.data[1]);
      const $var116 = matchValue_2.tag === 3 ? [0] : matchValue_2.tag === 4 ? [0] : [1];

      switch ($var116[0]) {
        case 0:
          return [new List(), ofArray([mkInvisibleBind(pgrbind_2.Binding.data[0], pgrbind_2.Binding.data[1])])];

        case 1:
          const ty = pgrbind_2.Binding.data[0].Type;
          const m_2 = pgrbind_2.Binding.data[0].Range;
          const vty = mkLazyTy(g, ty);
          const fty = op_MinusMinusGreater(g.unit_ty, ty);
          const patternInput = mkCompGenLocal(m_2, pgrbind_2.Binding.data[0].LogicalName, fty);
          const frhs = mkUnitDelayLambda(g, m_2, pgrbind_2.Binding.data[1]);

          if (mustHaveArity) {
            patternInput[0].SetValReprInfo(InferArityOfExpr(g, new AllowTypeDirectedDetupling(0), fty, new List(), new List(), frhs));
          }

          const patternInput_1 = mkCompGenLocal(m_2, pgrbind_2.Binding.data[0].LogicalName, vty);
          const vrhs = mkLazyDelayed(g, m_2, ty, patternInput[1]);

          if (mustHaveArity) {
            patternInput_1[0].SetValReprInfo(InferArityOfExpr(g, new AllowTypeDirectedDetupling(0), vty, new List(), new List(), vrhs));
          }

          iterate(function (tupledArg) {
            tupledArg[0].contents = mkLazyForce(g, Expr_get_Range.bind(tupledArg[0].contents)(), ty, patternInput_1[1]);
          }, pgrbind_2.FixupPoints.data);
          return [ofArray([mkInvisibleBind(patternInput[0], frhs), mkInvisibleBind(patternInput_1[0], vrhs)]), ofArray([mkBind(pgrbind_2.Binding.data[2], pgrbind_2.Binding.data[0], mkLazyForce(g, m_2, ty, patternInput_1[1]))])];
      }
    };

    const newTopBinds = [];

    const morphBindings = function (pgrbinds) {
      return function (tupledArg_1) {
        newTopBinds.push(concat(tupledArg_1[0]));
        return concat(tupledArg_1[1]);
      }(unzip(function (list_5) {
        return map_1(morphBinding, list_5);
      }(pgrbinds)));
    };

    const res = MutRecShapes.map(CurriedLambda(morphTyconBinds)(morphBindings), CurriedLambda(morphLetBinds)(morphBindings), function (x) {
      return x;
    }, fixupsAndBindingsWithoutLaziness);

    if (newTopBinds.length === 0) {
      return res;
    } else {
      return new List(new MutRecShape(1, concat(newTopBinds)), res);
    }
  } else {
    const noMorph = function (pgrbinds_1) {
      return map_1(function (pgrbind_3) {
        return pgrbind_3.Binding;
      }, pgrbinds_1);
    };

    return MutRecShapes.map(CurriedLambda(morphTyconBinds)(noMorph), CurriedLambda(morphLetBinds)(noMorph), function (x_1) {
      return x_1;
    }, fixupsAndBindingsWithoutLaziness);
  }
}
export function CheckAndRewriteObjectCtor(g, env, ctorLambaExpr) {
  const m = Expr_get_Range.bind(ctorLambaExpr)();
  const patternInput = stripTopLambda(ctorLambaExpr, tyOfExpr(g, ctorLambaExpr));

  const error = function (expr) {
    errorR(new _Error(SR.tcInvalidObjectConstructionExpression(), Expr_get_Range.bind(expr)()));
    return expr;
  };

  const rewriteConstruction = function (recdExpr) {
    if (env.eCtorInfo != null) {
      let recdExpr_1;

      if (getValue(env.eCtorInfo).safeThisValOpt != null) {
        const ty = tyOfExpr(g, recdExpr);
        const thisExpr = mkGetArg0(m, ty);
        const setExpr = mkRefCellSet(g, m, ty, exprForValRef(m, mkLocalValRef(getValue(getValue(env.eCtorInfo).safeThisValOpt))), thisExpr);
        recdExpr_1 = new Expr(2, [recdExpr, setExpr, new SequentialOpKind(1), new SequencePointInfoForSeq(1), m]);
      } else {
        recdExpr_1 = recdExpr;
      }

      let recdExpr_2;

      if (getValue(env.eCtorInfo).safeInitInfo.tag === 0) {
        const thisTy = tyOfExpr(g, recdExpr_1);
        const thisExpr_1 = mkGetArg0(m, thisTy);
        const thisTyInst = argsOfAppTy(g, thisTy);
        const setExpr_1 = mkRecdFieldSetViaExprAddr(thisExpr_1, getValue(env.eCtorInfo).safeInitInfo.data[0], thisTyInst, mkOne(g, m), m);
        recdExpr_2 = new Expr(2, [recdExpr_1, setExpr_1, new SequentialOpKind(1), new SequencePointInfoForSeq(1), m]);
      } else {
        recdExpr_2 = recdExpr_1;
      }

      return recdExpr_2;
    } else {
      return recdExpr;
    }
  };

  const checkAndRewrite = function (expr_1) {
    const $var117 = expr_1.tag === 11 ? expr_1.data[0].tag === 10 ? expr_1.data[0].data[0].tag === 0 ? [0] : [7] : [7] : expr_1.tag === 2 ? expr_1.data[2].tag === 1 ? [2, expr_1.data[1], expr_1.data[4], expr_1.data[0], expr_1.data[3]] : [1, expr_1.data[0], expr_1.data[4], expr_1.data[1], expr_1.data[3]] : expr_1.tag === 7 ? [3, expr_1.data[0], expr_1.data[1], expr_1.data[2]] : expr_1.tag === 9 ? [4, expr_1.data[1], expr_1.data[2], expr_1.data[4], expr_1.data[5], expr_1.data[0], expr_1.data[3]] : expr_1.tag === 6 ? [5, expr_1.data[0], expr_1.data[1]] : expr_1.tag === 5 ? [6, expr_1.data[1], expr_1.data[2], expr_1.data[3], expr_1.data[0], expr_1.data[4]] : [7];

    switch ($var117[0]) {
      case 0:
        return rewriteConstruction(expr_1);

      case 1:
        return new Expr(2, [$var117[1], checkAndRewrite($var117[3]), new SequentialOpKind(0), $var117[4], $var117[2]]);

      case 2:
        return new Expr(2, [checkAndRewrite($var117[3]), $var117[1], new SequentialOpKind(1), $var117[4], $var117[2]]);

      case 3:
        return mkLetBind($var117[3], $var117[1], checkAndRewrite($var117[2]));

      case 4:
        return new Expr(9, [$var117[5], $var117[1], $var117[2], map_3(function (_arg1) {
          return new DecisionTreeTarget(0, [_arg1.data[0], checkAndRewrite(_arg1.data[1]), _arg1.data[2]]);
        }, $var117[6], Array), $var117[3], $var117[4]]);

      case 5:
        return new Expr(6, [$var117[1], checkAndRewrite($var117[2]), m, NewFreeVarsCache()]);

      case 6:
        const f = checkAndRewriteCtorUsage($var117[4]);
        const expr_2 = new Expr(5, [f, $var117[1], $var117[2], $var117[3], $var117[5]]);
        return rewriteConstruction(expr_2);

      case 7:
        return error(expr_1);
    }
  };

  const checkAndRewriteCtorUsage = function (expr_3) {
    const $var118 = expr_3.tag === 14 ? [0, expr_3.data] : expr_3.tag === 5 ? expr_3.data[3].tail == null ? [1, expr_3.data[0], expr_3.data[1], expr_3.data[4], expr_3.data[2]] : [3] : expr_3.tag === 1 ? expr_3.data[1].tag === 1 ? [2, expr_3.data[2], expr_3.data[0]] : [3] : [3];

    switch ($var118[0]) {
      case 0:
        const e = checkAndRewriteCtorUsage($var118[1].contents);
        $var118[1].contents = e;
        return expr_3;

      case 1:
        const f_1 = checkAndRewriteCtorUsage($var118[1]);
        return new Expr(5, [f_1, $var118[2], $var118[4], new List(), $var118[3]]);

      case 2:
        let isCtor;
        const matchValue = $var118[2].MemberInfo;

        if (matchValue != null) {
          isCtor = getValue(matchValue).MemberFlags.MemberKind.Equals(new MemberKind_2(1));
        } else {
          isCtor = false;
        }

        if (!isCtor) {
          return error(expr_3);
        } else {
          return new Expr(1, [$var118[2], new ValUseFlag(3), $var118[1]]);
        }

      case 3:
        return error(expr_3);
    }
  };

  const body = checkAndRewrite(patternInput[2]);
  return mkMultiLambdas(m, patternInput[0], patternInput[1], body, patternInput[3]);
}
export function buildApp(cenv_1, expr, exprty, arg, m) {
  var x0_1;
  var vf_3;
  var x0;
  var vf_2;
  var vf_1;
  var vf;
  const matchValue = [expr, arg];
  const $var119 = matchValue[0].data[1].tag === 5 ? matchValue[0].data[1].data[0].tag === 1 ? matchValue[0].data[1].data[3].tail != null ? matchValue[0].data[1].data[3].tail.tail == null ? (x0_1 = matchValue[0].data[1].data[3].head, vf_3 = matchValue[0].data[1].data[0].data[0], valRefEq(cenv_1.g, vf_3, cenv_1.g.and_vref) ? true : valRefEq(cenv_1.g, vf_3, cenv_1.g.and2_vref)) ? [0, matchValue[0].data[1].data[0].data[0], matchValue[0].data[1].data[3].head] : [1] : [1] : [1] : [1] : [1];

  switch ($var119[0]) {
    case 0:
      return MakeApplicableExprNoFlex(cenv_1, mkLazyAnd(cenv_1.g, m, $var119[2], arg));

    case 1:
      const $var120 = matchValue[0].data[1].tag === 5 ? matchValue[0].data[1].data[0].tag === 1 ? matchValue[0].data[1].data[3].tail != null ? matchValue[0].data[1].data[3].tail.tail == null ? (x0 = matchValue[0].data[1].data[3].head, vf_2 = matchValue[0].data[1].data[0].data[0], valRefEq(cenv_1.g, vf_2, cenv_1.g.or_vref) ? true : valRefEq(cenv_1.g, vf_2, cenv_1.g.or2_vref)) ? [0, matchValue[0].data[1].data[0].data[0], matchValue[0].data[1].data[3].head] : [1] : [1] : [1] : [1] : [1];

      switch ($var120[0]) {
        case 0:
          return MakeApplicableExprNoFlex(cenv_1, mkLazyOr(cenv_1.g, m, $var120[2], arg));

        case 1:
          const $var121 = matchValue[0].data[1].tag === 5 ? matchValue[0].data[1].data[0].tag === 1 ? matchValue[0].data[1].data[3].tail == null ? (vf_1 = matchValue[0].data[1].data[0].data[0], valRefEq(cenv_1.g, vf_1, cenv_1.g.reraise_vref)) ? [0, matchValue[0].data[1].data[0].data[0]] : [1] : [1] : [1] : [1];

          switch ($var121[0]) {
            case 0:
              const patternInput = destFunTy(cenv_1.g, exprty);
              return MakeApplicableExprNoFlex(cenv_1, mkCompGenSequential(m, arg, mkReraise(m, patternInput[1])));

            case 1:
              const $var122 = matchValue[0].data[1].tag === 5 ? matchValue[0].data[1].data[0].tag === 1 ? matchValue[0].data[1].data[3].tail == null ? (vf = matchValue[0].data[1].data[0].data[0], valRefEq(cenv_1.g, vf, cenv_1.g.addrof_vref) ? true : valRefEq(cenv_1.g, vf, cenv_1.g.addrof2_vref)) ? [0, matchValue[0].data[1].data[0].data[0]] : [1] : [1] : [1] : [1];

              switch ($var122[0]) {
                case 0:
                  if (valRefEq(cenv_1.g, $var122[1], cenv_1.g.addrof2_vref)) {
                    warning(new UseOfAddressOfOperator(m));
                  }

                  const patternInput_1 = mkExprAddrOfExpr(cenv_1.g, true, false, new Mutates(0), arg, $var122[1], m);
                  return MakeApplicableExprNoFlex(cenv_1, patternInput_1[0](patternInput_1[1]));

                case 1:
                  return expr.SupplyArgument(arg, m);
              }

          }

      }

  }
}
export class DelayedItem {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.DelayedItem",
      interfaces: ["FSharpUnion"],
      cases: [["DelayedTypeApp", makeGeneric(List, {
        T: SynType
      }), range, range], ["DelayedApp", "number", SynExpr, range], ["DelayedDotLookup", makeGeneric(List, {
        T: Ident
      }), range], ["DelayedDot"], ["DelayedSet", SynExpr, range]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.DelayedItem", DelayedItem);
export function MakeDelayedSet(e, m) {
  return new DelayedItem(4, [new SynExpr(0, [e, range0, null, e.Range]), m]);
}
export class NewSlotsOK {
  constructor(tag) {
    this.tag = tag | 0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.NewSlotsOK",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["NewSlotsOK"], ["NoNewSlots"]]
    };
  }

  Equals(other) {
    return this.tag === other.tag;
  }

  CompareTo(other) {
    return comparePrimitives(this.tag, other.tag);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.NewSlotsOK", NewSlotsOK);
export class ImplictlyBoundTyparsAllowed {
  constructor(tag) {
    this.tag = tag | 0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.ImplictlyBoundTyparsAllowed",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["NewTyparsOKButWarnIfNotRigid"], ["NewTyparsOK"], ["NoNewTypars"]]
    };
  }

  Equals(other) {
    return this.tag === other.tag;
  }

  CompareTo(other) {
    return comparePrimitives(this.tag, other.tag);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.ImplictlyBoundTyparsAllowed", ImplictlyBoundTyparsAllowed);
export class CheckConstraints {
  constructor(tag) {
    this.tag = tag | 0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.CheckConstraints",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["CheckCxs"], ["NoCheckCxs"]]
    };
  }

  Equals(other) {
    return this.tag === other.tag;
  }

  CompareTo(other) {
    return comparePrimitives(this.tag, other.tag);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.CheckConstraints", CheckConstraints);
export class TypeRealizationPass {
  constructor(tag) {
    this.tag = tag | 0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.TypeRealizationPass",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["FirstPass"], ["SecondPass"]]
    };
  }

  Equals(other) {
    return this.tag === other.tag;
  }

  CompareTo(other) {
    return comparePrimitives(this.tag, other.tag);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.TypeRealizationPass", TypeRealizationPass);
export class MemberOrValContainerInfo {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.MemberOrValContainerInfo",
      interfaces: ["FSharpUnion"],
      cases: [["MemberOrValContainerInfo", EntityRef, Option(Tuple([TType, SlotImplSet])), Option(Val), SafeInitData, makeGeneric(List, {
        T: Typar
      })]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.MemberOrValContainerInfo", MemberOrValContainerInfo);
export class ContainerInfo {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.ContainerInfo",
      interfaces: ["FSharpUnion"],
      cases: [["ContainerInfo", ParentRef, Option(MemberOrValContainerInfo)]]
    };
  }

  get ParentRef() {
    return this.data[0];
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.ContainerInfo", ContainerInfo);
export const ExprContainerInfo = new ContainerInfo(0, [new ParentRef(1), null]);
export function ModuleOrNamespaceContainerInfo(modref) {
  return new ContainerInfo(0, [new ParentRef(0, modref), new MemberOrValContainerInfo(0, [modref, null, null, new SafeInitData(1), new List()])]);
}
export function TyconContainerInfo(parent, tcref, declaredTyconTypars, safeInitInfo) {
  return new ContainerInfo(0, [parent, new MemberOrValContainerInfo(0, [tcref, null, null, safeInitInfo, declaredTyconTypars])]);
}
export class NormalizedRecBindingDefn {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.NormalizedRecBindingDefn",
      interfaces: ["FSharpUnion"],
      cases: [["NormalizedRecBindingDefn", ContainerInfo, NewSlotsOK, DeclKind, NormalizedBinding]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.NormalizedRecBindingDefn", NormalizedRecBindingDefn);
export class TyconBindingDefn {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.TyconBindingDefn",
      interfaces: ["FSharpUnion"],
      cases: [["TyconBindingDefn", ContainerInfo, NewSlotsOK, DeclKind, SynMemberDefn, range]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.TyconBindingDefn", TyconBindingDefn);
export class ValSpecResult {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.ValSpecResult",
      interfaces: ["FSharpUnion"],
      cases: [["ValSpecResult", ParentRef, Option(ValMemberInfoTransient), Ident, makeGeneric(List, {
        T: Typar
      }), makeGeneric(List, {
        T: Typar
      }), TType, PartialValReprInfo, DeclKind]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.ValSpecResult", ValSpecResult);
export class RecDefnBindingInfo {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.RecDefnBindingInfo",
      interfaces: ["FSharpUnion"],
      cases: [["RecDefnBindingInfo", ContainerInfo, NewSlotsOK, DeclKind, SynBinding]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.RecDefnBindingInfo", RecDefnBindingInfo);
export class MutRecDataForOpen {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecDataForOpen",
      interfaces: ["FSharpUnion"],
      cases: [["MutRecDataForOpen", makeGeneric(List, {
        T: Ident
      }), range]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecDataForOpen", MutRecDataForOpen);
export class MutRecDataForModuleAbbrev {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecDataForModuleAbbrev",
      interfaces: ["FSharpUnion"],
      cases: [["MutRecDataForModuleAbbrev", Ident, makeGeneric(List, {
        T: Ident
      }), range]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecDataForModuleAbbrev", MutRecDataForModuleAbbrev);
export class MutRecDefnsPhase1DataForTycon {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecDefnsPhase1DataForTycon",
      interfaces: ["FSharpUnion"],
      cases: [["MutRecDefnsPhase1DataForTycon", SynComponentInfo, SynTypeDefnSimpleRepr, makeGeneric(List, {
        T: Tuple([SynType, range])
      }), "boolean", "boolean", "boolean"]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecDefnsPhase1DataForTycon", MutRecDefnsPhase1DataForTycon);
export class MutRecDefnsPhase2DataForTycon {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecDefnsPhase2DataForTycon",
      interfaces: ["FSharpUnion"],
      cases: [["MutRecDefnsPhase2DataForTycon", Option(Entity), ParentRef, DeclKind, EntityRef, Option(Val), SafeInitData, makeGeneric(List, {
        T: Typar
      }), makeGeneric(List, {
        T: SynMemberDefn
      }), range, NewSlotsOK, _Function([Unit, Unit])]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecDefnsPhase2DataForTycon", MutRecDefnsPhase2DataForTycon);
export class MutRecDefnsPhase2DataForModule {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecDefnsPhase2DataForModule",
      interfaces: ["FSharpUnion"],
      cases: [["MutRecDefnsPhase2DataForModule", Any, Entity]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecDefnsPhase2DataForModule", MutRecDefnsPhase2DataForModule);
export class MutRecDefnsPhase2InfoForTycon {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecDefnsPhase2InfoForTycon",
      interfaces: ["FSharpUnion"],
      cases: [["MutRecDefnsPhase2InfoForTycon", Option(Entity), EntityRef, makeGeneric(List, {
        T: Typar
      }), DeclKind, makeGeneric(List, {
        T: TyconBindingDefn
      }), _Function([Unit, Unit])]]
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecDefnsPhase2InfoForTycon", MutRecDefnsPhase2InfoForTycon);
export class RecursiveBindingInfo {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.RecursiveBindingInfo",
      interfaces: ["FSharpUnion"],
      cases: [["RBInfo", "number", ContainerInfo, makeGeneric(List, {
        T: Typar
      }), ValInline, Val, ExplicitTyparInfo, PartialValReprInfo, Option(ValMemberInfoTransient), Option(Val), Option(Val), SafeInitData, Option(SynAccess), TType, DeclKind]]
    };
  }

  get EnclosingDeclaredTypars() {
    return this.data[2];
  }

  get Val() {
    return this.data[4];
  }

  get ExplicitTyparInfo() {
    return this.data[5];
  }

  get DeclaredTypars() {
    const patternInput = this.ExplicitTyparInfo;
    return patternInput.data[1];
  }

  get Index() {
    return this.data[0];
  }

  get ContainerInfo() {
    return this.data[1];
  }

  get DeclKind() {
    return this.data[13];
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.RecursiveBindingInfo", RecursiveBindingInfo);
export class PreCheckingRecursiveBinding {
  constructor(syntacticBinding, recBindingInfo) {
    this.SyntacticBinding = syntacticBinding;
    this.RecBindingInfo = recBindingInfo;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.PreCheckingRecursiveBinding",
      interfaces: ["FSharpRecord"],
      properties: {
        SyntacticBinding: NormalizedBinding,
        RecBindingInfo: RecursiveBindingInfo
      }
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.PreCheckingRecursiveBinding", PreCheckingRecursiveBinding);
export class PreGeneralizationRecursiveBinding {
  constructor(extraGeneralizableTypars, checkedBinding, recBindingInfo) {
    this.ExtraGeneralizableTypars = extraGeneralizableTypars;
    this.CheckedBinding = checkedBinding;
    this.RecBindingInfo = recBindingInfo;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.PreGeneralizationRecursiveBinding",
      interfaces: ["FSharpRecord"],
      properties: {
        ExtraGeneralizableTypars: makeGeneric(List, {
          T: Typar
        }),
        CheckedBinding: CheckedBindingInfo,
        RecBindingInfo: RecursiveBindingInfo
      }
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.PreGeneralizationRecursiveBinding", PreGeneralizationRecursiveBinding);
export class PostGeneralizationRecursiveBinding {
  constructor(valScheme, checkedBinding, recBindingInfo) {
    this.ValScheme = valScheme;
    this.CheckedBinding = checkedBinding;
    this.RecBindingInfo = recBindingInfo;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.PostGeneralizationRecursiveBinding",
      interfaces: ["FSharpRecord"],
      properties: {
        ValScheme: ValScheme,
        CheckedBinding: CheckedBindingInfo,
        RecBindingInfo: RecursiveBindingInfo
      }
    };
  }

  get GeneralizedTypars() {
    return this.ValScheme.GeneralizedTypars;
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.PostGeneralizationRecursiveBinding", PostGeneralizationRecursiveBinding);
export class PostBindCtorThisVarRefCellRecursiveBinding {
  constructor(valScheme, binding) {
    this.ValScheme = valScheme;
    this.Binding = binding;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.PostBindCtorThisVarRefCellRecursiveBinding",
      interfaces: ["FSharpRecord"],
      properties: {
        ValScheme: ValScheme,
        Binding: Binding_1
      }
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.PostBindCtorThisVarRefCellRecursiveBinding", PostBindCtorThisVarRefCellRecursiveBinding);
export function CanInferExtraGeneralizedTyparsForRecBinding(pgrbind) {
  const flex = pgrbind.RecBindingInfo.ExplicitTyparInfo;
  const memFlagsOpt = defaultArg(pgrbind.RecBindingInfo.Val.MemberInfo, null, function (memInfo) {
    return memInfo.MemberFlags;
  });
  const canInferTypars = GeneralizationHelpers.ComputeCanInferExtraGeneralizableTypars(pgrbind.RecBindingInfo.ContainerInfo.ParentRef, flex.data[2], memFlagsOpt);
  return canInferTypars;
}
export function GetInstanceMemberThisVariable(v, x) {
  if (v.IsInstanceMember) {
    const firstArg = function (e) {
      firstArg: while (true) {
        const $var123 = e.tag === 4 ? [0, e.data[2]] : e.tag === 13 ? [1, e.data[1]] : e.tag === 3 ? e.data[3].tail != null ? e.data[3].tail.tail == null ? [2, e.data[3].head] : [3] : [3] : [3];

        switch ($var123[0]) {
          case 0:
            e = $var123[1];
            continue firstArg;

          case 1:
            e = $var123[1];
            continue firstArg;

          case 2:
            return $var123[1];

          case 3:
            throw new Error("GetInstanceMemberThisVariable: instance member did not have expected internal form");
        }
      }
    };

    return firstArg(x);
  } else {
    return null;
  }
}
export function TcTyparConstraint(ridx, cenv_1, newOk, checkCxs, occ, env, tpenv, c) {
  var ty;

  const checkSimpleConstraint = function (tp, m, constraintAdder) {
    const patternInput = TcTypar(cenv_1, env, newOk, tpenv, tp);
    constraintAdder(env.DisplayEnv, cenv_1.css, m, new OptionalTrace(0), mkTyparTy(patternInput[0]));
    return patternInput[1];
  };

  switch (c.tag) {
    case 7:
      const patternInput_1 = TcTypeAndRecover(cenv_1, newOk, checkCxs, new ItemOccurence(2), env, tpenv, c.data[1]);
      const patternInput_2 = TcTypar(cenv_1, env, newOk, patternInput_1[1], c.data[0]);

      if (newOk.Equals(new ImplictlyBoundTyparsAllowed(2)) ? isSealedTy(cenv_1.g, patternInput_1[0]) : false) {
        errorR(new _Error(SR.tcInvalidConstraintTypeSealed(), c.data[2]));
      }

      AddCxTypeMustSubsumeType(new ContextInfo(0), env.DisplayEnv, cenv_1.css, c.data[2], new OptionalTrace(0), patternInput_1[0], mkTyparTy(patternInput_2[0]));
      return patternInput_2[1];

    case 3:
      return checkSimpleConstraint(c.data[0], c.data[1], function (arg00_, arg10_, arg20_, arg30_, arg40_) {
        AddCxTypeMustSupportNull(arg00_, arg10_, arg20_, arg30_, arg40_);
      });

    case 4:
      return checkSimpleConstraint(c.data[0], c.data[1], function (arg00__1, arg10__1, arg20__1, arg30__1, arg40__1) {
        AddCxTypeMustSupportComparison(arg00__1, arg10__1, arg20__1, arg30__1, arg40__1);
      });

    case 5:
      return checkSimpleConstraint(c.data[0], c.data[1], function (arg00__2, arg10__2, arg20__2, arg30__2, arg40__2) {
        AddCxTypeMustSupportEquality(arg00__2, arg10__2, arg20__2, arg30__2, arg40__2);
      });

    case 1:
      return checkSimpleConstraint(c.data[0], c.data[1], function (arg00__3, arg10__3, arg20__3, arg30__3, arg40__3) {
        AddCxTypeIsReferenceType(arg00__3, arg10__3, arg20__3, arg30__3, arg40__3);
      });

    case 0:
      return checkSimpleConstraint(c.data[0], c.data[1], function (arg00__4, arg10__4, arg20__4, arg30__4, arg40__4) {
        AddCxTypeIsValueType(arg00__4, arg10__4, arg20__4, arg30__4, arg40__4);
      });

    case 2:
      return checkSimpleConstraint(c.data[0], c.data[1], function (arg00__5, arg10__5, arg20__5, arg30__5, arg40__5) {
        AddCxTypeIsUnmanaged(arg00__5, arg10__5, arg20__5, arg30__5, arg40__5);
      });

    case 9:
      const patternInput_3 = TcTypar(cenv_1, env, newOk, tpenv, c.data[0]);
      let tpenv_1;
      const $var124 = c.data[1].tail != null ? c.data[1].tail.tail == null ? [0, c.data[1].head] : [1] : [1];

      switch ($var124[0]) {
        case 0:
          const patternInput_4 = TcTypeAndRecover(cenv_1, newOk, checkCxs, new ItemOccurence(2), env, patternInput_3[1], $var124[1]);
          AddCxTypeIsEnum(env.DisplayEnv, cenv_1.css, c.data[2], new OptionalTrace(0), mkTyparTy(patternInput_3[0]), patternInput_4[0]);
          tpenv_1 = patternInput_4[1];
          break;

        case 1:
          errorR(new _Error(SR.tcInvalidEnumConstraint(), c.data[2]));
          tpenv_1 = patternInput_3[1];
          break;
      }

      return tpenv_1;

    case 10:
      const patternInput_5 = TcTypar(cenv_1, env, newOk, tpenv, c.data[0]);
      const $var125 = c.data[1].tail != null ? c.data[1].tail.tail != null ? c.data[1].tail.tail.tail == null ? [0, c.data[1].head, c.data[1].tail.head] : [1] : [1] : [1];

      switch ($var125[0]) {
        case 0:
          const patternInput_6 = TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, patternInput_5[1], $var125[1]);
          const patternInput_7 = TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, patternInput_6[1], $var125[2]);
          AddCxTypeIsDelegate(env.DisplayEnv, cenv_1.css, c.data[2], new OptionalTrace(0), mkTyparTy(patternInput_5[0]), patternInput_6[0], patternInput_7[0]);
          return patternInput_7[1];

        case 1:
          errorR(new _Error(SR.tcInvalidEnumConstraint(), c.data[2]));
          return patternInput_5[1];
      }

    case 8:
      const patternInput_8 = TcPseudoMemberSpec(cenv_1, newOk, env, c.data[0], tpenv, c.data[1], c.data[2]);
      const $var126 = patternInput_8[0].data[1] === ".ctor" ? patternInput_8[0].data[2].MemberKind.Equals(new MemberKind_2(1)) ? [0] : [1] : [1];

      switch ($var126[0]) {
        case 0:
          const matchValue = [patternInput_8[0].data[0], patternInput_8[0].data[3]];
          const $var127 = matchValue[0].tail != null ? matchValue[0].tail.tail == null ? matchValue[1].tail == null ? (ty = matchValue[0].head, typeEquiv(cenv_1.g, ty, GetFSharpViewOfReturnType(cenv_1.g, patternInput_8[0].data[4]))) ? [0, matchValue[0].head] : [1] : [1] : [1] : [1];

          switch ($var127[0]) {
            case 0:
              AddCxTypeMustSupportDefaultCtor(env.DisplayEnv, cenv_1.css, c.data[2], new OptionalTrace(0), $var127[1]);
              return patternInput_8[1];

            case 1:
              errorR(new _Error(SR.tcInvalidNewConstraint(), c.data[2]));
              return patternInput_8[1];
          }

        case 1:
          AddCxMethodConstraint(env.DisplayEnv, cenv_1.css, c.data[2], new OptionalTrace(0), patternInput_8[0]);
          return patternInput_8[1];
      }

    default:
      const patternInput_9 = TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, tpenv, c.data[1]);
      const patternInput_10 = TcTypar(cenv_1, env, newOk, patternInput_9[1], c.data[0]);
      const csenv = MakeConstraintSolverEnv(env.eContextInfo, cenv_1.css, c.data[2], env.DisplayEnv);
      CommitOperationResult(AddConstraint(csenv, 0, c.data[2], new OptionalTrace(0), patternInput_10[0], new TyparConstraint(1, [ridx, patternInput_9[0], c.data[2]])));
      return patternInput_10[1];
  }
}
export function TcPseudoMemberSpec(cenv_1, newOk, env, synTypes, tpenv, memSpfn, m) {
  var checkCxs;
  var occ;
  const patternInput = mapFold((checkCxs = new CheckConstraints(0), occ = new ItemOccurence(2), function (tpenv_1, ty) {
    return TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, tpenv_1, ty);
  }), tpenv, synTypes, ofArray);

  if (memSpfn.tag === 0) {
    const patternInput_1 = TcValSpec(cenv_1, env, new DeclKind(0), newOk, ExprContainerInfo, memSpfn.data[1], patternInput[0].head, patternInput[1], memSpfn.data[0], new List());
    const $var128 = patternInput_1[0].tail != null ? patternInput_1[0].tail.tail == null ? [0, patternInput_1[0].head.data[2], patternInput_1[0].head.data[5], patternInput_1[0].head.data[6]] : [1] : [1];

    switch ($var128[0]) {
      case 0:
        const patternInput_2 = tryDestForallTy(cenv_1.g, $var128[2]);
        const topValInfo = TranslatePartialArity(patternInput_2[0], $var128[3]);
        const patternInput_3 = GetTopValTypeInCompiledForm(cenv_1.g, topValInfo, $var128[2], memSpfn.data[2]);
        const argtys = concat(patternInput_3[1]);
        const argtys_1 = map_1(function (tuple) {
          return tuple[0];
        }, argtys);
        const logicalCompiledName = ComputeLogicalName($var128[1], memSpfn.data[1]);
        const item = new Item(20, [$var128[1], $var128[2], null]);
        CallNameResolutionSink(cenv_1.tcSink, $var128[1].idRange, env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, env.eAccessRights);
        return [new TraitConstraintInfo(0, [patternInput[0], logicalCompiledName, memSpfn.data[1], argtys_1, patternInput_3[2], {
          contents: null
        }]), patternInput_1[1]];

      case 1:
        return error_1(new _Error(SR.tcInvalidConstraint(), memSpfn.data[2]));
    }
  } else {
    return error_1(new _Error(SR.tcInvalidConstraint(), m));
  }
}
export function TcValSpec(cenv_1, env, declKind, newOk, containerInfo, memFlagsOpt, thisTyOpt, tpenv, valSpfn, attrs) {
  var denv;
  const synTypars = valSpfn.data[2].data[0];
  const synTyparConstraints = valSpfn.data[2].data[2];
  const declaredTypars = TcTyparDecls(cenv_1, env, synTypars);
  let patternInput_1;

  if (containerInfo.data[1] == null) {
    patternInput_1 = [new List(), null, thisTyOpt, new DeclKind(0)];
  } else {
    const tcref = getValue(containerInfo.data[1]).data[0];
    const declaredTyconTypars = getValue(containerInfo.data[1]).data[4];
    const isExtrinsic = declKind.Equals(new DeclKind(2));
    const patternInput = FreshenObjectArgType(cenv_1, valSpfn.data[10], new TyparRigidity(0), tcref, isExtrinsic, declaredTyconTypars);
    patternInput_1 = [patternInput[1], tcref, patternInput[4], declKind];
  }

  const allDeclaredTypars = append(patternInput_1[0], declaredTypars);
  const envinner = AddDeclaredTypars(new CheckForDuplicateTyparFlag(1), allDeclaredTypars, env);
  const checkCxs = new CheckConstraints(0);
  const tpenv_1 = TcTyparConstraints(cenv_1, newOk, checkCxs, new ItemOccurence(2), envinner, tpenv, synTyparConstraints);
  const tpenv_2 = valSpfn.data[3].tag === 9 ? TcTyparConstraints(cenv_1, newOk, checkCxs, new ItemOccurence(2), envinner, tpenv_1, valSpfn.data[3].data[1]) : tpenv_1;
  iterate((denv = env.DisplayEnv, function (tp) {
    SetTyparRigid(cenv_1.g, denv, valSpfn.data[10], tp);
  }), allDeclaredTypars);
  const patternInput_2 = TcTypeAndRecover(cenv_1, newOk, checkCxs, new ItemOccurence(2), envinner, tpenv_2, valSpfn.data[3]);
  const matchValue = [memFlagsOpt, patternInput_1[2]];
  const $var129 = matchValue[0] != null ? matchValue[1] != null ? [0, getValue(matchValue[0]), getValue(matchValue[1])] : [1] : [1];

  switch ($var129[0]) {
    case 0:
      const generateOneMember = function (memberFlags) {
        let patternInput_4;

        switch (memberFlags.MemberKind.tag) {
          case 1:
          case 2:
            patternInput_4 = [patternInput_2[0], valSpfn.data[4]];
            break;

          case 3:
          case 4:
            const fakeArgReprInfos = toList(delay(function () {
              return map_2(function (n) {
                return toList(delay(function () {
                  return collect_1(function (matchValue_1) {
                    return singleton(ValReprInfoModule.unnamedTopArg1);
                  }, range_1(1, n));
                }));
              }, SynInfo.AritiesOfArgs(valSpfn.data[4]));
            }));
            const patternInput_3 = GetTopTauTypeInFSharpForm(cenv_1.g, fakeArgReprInfos, patternInput_2[0], valSpfn.data[10]);

            if (patternInput_3[0].length > 1) {
              error_1(new _Error(SR.tcInvalidPropertyType(), valSpfn.data[10]));
            }

            if (memberFlags.MemberKind.tag === 3) {
              if (SynInfo.HasNoArgs(valSpfn.data[4])) {
                patternInput_4 = [op_MinusMinusGreater(cenv_1.g.unit_ty, patternInput_2[0]), SynInfo.IncorporateEmptyTupledArgForPropertyGetter(valSpfn.data[4])];
              } else {
                patternInput_4 = [patternInput_2[0], valSpfn.data[4]];
              }
            } else {
              const setterTy = op_MinusMinusGreater(mkRefTupledTy(cenv_1.g, append(map_1(function (tuple) {
                return tuple[0];
              }, concat(patternInput_3[0])), ofArray([patternInput_3[1]]))), cenv_1.g.unit_ty);
              const synInfo = SynInfo.IncorporateSetterArg(valSpfn.data[4]);
              patternInput_4 = [setterTy, synInfo];
            }

            break;

          case 5:
            patternInput_4 = error_1(new InternalError("Unexpected MemberKind.PropertyGetSet from signature parsing", valSpfn.data[10]));
            break;

          default:
            patternInput_4 = [patternInput_2[0], valSpfn.data[4]];
        }

        const valSynInfo = AdjustValSynInfoInSignature(cenv_1.g, patternInput_4[0], patternInput_4[1]);
        const patternInput_5 = memberFlags.IsInstance ? [op_MinusMinusGreater($var129[2], patternInput_4[0]), SynInfo.IncorporateSelfArg(valSynInfo)] : [patternInput_4[0], valSynInfo];

        const reallyGenerateOneMember = function (tupledArg) {
          const partialValReprInfo = TranslateTopValSynInfo(tupledArg[0].idRange, function (attrTgt, synAttribs) {
            return TcAttributes(cenv_1, env, attrTgt, synAttribs);
          }, tupledArg[1]);
          let ty_;

          if (SynInfo.HasOptionalArgs(tupledArg[1])) {
            const patternInput_6 = GetTopTauTypeInFSharpForm(cenv_1.g, partialValReprInfo.data[0], tupledArg[2], valSpfn.data[10]);
            const argtysl = map_1(function (tupledArg_1) {
              return map_1(function (tupledArg_2) {
                return SynInfo.IsOptionalArg(tupledArg_2[1]) ? mkOptionTy(cenv_1.g, tupledArg_2[0]) : tupledArg_2[0];
              }, toList(zip(tupledArg_1[0], tupledArg_1[1])));
            }, toList(zip(List_1.mapSquared(function (tuple_1) {
              return tuple_1[0];
            }, patternInput_6[0]), tupledArg[1].ArgInfos)));
            ty_ = mkIteratedFunTy(map_1(function (arg10_) {
              return mkRefTupledTy(cenv_1.g, arg10_);
            }, argtysl), patternInput_6[1]);
          } else {
            ty_ = tupledArg[2];
          }

          let memberInfoOpt;

          if (patternInput_1[1] == null) {
            memberInfoOpt = null;
          } else {
            const isExtrinsic_1 = patternInput_1[3].Equals(new DeclKind(2));
            const memberInfoTransient = MakeMemberDataAndMangledNameForMemberVal(cenv_1.g, getValue(patternInput_1[1]), isExtrinsic_1, attrs, new List(), tupledArg[3], tupledArg[1], tupledArg[0], false);
            memberInfoOpt = memberInfoTransient;
          }

          return new ValSpecResult(0, [containerInfo.data[0], memberInfoOpt, tupledArg[0], patternInput_1[0], declaredTypars, ty_, partialValReprInfo, patternInput_1[3]]);
        };

        return toList(delay(function () {
          return append_1(singleton(reallyGenerateOneMember([valSpfn.data[1], patternInput_5[1], patternInput_5[0], memberFlags])), delay(function () {
            if (CompileAsEvent(cenv_1.g, attrs)) {
              const valSynInfo_1 = EventDeclarationNormalization.ConvertSynInfo(valSpfn.data[1].idRange, patternInput_5[1]);
              const memberFlags_1 = EventDeclarationNormalization.ConvertMemberFlags(memberFlags);
              const delTy = FindDelegateTypeOfPropertyEvent(cenv_1.g, cenv_1.amap, valSpfn.data[1].idText, valSpfn.data[1].idRange, patternInput_2[0]);
              const ty = memberFlags_1.IsInstance ? op_MinusMinusGreater($var129[2], op_MinusMinusGreater(delTy, cenv_1.g.unit_ty)) : op_MinusMinusGreater(delTy, cenv_1.g.unit_ty);
              return append_1(singleton(reallyGenerateOneMember([ident("add_" + valSpfn.data[1].idText, valSpfn.data[1].idRange), valSynInfo_1, ty, memberFlags_1])), delay(function () {
                return singleton(reallyGenerateOneMember([ident("remove_" + valSpfn.data[1].idText, valSpfn.data[1].idRange), valSynInfo_1, ty, memberFlags_1]));
              }));
            } else {
              return empty();
            }
          }));
        }));
      };

      switch ($var129[1].MemberKind.tag) {
        case 1:
        case 2:
        case 3:
        case 4:
          return [generateOneMember($var129[1]), patternInput_2[1]];

        case 5:
          return [toList(delay(function () {
            var MemberKind;
            return append_1(generateOneMember((MemberKind = new MemberKind_2(3), new MemberFlags($var129[1].IsInstance, $var129[1].IsDispatchSlot, $var129[1].IsOverrideOrExplicitImpl, $var129[1].IsFinal, MemberKind))), delay(function () {
              var MemberKind_1;
              return generateOneMember((MemberKind_1 = new MemberKind_2(4), new MemberFlags($var129[1].IsInstance, $var129[1].IsDispatchSlot, $var129[1].IsOverrideOrExplicitImpl, $var129[1].IsFinal, MemberKind_1)));
            }));
          })), patternInput_2[1]];

        default:
          return [generateOneMember($var129[1]), patternInput_2[1]];
      }

    case 1:
      const valSynInfo_2 = AdjustValSynInfoInSignature(cenv_1.g, patternInput_2[0], valSpfn.data[4]);
      const partialValReprInfo_1 = TranslateTopValSynInfo(valSpfn.data[1].idRange, function (attrTgt_1, synAttribs_1) {
        return TcAttributes(cenv_1, env, attrTgt_1, synAttribs_1);
      }, valSynInfo_2);
      return [ofArray([new ValSpecResult(0, [containerInfo.data[0], null, valSpfn.data[1], patternInput_1[0], declaredTypars, patternInput_2[0], partialValReprInfo_1, patternInput_1[3]])]), patternInput_2[1]];
  }
}
export function TcTyparOrMeasurePar(optKind, cenv_1, env, newOk, tpenv, _arg1) {
  const checkRes = function (res) {
    const matchValue = [optKind, res.Kind];
    const $var130 = matchValue[0] != null ? getValue(matchValue[0]).tag === 0 ? matchValue[1].tag === 1 ? [1] : [2] : matchValue[1].tag === 0 ? [0] : [2] : [2];

    switch ($var130[0]) {
      case 0:
        error_1(new _Error(SR.tcExpectedUnitOfMeasureMarkWithAttribute(), _arg1.data[0].idRange));
        return [res, tpenv];

      case 1:
        error_1(new _Error(SR.tcExpectedTypeParameter(), _arg1.data[0].idRange));
        return [res, tpenv];

      case 2:
        const item = new Item(17, [_arg1.data[0].idText, res]);
        CallNameResolutionSink(cenv_1.tcSink, _arg1.data[0].idRange, env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(2), env.DisplayEnv, env.eAccessRights);
        return [res, tpenv];
    }
  };

  const key = _arg1.data[0].idText;
  const matchValue_1 = tryFind_1(key, env.eNameResEnv.eTypars);

  if (matchValue_1 == null) {
    const matchValue_2 = TryFindUnscopedTypar(key, tpenv);

    if (matchValue_2 == null) {
      if (newOk.Equals(new ImplictlyBoundTyparsAllowed(2))) {
        const predictTypeParameters = function () {
          const predictions1 = map_2(function (p) {
            return "'" + p[0];
          }, env.eNameResEnv.eTypars);
          const predictions2 = map_2(function (p_1) {
            return "'" + p_1[0];
          }, tpenv.data);
          return new Set(toList(delay(function () {
            return append_1(predictions1, delay(function () {
              return predictions2;
            }));
          })));
        };

        const reportedId = new Ident("'" + _arg1.data[0].idText, _arg1.data[0].idRange);
        error_1(new UndefinedName(0, function (arg00) {
          return SR.undefinedNameTypeParameter(arg00);
        }, reportedId, predictTypeParameters));
      }

      const tp_ = NewTypar(optKind != null ? getValue(optKind) : new TyparKind(0), new TyparRigidity(2), _arg1, false, new TyparDynamicReq(1), new List(), false, false);
      const item_1 = new Item(17, [_arg1.data[0].idText, tp_]);
      CallNameResolutionSink(cenv_1.tcSink, _arg1.data[0].idRange, env.NameEnv, item_1, item_1, emptyTyparInst, new ItemOccurence(2), env.DisplayEnv, env.eAccessRights);
      return [tp_, AddUnscopedTypar(key, tp_, tpenv)];
    } else {
      return checkRes(getValue(matchValue_2));
    }
  } else {
    return checkRes(getValue(matchValue_1));
  }
}
export function TcTypar(cenv_1, env, newOk, tpenv, tp) {
  return TcTyparOrMeasurePar(new TyparKind(0), cenv_1, env, newOk, tpenv, tp);
}
export function TcTyparDecl(cenv_1, env, _arg2) {
  const id = _arg2.data[1].data[0];
  const attrs = TcAttributes(cenv_1, env, 16384, _arg2.data[0]);
  const hasMeasureAttr = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_MeasureAttribute, attrs);
  const hasEqDepAttr = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_EqualityConditionalOnAttribute, attrs);
  const hasCompDepAttr = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_ComparisonConditionalOnAttribute, attrs);
  const attrs_1 = filter($var131 => !IsMatchingFSharpAttribute(cenv_1.g, cenv_1.g.attrib_MeasureAttribute, $var131), attrs);
  const tp = NewTypar(hasMeasureAttr ? new TyparKind(1) : new TyparKind(0), new TyparRigidity(2), _arg2.data[1], false, new TyparDynamicReq(1), attrs_1, hasEqDepAttr, hasCompDepAttr);
  const matchValue = TryFindFSharpStringAttribute(cenv_1.g, cenv_1.g.attrib_CompiledNameAttribute, attrs_1);

  if (matchValue == null) {} else {
    tp.typar_il_name = getValue(matchValue);
  }

  const item = new Item(17, [id.idText, tp]);
  CallNameResolutionSink(cenv_1.tcSink, id.idRange, env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(2), env.DisplayEnv, env.eAccessRights);
  return tp;
}
export function TcTyparDecls(cenv_1, env, synTypars) {
  return map_1(function (arg20_) {
    return TcTyparDecl(cenv_1, env, arg20_);
  }, synTypars);
}
export function TcTypeOrMeasure(optKind, cenv_1, newOk, checkCxs, occ, env, tpenv, ty) {
  const $var132 = ty.tag === 1 ? ty.data[0].tag === 0 ? [2, ty.data[3], ty.data[2], ty.data[6], ty.data[5], ty.data[0].data.data[0]] : ty.data[0].tag === 7 ? [16, ty.data[3], ty.data[0], ty.data[2], ty.data[6], ty.data[0].data[1], ty.data[5]] : ty.data[0].tag === 12 ? [16, ty.data[3], ty.data[0], ty.data[2], ty.data[6], ty.data[0].data[2], ty.data[5]] : [17, ty.data[6]] : ty.tag === 2 ? [3, ty.data[4], ty.data[3], ty.data[1].data[0], ty.data[0], ty.data[6]] : ty.tag === 3 ? [4, ty.data[0], ty.data[1]] : ty.tag === 4 ? [5, ty.data[0], ty.data[1]] : ty.tag === 6 ? [6, ty.data[0], ty.data[1]] : ty.tag === 5 ? [7, ty.data[1], ty.data[2], ty.data[0]] : ty.tag === 7 ? [8, ty.data[0]] : ty.tag === 8 ? [9, ty.data] : ty.tag === 9 ? [10, ty.data[0], ty.data[1]] : ty.tag === 10 ? [11, ty.data[1], ty.data[0]] : ty.tag === 13 ? [12, ty.data[0], ty.data[1]] : ty.tag === 15 ? [13, ty.data[2]] : ty.tag === 14 ? [13, ty.data[1]] : ty.tag === 12 ? [14, ty.data[1], ty.data[2], ty.data[0]] : ty.tag === 11 ? [15, ty.data[2], ty.data[0], ty.data[1]] : ty.data.data[0].tail == null ? [0] : [1, ty.data, ty.data.data[0]];

  switch ($var132[0]) {
    case 0:
      return [cenv_1.g.obj_ty, tpenv];

    case 1:
      const m = $var132[1].Range;
      const tcref = ResultOrExceptionModule.ForceRaise(ResolveTypeLongIdent(cenv_1.tcSink, cenv_1.nameResolver, occ, new FullyQualifiedFlag(1), env.eNameResEnv, env.eAccessRights, $var132[2], TypeNameResolutionStaticArgsInfo.DefiniteEmpty, new PermitDirectReferenceToGeneratedType(1)));
      const matchValue = [optKind, tcref.TypeOrMeasureKind];
      const $var133 = matchValue[0] != null ? getValue(matchValue[0]).tag === 1 ? matchValue[1].tag === 1 ? [2] : [1] : matchValue[1].tag === 0 ? [3] : [0] : matchValue[1].tag === 0 ? [3] : [2];

      switch ($var133[0]) {
        case 0:
          error_1(new _Error(SR.tcExpectedTypeNotUnitOfMeasure(), m));
          return [NewErrorType(), tpenv];

        case 1:
          error_1(new _Error(SR.tcExpectedUnitOfMeasureNotType(), m));
          return [new TType(6, NewErrorMeasure()), tpenv];

        case 2:
          return [new TType(6, new Measure(1, tcref)), tpenv];

        case 3:
          return TcTypeApp(cenv_1, newOk, checkCxs, occ, env, tpenv, m, tcref, new List(), new List());
      }

    case 2:
      const tcref_1 = ResultOrExceptionModule.ForceRaise(ResolveTypeLongIdent(cenv_1.tcSink, cenv_1.nameResolver, new ItemOccurence(2), new FullyQualifiedFlag(1), env.eNameResEnv, env.eAccessRights, $var132[5], TypeNameResolutionStaticArgsInfo.FromTyArgs($var132[2].length), new PermitDirectReferenceToGeneratedType(1)));
      const matchValue_1 = [optKind, tcref_1.TypeOrMeasureKind];
      const $var134 = matchValue_1[0] != null ? getValue(matchValue_1[0]).tag === 1 ? matchValue_1[1].tag === 1 ? [3] : [1] : matchValue_1[1].tag === 0 ? [2] : [0] : matchValue_1[1].tag === 1 ? [3] : [2];

      switch ($var134[0]) {
        case 0:
          error_1(new _Error(SR.tcExpectedTypeNotUnitOfMeasure(), $var132[3]));
          return [NewErrorType(), tpenv];

        case 1:
          error_1(new _Error(SR.tcExpectedUnitOfMeasureNotType(), $var132[3]));
          return [new TType(6, NewErrorMeasure()), tpenv];

        case 2:
          if ($var132[4] ? exists_1(function (tp) {
            const matchValue_2 = tp.Kind;

            if (matchValue_2.tag === 1) {
              return true;
            } else {
              return false;
            }
          }, tcref_1.Typars($var132[3])) : false) {
            error_1(new _Error(SR.tcInvalidUnitsOfMeasurePrefix(), $var132[3]));
          }

          return TcTypeApp(cenv_1, newOk, checkCxs, occ, env, tpenv, $var132[3], tcref_1, new List(), $var132[2]);

        case 3:
          const matchValue_3 = [$var132[2], $var132[4]];
          const $var135 = matchValue_3[0].tail != null ? matchValue_3[0].tail.tail == null ? matchValue_3[1] ? [0, matchValue_3[0].head] : [1] : [1] : [1];

          switch ($var135[0]) {
            case 0:
              const patternInput = TcMeasure(cenv_1, newOk, checkCxs, occ, env, tpenv, $var135[1], $var132[3]);
              return [new TType(6, new Measure(2, [new Measure(1, tcref_1), patternInput[0]])), patternInput[1]];

            case 1:
              errorR(new _Error(SR.tcUnitsOfMeasureInvalidInTypeConstructor(), $var132[3]));
              return [NewErrorType(), tpenv];
          }

      }

    case 3:
      const patternInput_1 = TcType(cenv_1, newOk, checkCxs, occ, env, tpenv, $var132[4]);

      const activePatternResult41266 = function (arg10_) {
        return _AppTy___(cenv_1.g, arg10_);
      }(patternInput_1[0]);

      if (activePatternResult41266 != null) {
        const tcref_2 = ResolveTypeLongIdentInTyconRef(cenv_1.tcSink, cenv_1.nameResolver, env.eNameResEnv, TypeNameResolutionInfo.ResolveToTypeRefs(TypeNameResolutionStaticArgsInfo.FromTyArgs($var132[2].length)), env.eAccessRights, $var132[5], getValue(activePatternResult41266)[0], $var132[3]);
        return TcTypeApp(cenv_1, newOk, checkCxs, occ, env, patternInput_1[1], $var132[5], tcref_2, getValue(activePatternResult41266)[1], $var132[2]);
      } else {
        return error_1(new _Error(SR.tcTypeHasNoNestedTypes(), $var132[5]));
      }

    case 4:
      const isMeasure = optKind == null ? exists_1(function (tupledArg) {
        return tupledArg[0];
      }, $var132[1]) : getValue(optKind).tag === 1 ? true : false;

      if (isMeasure) {
        const patternInput_2 = TcMeasuresAsTuple(cenv_1, newOk, checkCxs, occ, env, tpenv, $var132[1], $var132[2]);
        return [new TType(6, patternInput_2[0]), patternInput_2[1]];
      } else {
        const patternInput_3 = TcTypesAsTuple(cenv_1, newOk, checkCxs, occ, env, tpenv, $var132[1], $var132[2]);
        return [new TType(2, [tupInfoRef, patternInput_3[0]]), patternInput_3[1]];
      }

    case 5:
      const patternInput_4 = TcTypesAsTuple(cenv_1, newOk, checkCxs, occ, env, tpenv, $var132[1], $var132[2]);
      return [new TType(2, [tupInfoStruct, patternInput_4[0]]), patternInput_4[1]];

    case 6:
      const patternInput_5 = TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, tpenv, $var132[1]);
      const patternInput_6 = TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, patternInput_5[1], $var132[2]);
      return [op_MinusMinusGreater(patternInput_5[0], patternInput_6[0]), patternInput_6[1]];

    case 7:
      const patternInput_7 = TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, tpenv, $var132[1]);
      return [mkArrayTy(cenv_1.g, $var132[3], patternInput_7[0], $var132[2]), patternInput_7[1]];

    case 8:
      const patternInput_8 = TcTyparOrMeasurePar(optKind, cenv_1, env, newOk, tpenv, $var132[1]);
      const matchValue_4 = patternInput_8[0].Kind;

      if (matchValue_4.tag === 0) {
        return [mkTyparTy(patternInput_8[0]), patternInput_8[1]];
      } else {
        return [new TType(6, new Measure(0, patternInput_8[0])), patternInput_8[1]];
      }

    case 9:
      const tp_1 = TcAnonTypeOrMeasure(optKind, cenv_1, new TyparRigidity(4), new TyparDynamicReq(0), newOk, $var132[1]);
      const matchValue_5 = tp_1.Kind;

      if (matchValue_5.tag === 0) {
        return [mkTyparTy(tp_1), tpenv];
      } else {
        return [new TType(6, new Measure(0, tp_1)), tpenv];
      }

    case 10:
      const patternInput_9 = TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, tpenv, $var132[1]);
      const tpenv_1 = TcTyparConstraints(cenv_1, newOk, checkCxs, occ, env, patternInput_9[1], $var132[2]);
      return [patternInput_9[0], tpenv_1];

    case 11:
      const tp_2 = TcAnonTypeOrMeasure(new TyparKind(0), cenv_1, new TyparRigidity(2), new TyparDynamicReq(1), newOk, $var132[1]);
      const patternInput_10 = TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, tpenv, $var132[2]);
      AddCxTypeMustSubsumeType(new ContextInfo(0), env.DisplayEnv, cenv_1.css, $var132[1], new OptionalTrace(0), patternInput_10[0], mkTyparTy(tp_2));
      return [tp_2.AsType, patternInput_10[1]];

    case 12:
      const matchValue_6 = [$var132[1], optKind];
      const $var136 = matchValue_6[1] != null ? getValue(matchValue_6[1]).tag === 0 ? [0] : matchValue_6[0].tag === 6 ? matchValue_6[0].data === 1 ? [1] : [2] : [2] : matchValue_6[0].tag === 6 ? matchValue_6[0].data === 1 ? [1] : [2] : [2];

      switch ($var136[0]) {
        case 0:
          errorR(new _Error(SR.parsInvalidLiteralInType(), $var132[2]));
          return [NewErrorType(), tpenv];

        case 1:
          return [new TType(6, new Measure(4)), tpenv];

        case 2:
          errorR(new _Error(SR.parsInvalidLiteralInType(), $var132[2]));
          return [NewErrorType(), tpenv];
      }

    case 13:
      errorR(new _Error(SR.parsInvalidLiteralInType(), $var132[1]));
      return [NewErrorType(), tpenv];

    case 14:
      const $var137 = optKind != null ? getValue(optKind).tag === 0 ? [0] : [1] : [1];

      switch ($var137[0]) {
        case 0:
          errorR(new _Error(SR.tcUnexpectedSymbolInTypeExpression("^"), $var132[2]));
          return [NewErrorType(), tpenv];

        case 1:
          const patternInput_11 = TcMeasure(cenv_1, newOk, checkCxs, occ, env, tpenv, $var132[3], $var132[2]);
          return [new TType(6, new Measure(5, [patternInput_11[0], TcSynRationalConst($var132[1])])), patternInput_11[1]];
      }

    case 15:
      const $var138 = optKind != null ? getValue(optKind).tag === 0 ? [0] : [1] : [1];

      switch ($var138[0]) {
        case 0:
          errorR(new _Error(SR.tcUnexpectedSymbolInTypeExpression("/"), $var132[1]));
          return [NewErrorType(), tpenv];

        case 1:
          const patternInput_12 = TcMeasure(cenv_1, newOk, checkCxs, occ, env, tpenv, $var132[2], $var132[1]);
          const patternInput_13 = TcMeasure(cenv_1, newOk, checkCxs, occ, env, patternInput_12[1], $var132[3], $var132[1]);
          return [new TType(6, new Measure(2, [patternInput_12[0], new Measure(3, patternInput_13[0])])), patternInput_13[1]];
      }

    case 16:
      const matchValue_7 = [optKind, $var132[3], $var132[6]];
      const $var139 = matchValue_7[0] != null ? getValue(matchValue_7[0]).tag === 1 ? matchValue_7[1].tail != null ? matchValue_7[1].tail.tail == null ? matchValue_7[2] ? [0, matchValue_7[1].head] : [1] : [1] : [1] : [1] : matchValue_7[1].tail != null ? matchValue_7[1].tail.tail == null ? matchValue_7[2] ? [0, matchValue_7[1].head] : [1] : [1] : [1];

      switch ($var139[0]) {
        case 0:
          const patternInput_14 = TcMeasure(cenv_1, newOk, checkCxs, occ, env, tpenv, $var132[2], $var132[5]);
          const patternInput_15 = TcMeasure(cenv_1, newOk, checkCxs, occ, env, patternInput_14[1], $var139[1], $var132[4]);
          return [new TType(6, new Measure(2, [patternInput_14[0], patternInput_15[0]])), patternInput_15[1]];

        case 1:
          errorR(new _Error(SR.tcTypeParameterInvalidAsTypeConstructor(), $var132[4]));
          return [NewErrorType(), tpenv];
      }

    case 17:
      errorR(new _Error(SR.tcIllegalSyntaxInTypeExpression(), $var132[1]));
      return [NewErrorType(), tpenv];
  }
}
export function TcType(cenv_1, newOk, checkCxs, occ, env, tpenv, ty) {
  return TcTypeOrMeasure(new TyparKind(0), cenv_1, newOk, checkCxs, occ, env, tpenv, ty);
}
export function TcMeasure(cenv_1, newOk, checkCxs, occ, env, tpenv, ty, m) {
  if (ty.tag === 8) {
    error_1(new _Error(SR.tcAnonymousUnitsOfMeasureCannotBeNested(), ty.data));
    return [NewErrorMeasure(), tpenv];
  } else {
    const matchValue = TcTypeOrMeasure(new TyparKind(1), cenv_1, newOk, checkCxs, occ, env, tpenv, ty);

    if (matchValue[0].tag === 6) {
      const ms = matchValue[0].data;
      return [ms, matchValue[1]];
    } else {
      error_1(new _Error(SR.tcExpectedUnitOfMeasureNotType(), m));
      return [NewErrorMeasure(), tpenv];
    }
  }
}
export function TcAnonTypeOrMeasure(optKind, _cenv, rigid, dyn, newOk, m) {
  if (newOk.Equals(new ImplictlyBoundTyparsAllowed(2))) {
    errorR(new _Error(SR.tcAnonymousTypeInvalidInDeclaration(), m));
  }

  const rigid_1 = (rigid.Equals(new TyparRigidity(4)) ? newOk.Equals(new ImplictlyBoundTyparsAllowed(0)) : false) ? new TyparRigidity(2) : rigid;
  let kind;
  const $var140 = optKind != null ? getValue(optKind).tag === 1 ? [0] : [1] : [1];

  switch ($var140[0]) {
    case 0:
      kind = new TyparKind(1);
      break;

    case 1:
      kind = new TyparKind(0);
      break;
  }

  return NewAnonTypar(kind, m, rigid_1, new TyparStaticReq(0), dyn);
}
export function TcTypes(cenv_1, newOk, checkCxs, occ, env, tpenv, args) {
  return mapFold(function (tpenv_1, ty) {
    return TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, tpenv_1, ty);
  }, tpenv, args, ofArray);
}
export function TcTypesAsTuple(cenv_1, newOk, checkCxs, occ, env, tpenv, args, m) {
  if (args.tail != null) {
    if (args.tail.tail == null) {
      const patternInput = TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, tpenv, args.head[1]);
      return [ofArray([patternInput[0]]), patternInput[1]];
    } else {
      const patternInput_1 = TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, tpenv, args.head[1]);
      const patternInput_2 = TcTypesAsTuple(cenv_1, newOk, checkCxs, occ, env, patternInput_1[1], args.tail, m);

      if (args.head[0]) {
        errorR(new _Error(SR.tcUnexpectedSlashInType(), m));
      }

      return [new List(patternInput_1[0], patternInput_2[0]), patternInput_2[1]];
    }
  } else {
    return error_1(new InternalError("empty tuple type", m));
  }
}
export function TcMeasuresAsTuple(cenv_1, newOk, checkCxs, occ, env, tpenv, args, m) {
  const gather = function (args_1, tpenv_1, isquot, acc) {
    gather: while (true) {
      if (args_1.tail != null) {
        const typ = args_1.head[1];
        const nextisquot = args_1.head[0];
        const patternInput = TcMeasure(cenv_1, newOk, checkCxs, occ, env, tpenv_1, typ, m);
        args_1 = args_1.tail;
        tpenv_1 = patternInput[1];
        const $var557 = nextisquot;
        acc = isquot ? new Measure(2, [acc, new Measure(3, patternInput[0])]) : new Measure(2, [acc, patternInput[0]]);
        isquot = $var557;
        continue gather;
      } else {
        return [acc, tpenv_1];
      }
    }
  };

  return gather(args, tpenv, false, new Measure(4));
}
export function TcTypesOrMeasures(optKinds, cenv_1, newOk, checkCxs, occ, env, tpenv, args, m) {
  var optKind;

  if (optKinds != null) {
    if (getValue(optKinds).length === args.length) {
      return mapFold(function (tpenv_1, tupledArg) {
        return TcTypeOrMeasure(tupledArg[1], cenv_1, newOk, checkCxs, occ, env, tpenv_1, tupledArg[0]);
      }, tpenv, toList(zip(args, getValue(optKinds))), ofArray);
    } else if (getValue(optKinds).tail == null) {
      return error_1(new _Error(SR.tcUnexpectedTypeArguments(), m));
    } else {
      return error_1(new _Error(SR.tcTypeParameterArityMismatch(getValue(optKinds).length, args.length), m));
    }
  } else {
    return mapFold((optKind = null, function (tpenv_2, ty) {
      return TcTypeOrMeasure(optKind, cenv_1, newOk, checkCxs, occ, env, tpenv_2, ty);
    }), tpenv, args, ofArray);
  }
}
export function TcTyparConstraints(cenv_1, newOk, checkCxs, occ, env, tpenv, wcs) {
  const patternInput = fold(function (tupledArg, tc) {
    return [tupledArg[0] - 1, TcTyparConstraint(tupledArg[0], cenv_1, newOk, checkCxs, occ, env, tupledArg[1], tc)];
  }, [wcs.length - 1, tpenv], wcs);
  return patternInput[1];
}
export function TcTypeApp(cenv_1, newOk, checkCxs, occ, env, tpenv, m, tcref, pathTypeArgs, synArgTys) {
  CheckTyconAccessible(cenv_1.amap, m, env.eAccessRights, tcref);
  CommitOperationResult(CheckEntityAttributes(cenv_1.g, tcref, m));
  const patternInput = infoOfTyconRef(m, tcref);

  if (checkCxs.Equals(new CheckConstraints(1))) {
    iterate(function (tp) {
      tp.typar_constraints = new List();
    }, patternInput[0]);
  }

  if (patternInput[2].length !== pathTypeArgs.length + synArgTys.length) {
    error_1(new TyconBadArgs(env.DisplayEnv, tcref, pathTypeArgs.length + synArgTys.length, m));
  }

  let patternInput_1;
  const tpsForArgs = List_1.drop(patternInput[0].length - synArgTys.length, patternInput[0]);
  const kindsForArgs = map_1(function (tp_1) {
    return tp_1.Kind;
  }, tpsForArgs);
  patternInput_1 = TcTypesOrMeasures(kindsForArgs, cenv_1, newOk, checkCxs, occ, env, tpenv, synArgTys, m);
  const actualArgTys = append(pathTypeArgs, patternInput_1[0]);

  if (checkCxs.Equals(new CheckConstraints(0))) {
    iterate2(function (expectedTy, actualTy) {
      UnifyTypes(cenv_1, env, m, expectedTy, actualTy);
    }, patternInput[2], actualArgTys);
  }

  const ty = function (arg00, arg10) {
    return cenv_1.g.decompileType(arg00, arg10);
  }(tcref, actualArgTys);

  return [ty, patternInput_1[1]];
}
export function TcTypeOrMeasureAndRecover(optKind, cenv_1, newOk, checkCxs, occ, env, tpenv, ty) {
  try {
    return TcTypeOrMeasure(optKind, cenv_1, newOk, checkCxs, occ, env, tpenv, ty);
  } catch (e) {
    errorRecovery(e, ty.Range);
    let rty;
    const matchValue = [optKind, newOk];
    const $var141 = matchValue[0] != null ? getValue(matchValue[0]).tag === 1 ? matchValue[1].tag === 2 ? [0] : [1] : matchValue[1].tag === 2 ? [2] : [3] : matchValue[1].tag === 2 ? [2] : [3];

    switch ($var141[0]) {
      case 0:
        rty = new TType(6, new Measure(4));
        break;

      case 1:
        rty = new TType(6, NewErrorMeasure());
        break;

      case 2:
        rty = cenv_1.g.obj_ty;
        break;

      case 3:
        rty = NewErrorType();
        break;
    }

    return [rty, tpenv];
  }
}
export function TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, env, tpenv, ty) {
  return TcTypeOrMeasureAndRecover(new TyparKind(0), cenv_1, newOk, checkCxs, occ, env, tpenv, ty);
}
export function TcNestedTypeApplication(cenv_1, newOk, checkCxs, occ, env, tpenv, mWholeTypeApp, typ, tyargs) {
  const typ_1 = helpEnsureTypeHasMetadata(cenv_1.g, typ);

  if (!isAppTy(cenv_1.g, typ_1)) {
    error_1(new _Error(SR.tcTypeHasNoNestedTypes(), mWholeTypeApp));
  }

  if (typ_1.tag === 1) {
    const pathTypeArgs = List_1.take(typ_1.data[1].length - typ_1.data[0].Typars(mWholeTypeApp).length > 0 ? typ_1.data[1].length - typ_1.data[0].Typars(mWholeTypeApp).length : 0, typ_1.data[1]);
    return TcTypeApp(cenv_1, newOk, checkCxs, occ, env, tpenv, mWholeTypeApp, typ_1.data[0], pathTypeArgs, tyargs);
  } else {
    return error_1(new InternalError("TcNestedTypeApplication: expected type application", mWholeTypeApp));
  }
}
export function TryAdjustHiddenVarNameToCompGenName(cenv_1, env, id, altNameRefCellOpt) {
  if (altNameRefCellOpt == null) {
    return null;
  } else if (getValue(altNameRefCellOpt).contents.tag === 1) {
    return getValue(altNameRefCellOpt).contents.data;
  } else {
    const matchValue = ResolvePatternLongIdent(cenv_1.tcSink, cenv_1.nameResolver, new WarnOnUpperFlag(1), false, id.idRange, env.eAccessRights, env.eNameResEnv, TypeNameResolutionInfo.Default, ofArray([id]));

    if (matchValue.tag === 6) {
      return null;
    } else {
      getValue(altNameRefCellOpt).contents = new SynSimplePatAlternativeIdInfo(1, getValue(altNameRefCellOpt).contents.data);
      return getValue(altNameRefCellOpt).contents.data;
    }
  }
}
export function TcSimplePat(optArgsOK, checkCxs, cenv_1, ty, env, tpenv, names, takenNames, p) {
  TcSimplePat: while (true) {
    if (p.tag === 1) {
      const patternInput = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(1), checkCxs, new ItemOccurence(2), env, tpenv, p.data[1]);
      const $var142 = p.data[0].tag === 0 ? p.data[0].data[4] ? [0] : [1] : [1];

      switch ($var142[0]) {
        case 0:
          UnifyTypes(cenv_1, env, p.data[2], ty, mkOptionTy(cenv_1.g, patternInput[0]));
          break;

        case 1:
          UnifyTypes(cenv_1, env, p.data[2], ty, patternInput[0]);
          break;
      }

      optArgsOK = optArgsOK;
      checkCxs = checkCxs;
      cenv_1 = cenv_1;
      ty = ty;
      env = env;
      tpenv = patternInput[1];
      names = names;
      takenNames = takenNames;
      p = p.data[0];
      continue TcSimplePat;
    } else if (p.tag === 2) {
      optArgsOK = optArgsOK;
      checkCxs = checkCxs;
      cenv_1 = cenv_1;
      ty = ty;
      env = env;
      tpenv = tpenv;
      names = names;
      takenNames = takenNames;
      p = p.data[0];
      continue TcSimplePat;
    } else {
      const matchValue = TryAdjustHiddenVarNameToCompGenName(cenv_1, env, p.data[0], p.data[1]);

      if (matchValue == null) {
        if (p.data[4]) {
          if (!optArgsOK) {
            errorR(new _Error(SR.tcOptionalArgsOnlyOnMembers(), p.data[5]));
          }

          const tyarg = NewInferenceType();
          UnifyTypes(cenv_1, env, p.data[5], ty, mkOptionTy(cenv_1.g, tyarg));
        }

        const patternInput_1 = TcPatBindingName(cenv_1, env, p.data[0], ty, p.data[3], null, null, new ValInline(2), permitInferTypars, noArgOrRetAttribs, false, null, p.data[2], names, takenNames);
        return [p.data[0].idText, [tpenv, patternInput_1[1], patternInput_1[2]]];
      } else {
        optArgsOK = optArgsOK;
        checkCxs = checkCxs;
        cenv_1 = cenv_1;
        ty = ty;
        env = env;
        tpenv = tpenv;
        names = names;
        takenNames = takenNames;
        p = new SynSimplePat(0, [getValue(matchValue), null, p.data[2], p.data[3], p.data[4], p.data[5]]);
        continue TcSimplePat;
      }
    }
  }
}
export function ValidateOptArgOrder(spats) {
  const getPats = function (spats_1) {
    getPats: while (true) {
      if (spats_1.tag === 1) {
        spats_1 = spats_1.data[0];
        continue getPats;
      } else {
        return [spats_1.data[0], spats_1.data[1]];
      }
    }
  };

  const isOptArg = function (pat) {
    isOptArg: while (true) {
      if (pat.tag === 1) {
        pat = pat.data[0];
        continue isOptArg;
      } else if (pat.tag === 2) {
        pat = pat.data[0];
        continue isOptArg;
      } else {
        return pat.data[4];
      }
    }
  };

  const patternInput = getPats(spats);
  const hitOptArg = {
    contents: false
  };
  iterate(function (pat_1) {
    if (isOptArg(pat_1)) {
      hitOptArg.contents = true;
    } else if (hitOptArg.contents) {
      error_1(new _Error(SR.tcOptionalArgsMustComeAfterNonOptionalArgs(), patternInput[1]));
    }
  }, patternInput[0]);
}
export function TcSimplePats(cenv_1, optArgsOK, checkCxs, ty, env, tpenv, names, takenNames, p) {
  TcSimplePats: while (true) {
    ValidateOptArgOrder(p);

    if (p.tag === 1) {
      const patternInput = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, p.data[1]);
      const $var143 = p.data[0].tag === 0 ? p.data[0].data[0].tail != null ? p.data[0].data[0].head.tag === 0 ? p.data[0].data[0].head.data[4] ? p.data[0].data[0].tail.tail == null ? [0] : [1] : [1] : [1] : [1] : [1];

      switch ($var143[0]) {
        case 0:
          UnifyTypes(cenv_1, env, p.data[2], ty, mkOptionTy(cenv_1.g, patternInput[0]));
          break;

        case 1:
          UnifyTypes(cenv_1, env, p.data[2], ty, patternInput[0]);
          break;
      }

      cenv_1 = cenv_1;
      optArgsOK = optArgsOK;
      checkCxs = checkCxs;
      ty = ty;
      env = env;
      tpenv = patternInput[1];
      names = names;
      takenNames = takenNames;
      p = p.data[0];
      continue TcSimplePats;
    } else if (p.data[0].tail != null) {
      if (p.data[0].tail.tail == null) {
        const patternInput_1 = TcSimplePat(optArgsOK, checkCxs, cenv_1, ty, env, tpenv, names, takenNames, p.data[0].head);
        const tpenv_1 = patternInput_1[1][0];
        const takenNames_1 = patternInput_1[1][2];
        const names_1 = patternInput_1[1][1];
        return [ofArray([patternInput_1[0]]), [tpenv_1, names_1, takenNames_1]];
      } else {
        const ptys = UnifyRefTupleType(env.eContextInfo, cenv_1, env.DisplayEnv, p.data[1], ty, p.data[0]);
        const patternInput_2 = mapFold(function (tpenv_2, tupledArg) {
          return TcSimplePat(optArgsOK, checkCxs, cenv_1, tupledArg[0], env, tpenv_2[0], tpenv_2[1], tpenv_2[2], tupledArg[1]);
        }, [tpenv, names, takenNames], toList(zip(ptys, p.data[0])), ofArray);
        const tpenv_3 = patternInput_2[1][0];
        const takenNames_2 = patternInput_2[1][2];
        const names_2 = patternInput_2[1][1];
        return [patternInput_2[0], [tpenv_3, names_2, takenNames_2]];
      }
    } else {
      const id = ident("unitVar" + takenNames.size.toString(), p.data[1]);
      UnifyTypes(cenv_1, env, p.data[1], ty, cenv_1.g.unit_ty);
      const patternInput_3 = TcPatBindingName(cenv_1, env, id, ty, false, null, null, new ValInline(2), permitInferTypars, noArgOrRetAttribs, false, null, true, names, takenNames);
      return [ofArray([id.idText]), [tpenv, patternInput_3[1], patternInput_3[2]]];
    }
  }
}
export function TcSimplePatsOfUnknownType(cenv_1, optArgsOK, checkCxs, env, tpenv, spats) {
  const argty = NewInferenceType();
  return TcSimplePats(cenv_1, optArgsOK, checkCxs, argty, env, tpenv, NameMapModule.empty(), create_1(null, new Comparer(comparePrimitives)), spats);
}
export function TcPatBindingName(cenv_1, env, id, ty, isMemberThis, vis1, topValData, inlineFlag, declaredTypars, argAttribs, isMutable, vis2, compgen, names, takenNames) {
  const vis = vis1 != null ? vis1 : vis2;

  if (takenNames.has(id.idText)) {
    errorR(new VarBoundTwice(id));
  }

  const compgen_1 = compgen ? true : IsCompilerGeneratedName(id.idText);
  const baseOrThis = isMemberThis ? new ValBaseOrThisInfo(3) : new ValBaseOrThisInfo(2);
  const names_1 = add_1(id.idText, new PrelimValScheme1(0, [id, declaredTypars, ty, topValData, null, isMutable, inlineFlag, baseOrThis, argAttribs, vis, compgen_1]), names);
  const takenNames_1 = add_2(id.idText, takenNames);
  return [function (_arg2) {
    var vref;
    let patternInput;
    const matchValue = tryFind_1(id.idText, _arg2.data[0]);

    if (matchValue == null) {
      patternInput = error_1(new _Error(SR.tcNameNotBoundInPattern(id.idText), id.idRange));
    } else {
      const name = id.idText;

      if (!isNullOrEmpty(name) ? System.Char.IsLower(name[0]) : false) {
        const matchValue_1 = TryFindPatternByName(name, env.eNameResEnv);
        const $var144 = matchValue_1 != null ? getValue(matchValue_1).tag === 0 ? (vref = getValue(matchValue_1).data, CurriedLambda(() => vref.LiteralValue != null)()) ? [0, getValue(matchValue_1).data] : [1] : [1] : [1];

        switch ($var144[0]) {
          case 0:
            warning(new _Error(SR.checkLowercaseLiteralBindingInPattern(id.idText), id.idRange));
            break;

          case 1:
            const $var145 = matchValue_1 == null ? [0] : [0];

            switch ($var145[0]) {
              case 0:
                break;
            }

            break;
        }
      }

      patternInput = getValue(matchValue);
    }

    if ((!_arg2.data[1] ? !patternInput[0].IsCompilerGenerated : false) ? !(patternInput[0].LogicalName.indexOf("_") === 0) : false) {
      const item = new Item(0, mkLocalValRef(patternInput[0]));
      CallNameResolutionSink(cenv_1.tcSink, id.idRange, env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(0), env.DisplayEnv, env.eAccessRights);
    }

    return new PatternValBinding(0, [patternInput[0], patternInput[1]]);
  }, names_1, takenNames_1];
}
export function TcPatAndRecover(warnOnUpper, cenv_1, env, topValInfo, vFlags_0, vFlags_1, vFlags_2, vFlags_3, vFlags_4, vFlags_5, tpenv, names, takenNames, ty, pat) {
  const vFlags = [vFlags_0, vFlags_1, vFlags_2, vFlags_3, vFlags_4, vFlags_5];

  try {
    return TcPat(warnOnUpper, cenv_1, env, topValInfo, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], tpenv, names, takenNames, ty, pat);
  } catch (e) {
    const m = pat.Range;
    errorRecovery(e, m);
    return [function (_arg3) {
      return new Pattern(1, m);
    }, [tpenv, names, takenNames]];
  }
}
export function TcPat(warnOnUpper, cenv_1, env, topValInfo, vFlags_0, vFlags_1, vFlags_2, vFlags_3, vFlags_4, vFlags_5, tpenv, names, takenNames, ty, pat) {
  TcPat: while (true) {
    const vFlags = [vFlags_0, vFlags_1, vFlags_2, vFlags_3, vFlags_4, vFlags_5];
    const $var146 = pat.tag === 1 ? [1, pat.data] : pat.tag === 15 ? [2, pat.data[0], pat.data[1]] : pat.tag === 2 ? pat.data[0].tag === 15 ? [2, pat.data[0].data[0], pat.data[0].data[1]] : [4, pat.data[1], pat.data[2], pat.data[4], pat.data[0], pat.data[3]] : pat.tag === 14 ? [3, pat.data[1]] : pat.tag === 3 ? [5, pat.data[1], pat.data[2], pat.data[0]] : pat.tag === 4 ? [6, pat.data[2]] : pat.tag === 5 ? [7, pat.data[2], pat.data[0], pat.data[1]] : pat.tag === 6 ? [8, pat.data[1], pat.data[0]] : pat.tag === 7 ? [9, pat.data[3], pat.data[0].data[0], pat.data[5], pat.data[2], pat.data[4]] : pat.tag === 16 ? [10, pat.data[1]] : pat.tag === 8 ? [11, pat.data[0], pat.data[1]] : pat.tag === 9 ? [12, pat.data[0], pat.data[1]] : pat.tag === 10 ? [13, pat.data[0]] : pat.tag === 11 ? [14, pat.data[1], pat.data[0], pat.data[2]] : pat.tag === 12 ? [15, pat.data[0], pat.data[1]] : pat.tag === 17 ? [16, pat.data[0], pat.data[1], pat.data[2]] : pat.tag === 13 ? [17, pat.data] : pat.tag === 18 ? [18, pat.data[4]] : pat.tag === 19 ? [19, pat.data[0]] : [0, pat.data[0], pat.data[1]];

    switch ($var146[0]) {
      case 0:
        if ($var146[1].tag === 18) {
          UnifyTypes(cenv_1, env, $var146[1].data[1], ty, mkByteArrayTy(cenv_1.g));
          const topValInfo_1 = null;
          const pat_1 = new SynPat(11, [true, toList(delay(function () {
            return map_2(function (b) {
              return new SynPat(0, [new SynConst(3, b), $var146[1].data[1]]);
            }, $var146[1].data[0]);
          })), $var146[1].data[1]]);
          warnOnUpper = warnOnUpper;
          cenv_1 = cenv_1;
          env = env;
          topValInfo = topValInfo_1;
          vFlags_0 = vFlags[0];
          vFlags_1 = vFlags[1];
          vFlags_2 = vFlags[2];
          vFlags_3 = vFlags[3];
          vFlags_4 = vFlags[4];
          vFlags_5 = vFlags[5];
          tpenv = tpenv;
          names = names;
          takenNames = takenNames;
          ty = ty;
          pat = pat_1;
          continue TcPat;
        } else if ($var146[1].tag === 16) {
          return error_1(new _Error(SR.tcInvalidNonPrimitiveLiteralInPatternMatch(), $var146[2]));
        } else {
          const c_ = TcConst(cenv_1, ty, $var146[2], env, $var146[1]);
          return [function (_arg4) {
            return new Pattern(0, [c_, $var146[2]]);
          }, [tpenv, names, takenNames]];
        }

      case 1:
        return [function (_arg5) {
          return new Pattern(1, $var146[1]);
        }, [tpenv, names, takenNames]];

      case 2:
        const patternInput = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(0), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, $var146[1]);
        TcRuntimeTypeTest(false, true, cenv_1, env.DisplayEnv, $var146[2], patternInput[0], ty);
        const $var147 = pat.tag === 15 ? [0, pat.data[1]] : pat.tag === 2 ? pat.data[0].tag === 15 ? [1, pat.data[1], pat.data[2], pat.data[4], pat.data[3]] : [2] : [2];

        switch ($var147[0]) {
          case 0:
            return [function (_arg6) {
              return new Pattern(13, [ty, patternInput[0], null, $var147[1]]);
            }, [patternInput[1], names, takenNames]];

          case 1:
            let patternInput_1;
            const topValData = null;
            patternInput_1 = TcPatBindingName(cenv_1, env, $var147[1], patternInput[0], $var147[2], $var147[4], topValData, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], names, takenNames);
            return [function (values) {
              return new Pattern(13, [ty, patternInput[0], patternInput_1[0](values), $var147[3]]);
            }, [patternInput[1], patternInput_1[1], patternInput_1[2]]];

          case 2:
            throw new Error("TcPat");
        }

      case 3:
        return error_1(new _Error(SR.tcOptionalArgsOnlyOnMembers(), $var146[1]));

      case 4:
        const patternInput_2 = TcPatBindingName(cenv_1, env, $var146[1], ty, $var146[2], $var146[5], topValInfo, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], names, takenNames);
        let patternInput_3;
        const topValInfo_2 = null;
        patternInput_3 = TcPat(warnOnUpper, cenv_1, env, topValInfo_2, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], tpenv, patternInput_2[1], patternInput_2[2], ty, $var146[4]);
        return [function (values_1) {
          return new Pattern(2, [patternInput_3[0](values_1), patternInput_2[0](values_1), $var146[3]]);
        }, patternInput_3[1]];

      case 5:
        const patternInput_4 = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, $var146[1]);
        UnifyTypes(cenv_1, env, $var146[2], ty, patternInput_4[0]);
        warnOnUpper = warnOnUpper;
        cenv_1 = cenv_1;
        env = env;
        topValInfo = topValInfo;
        vFlags_0 = vFlags[0];
        vFlags_1 = vFlags[1];
        vFlags_2 = vFlags[2];
        vFlags_3 = vFlags[3];
        vFlags_4 = vFlags[4];
        vFlags_5 = vFlags[5];
        tpenv = patternInput_4[1];
        names = names;
        takenNames = takenNames;
        ty = ty;
        pat = $var146[3];
        continue TcPat;

      case 6:
        return error_1(new _Error(SR.tcAttributesInvalidInPatterns(), $var146[1]));

      case 7:
        let patternInput_5;
        const topValInfo_3 = null;
        patternInput_5 = TcPat(warnOnUpper, cenv_1, env, topValInfo_3, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], tpenv, names, takenNames, ty, $var146[2]);
        const tpenv_1 = patternInput_5[1][0];
        const takenNames1 = patternInput_5[1][2];
        const names1 = patternInput_5[1][1];
        let patternInput_6;
        const topValInfo_4 = null;
        patternInput_6 = TcPat(warnOnUpper, cenv_1, env, topValInfo_4, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], tpenv_1, names, takenNames, ty, $var146[3]);
        const tpenv_2 = patternInput_6[1][0];
        const takenNames2 = patternInput_6[1][2];
        const names2 = patternInput_6[1][1];

        if (!takenNames1.Equals(takenNames2)) {
          error_1(new UnionPatternsBindDifferentNames($var146[1]));
        }

        iterate_1(function (_arg8, _arg7) {
          const matchValue = tryFind_1(_arg7.data[0].idText, names2);

          if (matchValue != null) {
            const ty2 = getValue(matchValue).data[2];
            UnifyTypes(cenv_1, env, $var146[1], _arg7.data[2], ty2);
          }
        }, names1);
        return [function (values_2) {
          return new Pattern(3, [ofArray([patternInput_5[0](values_2), patternInput_6[0](values_2.RightPath)]), $var146[1]]);
        }, [tpenv_2, names1, takenNames1]];

      case 8:
        let patternInput_7;
        const argtys = map_1(function (_arg9) {
          return ty;
        }, $var146[2]);
        patternInput_7 = TcPatterns(warnOnUpper, cenv_1, env, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], tpenv, names, takenNames, argtys, $var146[2]);
        return [function (values_3) {
          return new Pattern(4, [map_1(function (f) {
            return f(values_3);
          }, patternInput_7[0]), $var146[1]]);
        }, patternInput_7[1]];

      case 9:
        if ($var146[4] != null) {
          errorR(new _Error(SR.tcInvalidTypeArgumentUsage(), $var146[3]));
        }

        let warnOnUpperForId;
        const $var148 = $var146[1].tag === 0 ? $var146[1].data.tail == null ? [0] : [1] : [1];

        switch ($var148[0]) {
          case 0:
            warnOnUpperForId = warnOnUpper;
            break;

          case 1:
            warnOnUpperForId = new WarnOnUpperFlag(1);
            break;
        }

        const checkNoArgsForLiteral = function () {
          const nargs = ($var146[1].tag === 1 ? $var146[1].data[0].length : $var146[1].data.length) | 0;

          if (nargs !== 0) {
            error_1(new _Error(SR.tcLiteralDoesNotTakeArguments(), $var146[3]));
          }
        };

        const matchValue_1 = ResolvePatternLongIdent(cenv_1.tcSink, cenv_1.nameResolver, warnOnUpperForId, false, $var146[3], env.eAccessRights, env.eNameResEnv, TypeNameResolutionInfo.Default, $var146[2]);
        const $var149 = matchValue_1.tag === 6 ? [0] : matchValue_1.tag === 3 ? [1] : matchValue_1.tag === 1 ? [2, matchValue_1] : matchValue_1.tag === 4 ? [2, matchValue_1] : matchValue_1.tag === 7 ? [3] : matchValue_1.tag === 5 ? [4] : matchValue_1.tag === 0 ? [5] : [6];

        switch ($var149[0]) {
          case 0:
            const $var150 = $var146[1].tag === 1 ? $var146[1].data[0].tail == null ? [0] : [1] : $var146[1].data.tail == null ? [0] : [1];

            switch ($var150[0]) {
              case 0:
                const pat_2 = mkSynPatVar($var146[5], matchValue_1.data);
                warnOnUpper = warnOnUpperForId;
                cenv_1 = cenv_1;
                env = env;
                topValInfo = topValInfo;
                vFlags_0 = vFlags[0];
                vFlags_1 = vFlags[1];
                vFlags_2 = vFlags[2];
                vFlags_3 = vFlags[3];
                vFlags_4 = vFlags[4];
                vFlags_5 = vFlags[5];
                tpenv = tpenv;
                names = names;
                takenNames = takenNames;
                ty = ty;
                pat = pat_2;
                continue TcPat;

              case 1:
                return error_1(new UndefinedName(0, function (arg00) {
                  return SR.undefinedNamePatternDiscriminator(arg00);
                }, matchValue_1.data, function () {
                  return NoSuggestions();
                }));
            }

          case 1:
            const vref = matchValue_1.data.data[1];
            const idx = matchValue_1.data.data[2] | 0;
            const apinfo = matchValue_1.data.data[0];
            const args = $var146[1].tag === 0 ? $var146[1].data : error_1(new _Error(SR.tcNamedActivePattern(item_6(idx, apinfo.ActiveTags)), $var146[3]));
            const patternInput_8 = TcVal(true, cenv_1, env, tpenv, vref, null, null, $var146[3]);
            const vexp = MakeApplicableExprWithFlex(cenv_1, env, patternInput_8[1]);
            const vexpty = vexp.Type;
            let patternInput_10;

            if (args.tail == null) {
              patternInput_10 = [new List(), new SynPat(0, [new SynConst(0), $var146[3]])];
            } else {
              const patternInput_9 = stripFunTy(cenv_1.g, vexpty);

              if ((patternInput_9[0].length === args.length + 1 ? isOptionTy(cenv_1.g, patternInput_9[1]) : false) ? isUnitTy(cenv_1.g, destOptionTy(cenv_1.g, patternInput_9[1])) : false) {
                patternInput_10 = [args, new SynPat(0, [new SynConst(0), $var146[3]])];
              } else {
                patternInput_10 = List_1.frontAndBack(args);
              }
            }

            if (!(patternInput_10[0].tail == null) ? apinfo.ActiveTags.length !== 1 : false) {
              error_1(new _Error(SR.tcRequireActivePatternWithOneResult(), $var146[3]));
            }

            const convSynPatToSynExpr = function (x) {
              convSynPatToSynExpr: while (true) {
                const $var151 = x.tag === 19 ? [0, x.data[0]] : x.tag === 0 ? [1, x.data[0], x.data[1]] : x.tag === 2 ? x.data[0].tag === 1 ? x.data[3] == null ? [2, x.data[1]] : [10] : [10] : x.tag === 3 ? [3, x.data[1], x.data[2], x.data[0]] : x.tag === 7 ? x.data[4] == null ? [4, x.data[2], x.data[3], x.data[0].data[1], x.data[0], x.data[0].data[0], x.data[5]] : [10] : x.tag === 8 ? [5, x.data[0], x.data[1]] : x.tag === 10 ? [6, x.data[0]] : x.tag === 11 ? [7, x.data[1], x.data[0], x.data[2]] : x.tag === 16 ? [8, x.data[0]] : x.tag === 13 ? [9, x.data] : [10];

                switch ($var151[0]) {
                  case 0:
                    x = $var151[1];
                    continue convSynPatToSynExpr;

                  case 1:
                    return new SynExpr(2, [$var151[1], $var151[2]]);

                  case 2:
                    return new SynExpr(28, $var151[1]);

                  case 3:
                    return new SynExpr(3, [convSynPatToSynExpr($var151[3]), $var151[1], $var151[2]]);

                  case 4:
                    let args_1;

                    if ($var151[2].tag === 0) {
                      args_1 = $var151[2].data;
                    } else {
                      throw new Error("impossible: active patterns can be used only with SynConstructorArgs.Pats");
                    }

                    let e_1;

                    if ($var151[3].length === $var151[5].length) {
                      const e = new SynExpr(29, [false, new LongIdentWithDots(0, [$var151[5], List_1.take($var151[3].length - 1, $var151[3])]), null, $var151[6]]);
                      e_1 = new SynExpr(57, [e, unionRanges(e.Range, last($var151[3]))]);
                    } else {
                      e_1 = new SynExpr(29, [false, $var151[4], null, $var151[6]]);
                    }

                    return fold(function (f_1, x_1) {
                      return mkSynApp1(f_1, convSynPatToSynExpr(x_1), $var151[6]);
                    }, e_1, args_1);

                  case 5:
                    return new SynExpr(4, [map_1(convSynPatToSynExpr, $var151[1]), new List(), $var151[2]]);

                  case 6:
                    x = $var151[1];
                    continue convSynPatToSynExpr;

                  case 7:
                    return new SynExpr(6, [$var151[2], map_1(convSynPatToSynExpr, $var151[1]), $var151[3]]);

                  case 8:
                    return $var151[1];

                  case 9:
                    return new SynExpr(42, $var151[1]);

                  case 10:
                    return error_1(new _Error(SR.tcInvalidArgForParameterizedPattern(), x.Range));
                }
              }
            };

            const activePatArgsAsSynExprs = map_1(convSynPatToSynExpr, patternInput_10[0]);
            const activePatResTys = NewInferenceTypes(ActivePatternInfo_get_Names.bind(apinfo)());

            const activePatType = function (arg00_1, arg10, arg20, arg30) {
              return ActivePatternInfo_OverallType.bind(apinfo)(arg00_1, arg10, arg20, arg30);
            }(cenv_1.g, $var146[3], ty, activePatResTys);

            const delayed = map_1(function (arg) {
              return new DelayedItem(1, [1, arg, unionRanges(rangeOfLid($var146[2]), arg.Range)]);
            }, activePatArgsAsSynExprs);
            const patternInput_11 = PropagateThenTcDelayed(cenv_1, activePatType, env, tpenv, $var146[3], vexp, vexpty, 1, delayed);

            if (idx >= activePatResTys.length) {
              error_1(new _Error(SR.tcInvalidIndexIntoActivePatternArray(), $var146[3]));
            }

            const argty = item_6(idx, activePatResTys);
            let patternInput_12;
            const topValInfo_5 = null;
            patternInput_12 = TcPat(warnOnUpper, cenv_1, env, topValInfo_5, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], patternInput_11[1], names, takenNames, argty, patternInput_10[1]);
            const tpenv_3 = patternInput_12[1][0];
            const takenNames_1 = patternInput_12[1][2];
            const names_1 = patternInput_12[1][1];
            const activePatIdentity = activePatArgsAsSynExprs.tail == null ? [vref, patternInput_8[4]] : null;
            return [function (values_4) {
              CallNameResolutionSink(cenv_1.tcSink, rangeOfLid($var146[2]), env.NameEnv, matchValue_1, matchValue_1, emptyTyparInst, new ItemOccurence(4), env.DisplayEnv, env.eAccessRights);
              return new Pattern(5, [[patternInput_11[0], activePatResTys, activePatIdentity, idx, apinfo], patternInput_12[0](values_4), $var146[3]]);
            }, [tpenv_3, names_1, takenNames_1]];

          case 2:
            const patternInput_13 = ApplyUnionCaseOrExnTypesForPat($var146[3], cenv_1, env, ty, $var149[1]);
            const nargtys = patternInput_13[1].length | 0;
            let args_3;

            if ($var146[1].tag === 1) {
              const result = new Array(nargtys).fill(null);

              for (let forLoopVar of $var146[1].data[0]) {
                const matchValue_2 = tryFindIndex(function (id2) {
                  return forLoopVar[0].idText === id2.idText;
                }, patternInput_13[2]);

                if (matchValue_2 != null) {
                  const matchValue_3 = result[getValue(matchValue_2)];

                  if (matchValue_3 == null) {
                    result[getValue(matchValue_2)] = forLoopVar[1];
                    const argContainerOpt = $var149[1].tag === 1 ? new ArgumentContainer(2, $var149[1].data[0]) : $var149[1].tag === 4 ? new ArgumentContainer(1, $var149[1].data) : null;
                    const argItem = new Item(20, [item_6(getValue(matchValue_2), patternInput_13[2]), item_6(getValue(matchValue_2), patternInput_13[1]), argContainerOpt]);
                    CallNameResolutionSink(cenv_1.tcSink, forLoopVar[0].idRange, env.NameEnv, argItem, argItem, emptyTyparInst, new ItemOccurence(4), env.DisplayEnv, env.eAccessRights);
                  } else {
                    error_1(new _Error(SR.tcUnionCaseFieldCannotBeUsedMoreThanOnce(forLoopVar[0].idText), forLoopVar[0].idRange));
                  }
                } else {
                  let caseName;

                  if ($var149[1].tag === 1) {
                    caseName = $var149[1].data[0].Name;
                  } else if ($var149[1].tag === 4) {
                    caseName = $var149[1].data.DisplayName;
                  } else {
                    throw new Error("impossible");
                  }

                  error_1(new _Error(SR.tcUnionCaseConstructorDoesNotHaveFieldWithGivenName(caseName, forLoopVar[0].idText), forLoopVar[0].idRange));
                }
              }

              for (let i = 0; i <= nargtys - 1; i++) {
                if (result[i] == null) {
                  result[i] = new SynPat(1, $var146[1].data[1].MakeSynthetic());
                }
              }

              const args_2 = ofArray(result);

              if (result.length === 1) {
                args_3 = args_2;
              } else {
                args_3 = ofArray([new SynPat(8, [args_2, $var146[1].data[1]])]);
              }
            } else {
              args_3 = $var146[1].data;
            }

            let args_4;
            let $var152;

            if (args_3.tail != null) {
              const activePatternResult41473 = _SynPatErrorSkip_(args_3.head);

              if (activePatternResult41473.tag === 8) {
                if (args_3.tail.tail == null) {
                  if (nargtys > 1) {
                    $var152 = [1, activePatternResult41473.data[0]];
                  } else {
                    $var152 = [2];
                  }
                } else {
                  $var152 = [2];
                }
              } else if (activePatternResult41473.tag === 10) {
                const activePatternResult41474 = _SynPatErrorSkip_(activePatternResult41473.data[0]);

                if (activePatternResult41474.tag === 8) {
                  if (args_3.tail.tail == null) {
                    if (nargtys > 1) {
                      $var152 = [1, activePatternResult41474.data[0]];
                    } else {
                      $var152 = [2];
                    }
                  } else {
                    $var152 = [2];
                  }
                } else {
                  $var152 = [2];
                }
              } else {
                $var152 = [2];
              }
            } else {
              $var152 = [0];
            }

            switch ($var152[0]) {
              case 0:
                args_4 = new List();
                break;

              case 1:
                args_4 = $var152[1];
                break;

              case 2:
                let $var153;

                if (args_3.tail != null) {
                  const activePatternResult41471 = _SynPatErrorSkip_(args_3.head);

                  if (activePatternResult41471.tag === 1) {
                    if (args_3.tail.tail == null) {
                      $var153 = [0, activePatternResult41471];
                    } else if (nargtys === 0) {
                      $var153 = [2];
                    } else {
                      $var153 = [3];
                    }
                  } else if (activePatternResult41471.tag === 10) {
                    const activePatternResult41472 = _SynPatErrorSkip_(activePatternResult41471.data[0]);

                    if (activePatternResult41472.tag === 1) {
                      if (args_3.tail.tail == null) {
                        $var153 = [0, activePatternResult41472];
                      } else if (nargtys === 0) {
                        $var153 = [2];
                      } else {
                        $var153 = [3];
                      }
                    } else if (args_3.tail.tail == null) {
                      $var153 = [1, args_3.head];
                    } else if (nargtys === 0) {
                      $var153 = [2];
                    } else {
                      $var153 = [3];
                    }
                  } else if (args_3.tail.tail == null) {
                    $var153 = [1, args_3.head];
                  } else if (nargtys === 0) {
                    $var153 = [2];
                  } else {
                    $var153 = [3];
                  }
                } else if (nargtys === 0) {
                  $var153 = [2];
                } else {
                  $var153 = [3];
                }

                switch ($var153[0]) {
                  case 0:
                    args_4 = toList(Array.from(replicate(nargtys, $var153[1])));
                    break;

                  case 1:
                    args_4 = ofArray([$var153[1]]);
                    break;

                  case 2:
                    args_4 = error_1(new _Error(SR.tcUnionCaseDoesNotTakeArguments(), $var146[3]));
                    break;

                  case 3:
                    if (nargtys === 1) {
                      args_4 = error_1(new _Error(SR.tcUnionCaseRequiresOneArgument(), $var146[3]));
                    } else {
                      args_4 = error_1(new _Error(SR.tcUnionCaseExpectsTupledArguments(nargtys), $var146[3]));
                    }

                    break;
                }

                break;
            }

            UnionCaseOrExnCheck(env, nargtys, args_4.length, $var146[3]);
            const patternInput_14 = TcPatterns(warnOnUpper, cenv_1, env, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], tpenv, names, takenNames, patternInput_13[1], args_4);
            return [function (values_5) {
              CallNameResolutionSink(cenv_1.tcSink, rangeOfLid($var146[2]), env.NameEnv, $var149[1], $var149[1], emptyTyparInst, new ItemOccurence(4), env.DisplayEnv, env.eAccessRights);
              return patternInput_13[0]($var146[3], map_1(function (f_2) {
                return f_2(values_5);
              }, patternInput_14[0]));
            }, patternInput_14[1]];

          case 3:
            CheckILFieldInfoAccessible(cenv_1.g, cenv_1.amap, $var146[3], env.eAccessRights, matchValue_1.data);

            if (!matchValue_1.data.IsStatic) {
              errorR(new _Error(SR.tcFieldIsNotStatic(matchValue_1.data.FieldName), $var146[3]));
            }

            CheckILFieldAttributes(cenv_1.g, matchValue_1.data, $var146[3]);
            const matchValue_4 = matchValue_1.data.LiteralValue;

            if (matchValue_4 != null) {
              checkNoArgsForLiteral();
              UnifyTypes(cenv_1, env, $var146[3], ty, matchValue_1.data.FieldType(cenv_1.amap, $var146[3]));
              const c__1 = TcFieldInit($var146[3], getValue(matchValue_4));
              const item = new Item(7, matchValue_1.data);
              CallNameResolutionSink(cenv_1.tcSink, $var146[3], env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(4), env.DisplayEnv, env.AccessRights);
              return [function (_arg10) {
                return new Pattern(0, [c__1, $var146[3]]);
              }, [tpenv, names, takenNames]];
            } else {
              return error_1(new _Error(SR.tcFieldNotLiteralCannotBeUsedInPattern(), $var146[3]));
            }

          case 4:
            CheckRecdFieldInfoAccessible(cenv_1.amap, $var146[3], env.eAccessRights, matchValue_1.data);

            if (!matchValue_1.data.IsStatic) {
              errorR(new _Error(SR.tcFieldIsNotStatic(matchValue_1.data.Name), $var146[3]));
            }

            CommitOperationResult(CheckRecdFieldInfoAttributes(cenv_1.g, matchValue_1.data, $var146[3]));
            const matchValue_5 = matchValue_1.data.LiteralValue;

            if (matchValue_5 != null) {
              checkNoArgsForLiteral();
              UnifyTypes(cenv_1, env, $var146[3], ty, matchValue_1.data.FieldType);
              const item_1 = new Item(5, matchValue_1.data);
              CallNameResolutionSink(cenv_1.tcSink, $var146[3], env.NameEnv, item_1, item_1, emptyTyparInst, new ItemOccurence(4), env.DisplayEnv, env.AccessRights);
              return [function (_arg11) {
                return new Pattern(0, [getValue(matchValue_5), $var146[3]]);
              }, [tpenv, names, takenNames]];
            } else {
              return error_1(new _Error(SR.tcFieldNotLiteralCannotBeUsedInPattern(), $var146[3]));
            }

          case 5:
            const matchValue_6 = matchValue_1.data.LiteralValue;

            if (matchValue_6 != null) {
              const patternInput_15 = TcVal(true, cenv_1, env, tpenv, matchValue_1.data, null, null, $var146[3]);
              CheckValAccessible($var146[3], env.eAccessRights, matchValue_1.data);
              CommitOperationResult(CheckFSharpAttributes(cenv_1.g, matchValue_1.data.Attribs, $var146[3]));
              checkNoArgsForLiteral();
              UnifyTypes(cenv_1, env, $var146[3], ty, patternInput_15[3]);
              const item_2 = new Item(0, matchValue_1.data);
              CallNameResolutionSink(cenv_1.tcSink, $var146[3], env.NameEnv, item_2, item_2, emptyTyparInst, new ItemOccurence(4), env.DisplayEnv, env.AccessRights);
              return [function (_arg12) {
                return new Pattern(0, [getValue(matchValue_6), $var146[3]]);
              }, [tpenv, names, takenNames]];
            } else {
              return error_1(new _Error(SR.tcNonLiteralCannotBeUsedInPattern(), $var146[3]));
            }

          case 6:
            return error_1(new _Error(SR.tcRequireVarConstRecogOrLiteral(), $var146[3]));
        }

      case 10:
        return error_1(new _Error(SR.tcInvalidPattern(), $var146[1]));

      case 11:
        const argtys_1 = NewInferenceTypes($var146[1]);
        UnifyTypes(cenv_1, env, $var146[2], ty, new TType(2, [tupInfoRef, argtys_1]));
        const patternInput_16 = TcPatterns(warnOnUpper, cenv_1, env, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], tpenv, names, takenNames, argtys_1, $var146[1]);
        return [function (values_6) {
          return new Pattern(8, [tupInfoRef, map_1(function (f_3) {
            return f_3(values_6);
          }, patternInput_16[0]), argtys_1, $var146[2]]);
        }, patternInput_16[1]];

      case 12:
        const argtys_2 = NewInferenceTypes($var146[1]);
        UnifyTypes(cenv_1, env, $var146[2], ty, new TType(2, [tupInfoStruct, argtys_2]));
        const patternInput_17 = TcPatterns(warnOnUpper, cenv_1, env, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], tpenv, names, takenNames, argtys_2, $var146[1]);
        return [function (values_7) {
          return new Pattern(8, [tupInfoStruct, map_1(function (f_4) {
            return f_4(values_7);
          }, patternInput_17[0]), argtys_2, $var146[2]]);
        }, patternInput_17[1]];

      case 13:
        const topValInfo_6 = null;
        warnOnUpper = warnOnUpper;
        cenv_1 = cenv_1;
        env = env;
        topValInfo = topValInfo_6;
        vFlags_0 = vFlags[0];
        vFlags_1 = vFlags[1];
        vFlags_2 = vFlags[2];
        vFlags_3 = vFlags[3];
        vFlags_4 = vFlags[4];
        vFlags_5 = vFlags[5];
        tpenv = tpenv;
        names = names;
        takenNames = takenNames;
        ty = ty;
        pat = $var146[1];
        continue TcPat;

      case 14:
        const argty_1 = NewInferenceType();
        UnifyTypes(cenv_1, env, $var146[3], ty, $var146[2] ? mkArrayType(cenv_1.g, argty_1) : mkListTy(cenv_1.g, argty_1));
        let patternInput_18;
        const argtys_3 = map_1(function (_arg13) {
          return argty_1;
        }, $var146[1]);
        patternInput_18 = TcPatterns(warnOnUpper, cenv_1, env, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], tpenv, names, takenNames, argtys_3, $var146[1]);
        return [function (values_8) {
          const args_ = map_1(function (f_5) {
            return f_5(values_8);
          }, patternInput_18[0]);

          if ($var146[2]) {
            return new Pattern(9, [args_, argty_1, $var146[3]]);
          } else {
            return foldBack(function (ph, pt) {
              return mkConsListPat(cenv_1.g, argty_1, ph, pt);
            }, args_, mkNilListPat(cenv_1.g, $var146[3], argty_1));
          }
        }, patternInput_18[1]];

      case 15:
        const patternInput_19 = BuildFieldMap(cenv_1, env, true, ty, $var146[1], $var146[2]);
        const patternInput_20 = infoOfTyconRef($var146[2], patternInput_19[0]);
        UnifyTypes(cenv_1, env, $var146[2], ty, patternInput_20[3]);
        const fields = patternInput_19[0].TrueInstanceFieldsAsList;
        const ftys = map_1(function (fsp) {
          return [actualTyOfRecdField(patternInput_20[1], fsp), fsp];
        }, fields);
        const patternInput_21 = mapFold(function (s, tupledArg) {
          const matchValue_7 = tryFind_1(tupledArg[1].rfield_id.idText, patternInput_19[1]);

          if (matchValue_7 == null) {
            return [function (_arg14) {
              return new Pattern(1, $var146[2]);
            }, s];
          } else {
            const topValInfo_7 = null;
            return TcPat(warnOnUpper, cenv_1, env, topValInfo_7, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], s[0], s[1], s[2], tupledArg[0], getValue(matchValue_7));
          }
        }, [tpenv, names, takenNames], ftys, ofArray);
        return [function (values_9) {
          return new Pattern(10, [patternInput_19[0], patternInput_20[2], map_1(function (f_6) {
            return f_6(values_9);
          }, patternInput_21[0]), $var146[2]]);
        }, patternInput_21[1]];

      case 16:
        errorR(new Deprecated(SR.tcUseWhenPatternGuard(), $var146[3]));
        UnifyTypes(cenv_1, env, $var146[3], ty, cenv_1.g.char_ty);
        return [function (_arg15) {
          return new Pattern(11, [$var146[1], $var146[2], $var146[3]]);
        }, [tpenv, names, takenNames]];

      case 17:
        AddCxTypeMustSupportNull(env.DisplayEnv, cenv_1.css, $var146[1], new OptionalTrace(0), ty);
        return [function (_arg16) {
          return new Pattern(12, $var146[1]);
        }, [tpenv, names, takenNames]];

      case 18:
        errorR(new _Error(SR.tcIllegalPattern(), pat.Range));
        return [function (_arg17) {
          return new Pattern(1, $var146[1]);
        }, [tpenv, names, takenNames]];

      case 19:
        return suppressErrorReporting(function () {
          const ty_1 = NewErrorType();
          return TcPatAndRecover(warnOnUpper, cenv_1, env, topValInfo, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], tpenv, names, takenNames, ty_1, $var146[1]);
        });
    }
  }
}
export function TcPatterns(warnOnUpper, cenv_1, env, vFlags_0, vFlags_1, vFlags_2, vFlags_3, vFlags_4, vFlags_5, s_0, s_1, s_2, argtys, args) {
  const vFlags = [vFlags_0, vFlags_1, vFlags_2, vFlags_3, vFlags_4, vFlags_5];
  const s = [s_0, s_1, s_2];
  return mapFold(function (s_3, tupledArg) {
    const topValInfo = null;
    return TcPat(warnOnUpper, cenv_1, env, topValInfo, vFlags[0], vFlags[1], vFlags[2], vFlags[3], vFlags[4], vFlags[5], s_3[0], s_3[1], s_3[2], tupledArg[0], tupledArg[1]);
  }, s, toList(zip(argtys, args)), ofArray);
}
export function solveTypAsError(cenv_1, denv, m, ty) {
  const ty2 = NewErrorType();
  SolveTypEqualsTypKeepAbbrevs(MakeConstraintSolverEnv(new ContextInfo(0), cenv_1.css, m, denv), 0, m, new OptionalTrace(0), ty, ty2);
}
export function RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects(cenv_1, env, tpenv, expr) {
  suppressErrorReporting(function () {
    try {
      TcExprOfUnknownType(cenv_1, env, tpenv, expr);
    } catch (e) {}
  });
}
export function RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects_Delayed(cenv_1, env, tpenv, delayed) {
  const dummyCheckedDelayed = function (delayed_1) {
    const $var154 = delayed_1.tail != null ? delayed_1.head.tag === 1 ? [0, delayed_1.head.data[0], delayed_1.head.data[2], delayed_1.head.data[1], delayed_1.tail] : [1] : [1];

    switch ($var154[0]) {
      case 0:
        RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects(cenv_1, env, tpenv, $var154[3]);
        dummyCheckedDelayed($var154[4]);
        break;

      case 1:
        break;
    }
  };

  dummyCheckedDelayed(delayed);
}
export function UnifyTypesAndRecover(cenv_1, env, m, expectedTy, actualTy) {
  try {
    UnifyTypes(cenv_1, env, m, expectedTy, actualTy);
  } catch (e) {
    errorRecovery(e, m);
  }
}
export function TcExprOfUnknownType(cenv_1, env, tpenv, expr) {
  const exprty = NewInferenceType();
  const patternInput = TcExpr(cenv_1, exprty, env, tpenv, expr);
  return [patternInput[0], exprty, patternInput[1]];
}
export function TcExprFlex(cenv_1, flex, ty, env, tpenv, e) {
  if (flex) {
    const argty = NewInferenceType();
    AddCxTypeMustSubsumeType(new ContextInfo(0), env.DisplayEnv, cenv_1.css, e.Range, new OptionalTrace(0), ty, argty);
    const patternInput = TcExpr(cenv_1, argty, env, tpenv, e);
    const e_ = mkCoerceIfNeeded(cenv_1.g, ty, argty, patternInput[0]);
    return [e_, patternInput[1]];
  } else {
    return TcExpr(cenv_1, ty, env, tpenv, e);
  }
}
export function TcExpr(cenv_1, ty, env, tpenv, expr) {
  try {
    return TcExprNoRecover(cenv_1, ty, env, tpenv, expr);
  } catch (e) {
    const m = expr.Range;
    errorRecovery(e, m);
    solveTypAsError(cenv_1, env.DisplayEnv, m, ty);
    return [mkThrow(m, ty, mkOne(cenv_1.g, m)), tpenv];
  }
}
export function TcExprNoRecover(cenv_1, ty, env, tpenv, expr) {
  const env_1 = GetCtorShapeCounter(env) > 0 ? AdjustCtorShapeCounter(function (x) {
    return x - 1;
  }, env) : env;
  return TcExprThen(cenv_1, ty, env_1, tpenv, expr, new List());
}
export function TcExprOfUnknownTypeThen(cenv_1, env, tpenv, expr, delayed) {
  const exprty = NewInferenceType();
  let patternInput;

  try {
    patternInput = TcExprThen(cenv_1, exprty, env, tpenv, expr, delayed);
  } catch (e) {
    const m = expr.Range;
    errorRecovery(e, m);
    solveTypAsError(cenv_1, env.DisplayEnv, m, exprty);
    patternInput = [mkThrow(m, exprty, mkOne(cenv_1.g, m)), tpenv];
  }

  return [patternInput[0], exprty, patternInput[1]];
}
export function TcExprThatIsCtorBody(safeInitInfo_0, safeInitInfo_1, cenv_1, overallTy, env, tpenv, expr) {
  const safeInitInfo = [safeInitInfo_0, safeInitInfo_1];
  let env_1;
  const eCtorInfo = InitialExplicitCtorInfo(safeInitInfo[0], safeInitInfo[1]);
  env_1 = new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, eCtorInfo, env.eCallerMemberName);
  const patternInput = TcExpr(cenv_1, overallTy, env_1, tpenv, expr);
  const expr_1 = CheckAndRewriteObjectCtor(cenv_1.g, env_1, patternInput[0]);
  return [expr_1, patternInput[1]];
}
export function TcExprThatCanBeCtorBody(cenv_1, overallTy, env, tpenv, expr) {
  const env_1 = AreWithinCtorShape(env) ? AdjustCtorShapeCounter(function (x) {
    return x + 1;
  }, env) : env;
  return TcExpr(cenv_1, overallTy, env_1, tpenv, expr);
}
export function TcExprThatCantBeCtorBody(cenv_1, overallTy, env, tpenv, expr) {
  const env_1 = AreWithinCtorShape(env) ? ExitCtorShapeRegion(env) : env;
  return TcExpr(cenv_1, overallTy, env_1, tpenv, expr);
}
export function TcStmtThatCantBeCtorBody(cenv_1, env, tpenv, expr) {
  const env_1 = AreWithinCtorShape(env) ? ExitCtorShapeRegion(env) : env;
  return TcStmt(cenv_1, env_1, tpenv, expr);
}
export function TcStmt(cenv_1, env, tpenv, synExpr) {
  const patternInput = TcExprOfUnknownType(cenv_1, env, tpenv, synExpr);
  const m = synExpr.Range;
  const wasUnit = UnifyUnitType(cenv_1, env, m, patternInput[1], patternInput[0]);

  if (wasUnit) {
    return [patternInput[0], patternInput[2]];
  } else {
    return [mkCompGenSequential(m, patternInput[0], mkUnit(cenv_1.g, m)), patternInput[2]];
  }
}
export function TcExprThen(cenv_1, overallTy, env, tpenv, synExpr, delayed) {
  TcExprThen: while (true) {
    const activePatternResult41596 = _LongOrSingleIdent___(synExpr);

    if (activePatternResult41596 != null) {
      if (getValue(activePatternResult41596)[0]) {
        errorR(new _Error(SR.tcSyntaxErrorUnexpectedQMark(), getValue(activePatternResult41596)[3]));
      }

      const $var155 = getValue(activePatternResult41596)[2] != null ? getValue(getValue(activePatternResult41596)[2]).contents.tag === 1 ? [0, getValue(getValue(activePatternResult41596)[2]).contents.data] : [1] : [1];

      switch ($var155[0]) {
        case 0:
          cenv_1 = cenv_1;
          overallTy = overallTy;
          env = env;
          tpenv = tpenv;
          synExpr = new SynExpr(29, [getValue(activePatternResult41596)[0], new LongIdentWithDots(0, [ofArray([$var155[1]]), new List()]), null, getValue(activePatternResult41596)[3]]);
          delayed = delayed;
          continue TcExprThen;

        case 1:
          return TcLongIdentThen(cenv_1, overallTy, env, tpenv, getValue(activePatternResult41596)[1], delayed);
      }
    } else {
      switch (synExpr.tag) {
        case 20:
          cenv_1 = cenv_1;
          overallTy = overallTy;
          env = env;
          tpenv = tpenv;
          const $var558 = synExpr.data[2];
          delayed = new List(new DelayedItem(1, [synExpr.data[0], synExpr.data[3], synExpr.data[4]]), delayed);
          synExpr = $var558;
          continue TcExprThen;

        case 21:
          cenv_1 = cenv_1;
          overallTy = overallTy;
          env = env;
          tpenv = tpenv;
          const $var559 = synExpr.data[0];
          delayed = new List(new DelayedItem(0, [synExpr.data[2], synExpr.data[5], synExpr.data[6]]), delayed);
          synExpr = $var559;
          continue TcExprThen;

        case 31:
          const longId = synExpr.data[2].data[0];
          cenv_1 = cenv_1;
          overallTy = overallTy;
          env = env;
          tpenv = tpenv;
          const $var560 = synExpr.data[0];
          delayed = new List(new DelayedItem(2, [longId, synExpr.RangeSansAnyExtraDot]), delayed);
          synExpr = $var560;
          continue TcExprThen;

        case 33:
          return TcIndexerThen(cenv_1, env, overallTy, synExpr.data[3], synExpr.data[2], tpenv, synExpr, synExpr.data[0], synExpr.data[1], delayed);

        case 34:
          return TcIndexerThen(cenv_1, env, overallTy, synExpr.data[5], synExpr.data[4], tpenv, synExpr, synExpr.data[0], synExpr.data[1], delayed);

        default:
          if (delayed.tail == null) {
            return TcExprUndelayed(cenv_1, overallTy, env, tpenv, synExpr);
          } else {
            const patternInput = TcExprUndelayedNoType(cenv_1, env, tpenv, synExpr);
            return PropagateThenTcDelayed(cenv_1, overallTy, env, patternInput[2], synExpr.Range, MakeApplicableExprNoFlex(cenv_1, patternInput[0]), patternInput[1], 1, delayed);
          }

      }
    }
  }
}
export function TcExprs(cenv_1, env, m, tpenv, flexes, argtys, args) {
  if (args.length !== argtys.length) {
    error_1(new _Error(SR.tcExpressionCountMisMatch(argtys.length, args.length), m));
  }

  return mapFold(function (tpenv_1, tupledArg) {
    return TcExprFlex(cenv_1, tupledArg[0], tupledArg[1], env, tpenv_1, tupledArg[2]);
  }, tpenv, toList(zip3(flexes, argtys, args)), ofArray);
}
export function CheckSuperInit(cenv_1, objTy, m) {
  const matchValue = tryDestAppTy(cenv_1.g, objTy);
  const $var156 = matchValue != null ? isAbstractTycon(getValue(matchValue).Deref) ? [0, getValue(matchValue)] : [1] : [1];

  switch ($var156[0]) {
    case 0:
      errorR(new _Error(SR.tcAbstractTypeCannotBeInstantiated(), m));
      break;

    case 1:
      break;
  }
}
export function TcExprUndelayedNoType(cenv_1, env, tpenv, expr) {
  const exprty = NewInferenceType();
  const patternInput = TcExprUndelayed(cenv_1, exprty, env, tpenv, expr);
  return [patternInput[0], exprty, patternInput[1]];
}
export function TcExprUndelayed(cenv_1, overallTy, env, tpenv, expr) {
  var isTrueYield;
  var isTrueYield_1;
  var isTrueReturn;
  var isTrueReturn_1;

  TcExprUndelayed: while (true) {
    const $var157 = expr.tag === 0 ? [0, expr.data[0], expr.data[3]] : expr.tag === 33 ? [1] : expr.tag === 34 ? [1] : expr.tag === 21 ? [1] : expr.tag === 28 ? [1] : expr.tag === 29 ? [1] : expr.tag === 20 ? [1] : expr.tag === 31 ? [1] : expr.tag === 2 ? expr.data[0].tag === 17 ? [2, expr.data[0].data[1], expr.data[0].data[0]] : [3, expr.data[0], expr.data[1]] : expr.tag === 15 ? [4] : expr.tag === 17 ? [5, expr.data[4], expr.data[3], expr.data[2], expr.data[0], expr.data[1]] : expr.tag === 16 ? [6, expr.data[1], expr.data[2], expr.data[0], expr.data[4], expr.data[3]] : expr.tag === 19 ? [7, expr.data[1], expr.data[0]] : expr.tag === 58 ? [8, expr.data[1]] : expr.tag === 3 ? [9, expr.data[1], expr.data[0], expr.data[2]] : expr.tag === 37 ? [10, expr.data[0], expr.data[2], expr.data[1]] : expr.tag === 43 ? [11, expr.data[0], expr.data[1], expr.data[3], expr.data[2]] : expr.tag === 38 ? [12, expr.data[0], expr.data[2]] : expr.tag === 40 ? [12, expr.data[0], expr.data[1]] : expr.tag === 39 ? [13, expr.data[0], expr.data[2]] : expr.tag === 41 ? [13, expr.data[0], expr.data[1]] : expr.tag === 42 ? [14, expr.data] : expr.tag === 25 ? [15, expr.data[0], expr.data[1]] : expr.tag === 4 ? [16, expr.data[0], expr.data[2]] : expr.tag === 5 ? [17, expr.data[0], expr.data[2]] : expr.tag === 6 ? [18, expr.data[1], expr.data[0], expr.data[2]] : expr.tag === 8 ? [19, expr.data[2], expr.data[3], expr.data[0], expr.data[1]] : expr.tag === 9 ? [20, expr.data[1], expr.data[2], expr.data[3], expr.data[5], expr.data[4], expr.data[0]] : expr.tag === 7 ? [21, expr.data[2], expr.data[0], expr.data[3], expr.data[1]] : expr.tag === 10 ? [22, expr.data[1], expr.data[2], expr.data[3], expr.data[0]] : expr.tag === 11 ? [23, expr.data[5], expr.data[3], expr.data[4], expr.data[1], expr.data[6], expr.data[0], expr.data[2]] : expr.tag === 12 ? [24, expr.data[5], expr.data[4], expr.data[2], expr.data[6], expr.data[3], expr.data[1].data, expr.data[0]] : expr.tag === 14 ? [25, expr.data[2], expr.data[0], expr.data[1], expr.data[3]] : expr.tag === 13 ? [26, expr.data[1], expr.data[0], expr.data[2]] : expr.tag === 22 ? [27] : expr.tag === 23 ? [28, expr.data[1], expr.data[2], expr.data[0], expr.data[4], expr.data[3], expr.data[5], expr.data[6]] : expr.tag === 24 ? [29, expr.data[0], expr.data[1], expr.data[2], expr.data[4], expr.data[3]] : expr.tag === 45 ? [30, expr.data[0], expr.data[2], expr.data[3], expr.data[1]] : expr.tag === 55 ? [31, expr.data[0], expr.data[1]] : expr.tag === 57 ? [32, expr.data[0], expr.data[1]] : expr.tag === 56 ? [33, expr.data[0], expr.data[1]] : expr.tag === 26 ? [34, expr.data[1], expr.data[2], expr.data[3], expr.data[4], expr.data[0]] : expr.tag === 18 ? [35, expr.data[0], expr.data[1]] : expr.tag === 27 ? [36, expr.data[0], expr.data[1], expr.data[2], expr.data[4], expr.data[6], expr.data[5], expr.data[3]] : expr.tag === 52 ? [37, expr.data[0], expr.data[1], expr.data[2], expr.data[3]] : expr.tag === 32 ? [38, expr.data[0], expr.data[2], expr.data[1], expr.data[1].data[0], expr.data[3]] : expr.tag === 36 ? [39, expr.data[0], expr.data[2], expr.data[3], expr.data[1], expr.data[1].data[0], expr.data[4]] : expr.tag === 30 ? [40, expr.data[1], expr.data[0], expr.data[2]] : expr.tag === 35 ? [41, expr.data[1], expr.data[2], expr.data[0], expr.data[3]] : expr.tag === 44 ? [42, expr.data[2], expr.data[3], expr.data[1], expr.data[0]] : expr.tag === 53 ? [43, expr.data[1], expr.data[0], expr.data[3], expr.data[2]] : expr.tag === 54 ? [44, expr.data[1], expr.data[0], expr.data[3], expr.data[4], expr.data[2]] : expr.tag === 51 ? [45, expr.data[2], expr.data[4], expr.data[3], expr.data[0], expr.data[1]] : expr.tag === 1 ? [46, expr.data[2], expr.data[3], expr.data[4], expr.data[0], expr.data[1]] : expr.tag === 47 ? (isTrueYield = expr.data[0][0], isTrueYield) ? [47, expr.data[0][0], expr.data[2]] : [48] : expr.tag === 48 ? (isTrueYield_1 = expr.data[0][0], isTrueYield_1) ? [47, expr.data[0][0], expr.data[2]] : [48] : [48];

    switch ($var157[0]) {
      case 0:
        CallExprHasTypeSink(cenv_1.tcSink, $var157[2], env.NameEnv, overallTy, env.DisplayEnv, env.eAccessRights);
        const env_1 = ShrinkContext(env, $var157[2], $var157[1].Range);
        return TcExpr(cenv_1, overallTy, env_1, tpenv, $var157[1]);

      case 1:
        return error_1(new _Error(SR.tcExprUndelayed(), expr.Range));

      case 2:
        CallExprHasTypeSink(cenv_1.tcSink, $var157[1], env.NameEnv, overallTy, env.DisplayEnv, env.eAccessRights);
        return TcConstStringExpr(cenv_1, overallTy, env, $var157[1], tpenv, $var157[2]);

      case 3:
        CallExprHasTypeSink(cenv_1.tcSink, $var157[2], env.NameEnv, overallTy, env.DisplayEnv, env.eAccessRights);
        return TcConstExpr(cenv_1, overallTy, env, $var157[2], tpenv, $var157[1]);

      case 4:
        return TcIteratedLambdas(cenv_1, true, env, overallTy, create_1(null, new Comparer(comparePrimitives)), tpenv, expr);

      case 5:
        const patternInput = TcExprOfUnknownType(cenv_1, env, tpenv, $var157[5]);
        const mExpr = Expr_get_Range.bind(patternInput[0])();
        const patternInput_1 = TcAndPatternCompileMatchClauses(mExpr, mExpr, $var157[2] ? new ActionOnFailure(2) : new ActionOnFailure(0), cenv_1, patternInput[1], overallTy, env, patternInput[2], $var157[3]);
        return [mkLet($var157[4], mExpr, patternInput_1[0], patternInput[0], patternInput_1[1]), patternInput_1[2]];

      case 6:
        const patternInput_2 = UnifyFunctionType(null, cenv_1, env.DisplayEnv, $var157[4], overallTy);
        const patternInput_3 = mkCompGenLocal($var157[1], cenv_1.synArgNameGenerator.New(), patternInput_2[0]);
        const envinner = ExitFamilyRegion(env);
        const patternInput_4 = TcAndPatternCompileMatchClauses($var157[4], $var157[1], $var157[3] ? new ActionOnFailure(2) : new ActionOnFailure(0), cenv_1, patternInput_2[0], patternInput_2[1], envinner, tpenv, $var157[2]);
        const overallExpr = mkMultiLambda($var157[4], ofArray([patternInput_3[0]]), mkLet($var157[5], $var157[4], patternInput_4[0], patternInput_3[1], patternInput_4[1]), patternInput_2[1]);
        return [overallExpr, patternInput_4[2]];

      case 7:
        return TcAssertExpr(cenv_1, overallTy, env, $var157[1], tpenv, $var157[2]);

      case 8:
        return error_1(new _Error(SR.tcFixedNotAllowed(), $var157[1]));

      case 9:
        const patternInput_5 = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, $var157[1]);
        UnifyTypes(cenv_1, env, $var157[3], overallTy, patternInput_5[0]);
        const patternInput_6 = TcExpr(cenv_1, overallTy, env, patternInput_5[1], $var157[2]);
        return [patternInput_6[0], patternInput_6[1]];

      case 10:
        const patternInput_7 = TcExprOfUnknownType(cenv_1, env, tpenv, $var157[1]);
        UnifyTypes(cenv_1, env, $var157[2], overallTy, cenv_1.g.bool_ty);
        const patternInput_8 = TcType(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, patternInput_7[2], $var157[3]);
        TcRuntimeTypeTest(false, true, cenv_1, env.DisplayEnv, $var157[2], patternInput_8[0], patternInput_7[1]);
        const e_ = mkCallTypeTest(cenv_1.g, $var157[2], patternInput_8[0], patternInput_7[0]);
        return [e_, patternInput_8[1]];

      case 11:
        return TcExpr(cenv_1, overallTy, env, tpenv, mkSynPrefix($var157[4], $var157[3], $var157[1] ? "~&" : "~&&", $var157[2]));

      case 12:
        const patternInput_9 = TcExprOfUnknownType(cenv_1, env, tpenv, $var157[1]);
        let patternInput_11;

        if (expr.tag === 38) {
          const patternInput_10 = TcType(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, patternInput_9[2], expr.data[1]);
          UnifyTypes(cenv_1, env, expr.data[2], patternInput_10[0], overallTy);
          patternInput_11 = [patternInput_10[0], patternInput_10[1]];
        } else if (expr.tag === 40) {
          patternInput_11 = [overallTy, patternInput_9[2]];
        } else {
          throw new Error("upcast");
        }

        TcStaticUpcast(cenv_1, env.DisplayEnv, $var157[2], patternInput_11[0], patternInput_9[1]);
        return [mkCoerceExpr(patternInput_9[0], patternInput_11[0], $var157[2], patternInput_9[1]), patternInput_11[1]];

      case 13:
        const patternInput_12 = TcExprOfUnknownType(cenv_1, env, tpenv, $var157[1]);
        let patternInput_14;

        if (expr.tag === 39) {
          const patternInput_13 = TcType(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, patternInput_12[2], expr.data[1]);
          UnifyTypes(cenv_1, env, expr.data[2], patternInput_13[0], overallTy);
          patternInput_14 = [patternInput_13[0], patternInput_13[1], true];
        } else if (expr.tag === 41) {
          patternInput_14 = [overallTy, patternInput_12[2], false];
        } else {
          throw new Error("downcast");
        }

        TcRuntimeTypeTest(true, patternInput_14[2], cenv_1, env.DisplayEnv, $var157[2], patternInput_14[0], patternInput_12[1]);
        const e__1 = mkCallUnbox(cenv_1.g, $var157[2], patternInput_14[0], patternInput_12[0]);
        return [e__1, patternInput_14[1]];

      case 14:
        AddCxTypeMustSupportNull(env.DisplayEnv, cenv_1.css, $var157[1], new OptionalTrace(0), overallTy);
        return [mkNull($var157[1], overallTy), tpenv];

      case 15:
        const ety = NewInferenceType();
        UnifyTypes(cenv_1, env, $var157[2], overallTy, mkLazyTy(cenv_1.g, ety));
        const patternInput_15 = TcExpr(cenv_1, ety, env, tpenv, $var157[1]);
        return [mkLazyDelayed(cenv_1.g, $var157[2], ety, mkUnitDelayLambda(cenv_1.g, $var157[2], patternInput_15[0])), patternInput_15[1]];

      case 16:
        const argtys = UnifyRefTupleType(env.eContextInfo, cenv_1, env.DisplayEnv, $var157[2], overallTy, $var157[1]);
        const flexes = map_1(function (_arg18) {
          return false;
        }, argtys);
        const patternInput_16 = TcExprs(cenv_1, env, $var157[2], tpenv, flexes, argtys, $var157[1]);
        return [mkRefTupled(cenv_1.g, $var157[2], patternInput_16[0], argtys), patternInput_16[1]];

      case 17:
        const argtys_1 = UnifyStructTupleType(env.eContextInfo, cenv_1, env.DisplayEnv, $var157[2], overallTy, $var157[1]);
        const flexes_1 = map_1(function (_arg19) {
          return false;
        }, argtys_1);
        const patternInput_17 = TcExprs(cenv_1, env, $var157[2], tpenv, flexes_1, argtys_1, $var157[1]);
        return [mkAnyTupled(cenv_1.g, $var157[2], tupInfoStruct, patternInput_17[0], argtys_1), patternInput_17[1]];

      case 18:
        CallExprHasTypeSink(cenv_1.tcSink, $var157[3], env.NameEnv, overallTy, env.DisplayEnv, env.eAccessRights);
        const argty = NewInferenceType();
        UnifyTypes(cenv_1, env, $var157[3], overallTy, $var157[2] ? mkArrayType(cenv_1.g, argty) : mkListTy(cenv_1.g, argty));
        const flex = !isTyparTy(cenv_1.g, argty);
        const first = {
          contents: true
        };

        const getInitEnv = function (m) {
          if (first.contents) {
            first.contents = false;
            return env;
          } else {
            const eContextInfo = new ContextInfo(6, [$var157[2], m]);
            return new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
          }
        };

        const patternInput_18 = mapFold(function (tpenv_1, x) {
          return TcExprFlex(cenv_1, flex, argty, getInitEnv(x.Range), tpenv_1, x);
        }, tpenv, $var157[1], ofArray);
        const expr_1 = $var157[2] ? new Expr(11, [new TOp(3), ofArray([argty]), patternInput_18[0], $var157[3]]) : foldBack(function (arg20_, arg30_) {
          return mkCons(cenv_1.g, argty, arg20_, arg30_);
        }, patternInput_18[0], mkNil(cenv_1.g, $var157[3], argty));
        return [expr_1, patternInput_18[1]];

      case 19:
        const patternInput_19 = TcType(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(1), env, tpenv, $var157[4]);
        UnifyTypes(cenv_1, env, $var157[2], overallTy, patternInput_19[0]);
        return TcNewExpr(cenv_1, env, patternInput_19[1], patternInput_19[0], $var157[4].Range, $var157[3], $var157[1], $var157[2]);

      case 20:
        CallExprHasTypeSink(cenv_1.tcSink, $var157[4], env.NameEnv, overallTy, env.DisplayEnv, env.eAccessRights);
        return TcObjectExpr(cenv_1, overallTy, env, tpenv, $var157[6], $var157[1], $var157[2], $var157[3], $var157[5], $var157[4]);

      case 21:
        CallExprHasTypeSink(cenv_1.tcSink, $var157[3], env.NameEnv, overallTy, env.DisplayEnv, env.eAccessRights);
        return TcRecdExpr(cenv_1, overallTy, env, tpenv, $var157[2], $var157[4], $var157[1], $var157[3]);

      case 22:
        UnifyTypes(cenv_1, env, $var157[3], overallTy, cenv_1.g.unit_ty);
        const patternInput_20 = TcExpr(cenv_1, cenv_1.g.bool_ty, env, tpenv, $var157[1]);
        const patternInput_21 = TcStmt(cenv_1, env, patternInput_20[1], $var157[2]);
        return [mkWhile(cenv_1.g, $var157[4], new SpecialWhileLoopMarker(0), patternInput_20[0], patternInput_21[0], $var157[3]), patternInput_21[1]];

      case 23:
        UnifyTypes(cenv_1, env, $var157[5], overallTy, cenv_1.g.unit_ty);
        const patternInput_22 = TcExpr(cenv_1, cenv_1.g.int_ty, env, tpenv, $var157[7]);
        const patternInput_23 = TcExpr(cenv_1, cenv_1.g.int_ty, env, patternInput_22[1], $var157[3]);
        const patternInput_24 = mkLocal($var157[4].idRange, $var157[4].idText, cenv_1.g.int_ty);
        const envinner_1 = AddLocalVal(cenv_1.tcSink, $var157[5], patternInput_24[0], env);
        const item = new Item(0, mkLocalValRef(patternInput_24[0]));
        CallNameResolutionSink(cenv_1.tcSink, patternInput_24[0].Range, env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(0), env.DisplayEnv, env.eAccessRights);
        const patternInput_25 = TcStmt(cenv_1, envinner_1, patternInput_23[1], $var157[1]);
        return [mkFastForLoop(cenv_1.g, $var157[6], $var157[5], patternInput_24[0], patternInput_22[0], $var157[2], patternInput_23[0], patternInput_25[0]), patternInput_25[1]];

      case 24:
        if ($var157[6]) {
          warning(new _Error(SR.tcExpressionRequiresSequence(), $var157[4]));
        }

        return TcForEachExpr(cenv_1, overallTy, env, tpenv, $var157[5], $var157[2], $var157[1], $var157[4], $var157[7]);

      case 25:
        const env_2 = ExitFamilyRegion(env);

        if (!$var157[2]) {
          if ($var157[1].tag === 8) {
            errorR(new _Error(SR.tcInvalidObjectExpressionSyntaxForm(), $var157[4]));
          } else {
            const activePatternResult41625 = _SimpleSemicolonSequence___(false, $var157[1]);

            if (activePatternResult41625 != null) {
              errorR(new _Error(SR.tcInvalidObjectSequenceOrRecordExpression(), $var157[4]));
            }
          }
        }

        if (!$var157[3].contents ? !cenv_1.g.compilingFslib : false) {
          error_1(new _Error(SR.tcInvalidSequenceExpressionSyntaxForm(), $var157[4]));
        }

        return TcComputationOrSequenceExpression(cenv_1, env_2, overallTy, $var157[4], null, tpenv, $var157[1]);

      case 26:
        CallExprHasTypeSink(cenv_1.tcSink, $var157[3], env.NameEnv, overallTy, env.DisplayEnv, env.eAccessRights);
        let $var158;

        if ($var157[1].tag === 14) {
          const activePatternResult41633 = _SimpleSemicolonSequence___(true, $var157[1].data[2]);

          if (activePatternResult41633 != null) {
            $var158 = [0, $var157[1].data[2], getValue(activePatternResult41633)];
          } else {
            $var158 = [1];
          }
        } else {
          $var158 = [1];
        }

        switch ($var158[0]) {
          case 0:
            const activePatternResult41627 = _SimpleSemicolonSequence___(false, $var158[1]);

            if (activePatternResult41627 != null) {} else {
              errorR(new Deprecated(SR.tcExpressionWithIfRequiresParenthesis(), $var157[3]));
            }

            let replacementExpr;

            if ($var157[2]) {
              const nelems = $var158[2].length | 0;

              if (nelems > 0 ? forAll(function (_arg13) {
                const $var159 = _arg13.tag === 2 ? _arg13.data[0].tag === 5 ? [0] : [1] : [1];

                switch ($var159[0]) {
                  case 0:
                    return true;

                  case 1:
                    return false;
                }
              }, $var158[2]) : false) {
                replacementExpr = new SynExpr(2, [new SynConst(19, Uint16Array.from(map_1(function (_arg14) {
                  const $var160 = _arg14.tag === 2 ? _arg14.data[0].tag === 5 ? [0, _arg14.data[0].data] : [1] : [1];

                  switch ($var160[0]) {
                    case 0:
                      return $var160[1];

                    case 1:
                      throw new Error("unreachable");
                  }
                }, $var158[2]))), $var157[3]]);
              } else if (nelems > 0 ? forAll(function (_arg15) {
                const $var161 = _arg15.tag === 2 ? _arg15.data[0].tag === 3 ? [0] : [1] : [1];

                switch ($var161[0]) {
                  case 0:
                    return true;

                  case 1:
                    return false;
                }
              }, $var158[2]) : false) {
                replacementExpr = new SynExpr(2, [new SynConst(18, [Uint8Array.from(map_1(function (_arg16) {
                  const $var162 = _arg16.tag === 2 ? _arg16.data[0].tag === 3 ? [0, _arg16.data[0].data] : [1] : [1];

                  switch ($var162[0]) {
                    case 0:
                      return $var162[1];

                    case 1:
                      throw new Error("unreachable");
                  }
                }, $var158[2])), $var157[3]]), $var157[3]]);
              } else {
                replacementExpr = new SynExpr(6, [$var157[2], $var158[2], $var157[3]]);
              }
            } else {
              if ($var158[2].length > 500) {
                error_1(new _Error(SR.tcListLiteralMaxSize(), $var157[3]));
              }

              replacementExpr = new SynExpr(6, [$var157[2], $var158[2], $var157[3]]);
            }

            cenv_1 = cenv_1;
            overallTy = overallTy;
            env = env;
            tpenv = tpenv;
            expr = replacementExpr;
            continue TcExprUndelayed;

          case 1:
            const genCollElemTy = NewInferenceType();
            const genCollTy = ($var157[2] ? function (arg00_, arg10_) {
              return mkArrayType(arg00_, arg10_);
            } : function (arg00__1, arg10__1) {
              return mkListTy(arg00__1, arg10__1);
            })(cenv_1.g, genCollElemTy);
            UnifyTypes(cenv_1, env, $var157[3], overallTy, genCollTy);
            const exprty = NewInferenceType();
            const genEnumTy = mkSeqTy(cenv_1.g, genCollElemTy);
            AddCxTypeMustSubsumeType(new ContextInfo(0), env.DisplayEnv, cenv_1.css, $var157[3], new OptionalTrace(0), genEnumTy, exprty);
            const patternInput_26 = TcExpr(cenv_1, exprty, env, tpenv, $var157[1]);
            const expr_2 = mkCoerceIfNeeded(cenv_1.g, genEnumTy, tyOfExpr(cenv_1.g, patternInput_26[0]), patternInput_26[0]);
            return [($var157[2] ? function (arg00__2, arg10__2, arg20__1, arg30__1) {
              return mkCallSeqToArray(arg00__2, arg10__2, arg20__1, arg30__1);
            } : function (arg00__3, arg10__3, arg20__2, arg30__2) {
              return mkCallSeqToList(arg00__3, arg10__3, arg20__2, arg30__2);
            })(cenv_1.g, $var157[3], genCollElemTy, (cenv_1.g.compilingFslib ? function (x_1) {
              return x_1;
            } : function (arg30__3) {
              return mkCallSeq(cenv_1.g, $var157[3], genCollElemTy, arg30__3);
            })(mkCoerceExpr(expr_2, genEnumTy, Expr_get_Range.bind(expr_2)(), exprty))), patternInput_26[1]];
        }

      case 27:
        return TcLinearExprs(function (overallTy_1, env_3, tpenv_2, expr_3) {
          return TcExprThatCanBeCtorBody(cenv_1, overallTy_1, env_3, tpenv_2, expr_3);
        }, cenv_1, env, overallTy, tpenv, false, expr, function (x_2) {
          return x_2;
        });

      case 28:
        const patternInput_27 = TcExpr(cenv_1, overallTy, env, tpenv, $var157[3]);
        const filterClauses = map_1(function (_arg17) {
          return new SynMatchClause(0, [_arg17.data[0], _arg17.data[1], new SynExpr(2, [new SynConst(6, 1), _arg17.data[3]]), _arg17.data[3], new SequencePointInfoForTarget(1)]);
        }, $var157[2]);
        const patternInput_28 = TcMatchClauses(cenv_1, cenv_1.g.exn_ty, cenv_1.g.int_ty, env, patternInput_27[1], filterClauses);
        const patternInput_29 = TcMatchClauses(cenv_1, cenv_1.g.exn_ty, overallTy, env, patternInput_28[1], $var157[2]);
        const patternInput_30 = CompilePatternForMatchClauses(cenv_1, env, $var157[5], $var157[5], true, new ActionOnFailure(4), cenv_1.g.exn_ty, cenv_1.g.int_ty, patternInput_28[0]);
        const patternInput_31 = CompilePatternForMatchClauses(cenv_1, env, $var157[5], $var157[5], true, new ActionOnFailure(3), cenv_1.g.exn_ty, overallTy, patternInput_29[0]);
        return [mkTryWith(cenv_1.g, patternInput_27[0], patternInput_30[0], patternInput_30[1], patternInput_31[0], patternInput_31[1], $var157[4], overallTy, $var157[6], $var157[7]), patternInput_29[1]];

      case 29:
        const patternInput_32 = TcExpr(cenv_1, overallTy, env, tpenv, $var157[1]);
        const patternInput_33 = TcStmt(cenv_1, env, patternInput_32[1], $var157[2]);
        return [mkTryFinally(cenv_1.g, patternInput_32[0], patternInput_33[0], $var157[3], overallTy, $var157[5], $var157[4]), patternInput_33[1]];

      case 30:
        errorR(new _Error(SR.parsUnfinishedExpression("in"), $var157[4]));
        const patternInput_34 = suppressErrorReporting(function () {
          return TcExprOfUnknownType(cenv_1, env, tpenv, $var157[1]);
        });
        const patternInput_35 = suppressErrorReporting(function () {
          return TcExprOfUnknownType(cenv_1, env, patternInput_34[2], $var157[2]);
        });
        return [mkDefault($var157[3], overallTy), patternInput_35[2]];

      case 31:
        return [mkDefault($var157[2], overallTy), tpenv];

      case 32:
        const patternInput_36 = suppressErrorReporting(function () {
          return TcExprOfUnknownTypeThen(cenv_1, env, tpenv, $var157[1], ofArray([new DelayedItem(3)]));
        });
        return [mkDefault($var157[2], overallTy), patternInput_36[2]];

      case 33:
        const patternInput_37 = suppressErrorReporting(function () {
          return TcExpr(cenv_1, overallTy, env, tpenv, $var157[1]);
        });
        return [mkDefault($var157[2], overallTy), patternInput_37[1]];

      case 34:
        if ($var157[1]) {
          return TcLinearExprs(function (overallTy_2, env_4, tpenv_3, expr_4) {
            return TcExprThatCanBeCtorBody(cenv_1, overallTy_2, env_4, tpenv_3, expr_4);
          }, cenv_1, env, overallTy, tpenv, false, expr, function (x_3) {
            return x_3;
          });
        } else {
          const patternInput_38 = TcExprThatCanBeCtorBody(cenv_1, overallTy, env, tpenv, $var157[2]);

          if (GetCtorShapeCounter(env) !== 1) {
            errorR(new _Error(SR.tcExpressionFormRequiresObjectConstructor(), $var157[4]));
          }

          const patternInput_39 = TcStmtThatCantBeCtorBody(cenv_1, env, patternInput_38[1], $var157[3]);
          return [new Expr(2, [patternInput_38[0], patternInput_39[0], new SequentialOpKind(1), $var157[5], $var157[4]]), patternInput_39[1]];
        }

      case 35:
        UnifyTypes(cenv_1, env, $var157[2], overallTy, cenv_1.g.unit_ty);
        return TcStmtThatCantBeCtorBody(cenv_1, env, tpenv, $var157[1]);

      case 36:
        const patternInput_40 = TcExprThatCantBeCtorBody(cenv_1, cenv_1.g.bool_ty, env, tpenv, $var157[1]);
        let patternInput_41;
        let env_5;

        if (env.eContextInfo.tag === 3) {
          const eContextInfo_1 = new ContextInfo(3, $var157[2].Range);
          env_5 = new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, eContextInfo_1, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
        } else if ($var157[3] == null) {
          const eContextInfo_2 = new ContextInfo(2, $var157[2].Range);
          env_5 = new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, eContextInfo_2, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
        } else {
          const eContextInfo_3 = new ContextInfo(1, $var157[2].Range);
          env_5 = new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, eContextInfo_3, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
        }

        if (!$var157[4] ? $var157[3] == null : false) {
          UnifyTypes(cenv_1, env_5, $var157[5], cenv_1.g.unit_ty, overallTy);
        }

        patternInput_41 = TcExprThatCanBeCtorBody(cenv_1, overallTy, env_5, patternInput_40[1], $var157[2]);
        let patternInput_43;

        if ($var157[3] != null) {
          let env_6;
          const eContextInfo_4 = new ContextInfo(3, getValue($var157[3]).Range);
          env_6 = new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, eContextInfo_4, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
          const patternInput_42 = TcExprThatCanBeCtorBody(cenv_1, overallTy, env_6, patternInput_41[1], getValue($var157[3]));
          patternInput_43 = [patternInput_42[0], new SequencePointInfoForTarget(0), patternInput_42[1]];
        } else {
          patternInput_43 = [mkUnit(cenv_1.g, $var157[6]), new SequencePointInfoForTarget(1), patternInput_41[1]];
        }

        return [primMkCond($var157[7], new SequencePointInfoForTarget(0), patternInput_43[1], $var157[5], overallTy, patternInput_40[0], patternInput_41[0], patternInput_43[0]), patternInput_43[2]];

      case 37:
        const patternInput_44 = mapFold(function (tpenv_4, c) {
          return TcStaticOptimizationConstraint(cenv_1, env, tpenv_4, c);
        }, tpenv, $var157[1], ofArray);
        const patternInput_45 = TcExprOfUnknownType(cenv_1, env, patternInput_44[1], $var157[2]);
        const patternInput_46 = TcExpr(cenv_1, overallTy, env, patternInput_45[2], $var157[3]);
        return [new Expr(10, [patternInput_44[0], patternInput_45[0], patternInput_46[0], $var157[4]]), patternInput_46[1]];

      case 38:
        if ($var157[3].ThereIsAnExtraDotAtTheEnd) {
          const mExprAndDotLookup = unionRanges($var157[1].Range, rangeOfLid($var157[4]));
          return TcExprThen(cenv_1, overallTy, env, tpenv, $var157[1], ofArray([new DelayedItem(2, [$var157[4], mExprAndDotLookup])]));
        } else {
          const mExprAndDotLookup_1 = unionRanges($var157[1].Range, rangeOfLid($var157[4]));
          return TcExprThen(cenv_1, overallTy, env, tpenv, $var157[1], ofArray([new DelayedItem(2, [$var157[4], mExprAndDotLookup_1]), MakeDelayedSet($var157[2], $var157[5])]));
        }

      case 39:
        if ($var157[4].ThereIsAnExtraDotAtTheEnd) {
          const mExprAndDotLookup_2 = unionRanges($var157[1].Range, rangeOfLid($var157[5]));
          return TcExprThen(cenv_1, overallTy, env, tpenv, $var157[1], ofArray([new DelayedItem(2, [$var157[5], mExprAndDotLookup_2])]));
        } else {
          const mExprAndDotLookup_3 = unionRanges($var157[1].Range, rangeOfLid($var157[5]));
          return TcExprThen(cenv_1, overallTy, env, tpenv, $var157[1], ofArray([new DelayedItem(2, [$var157[5], mExprAndDotLookup_3]), new DelayedItem(1, [0, $var157[2], $var157[6]]), MakeDelayedSet($var157[3], $var157[6])]));
        }

      case 40:
        if ($var157[2].ThereIsAnExtraDotAtTheEnd) {
          return TcLongIdentThen(cenv_1, overallTy, env, tpenv, $var157[2], new List());
        } else {
          return TcLongIdentThen(cenv_1, overallTy, env, tpenv, $var157[2], ofArray([MakeDelayedSet($var157[1], $var157[3])]));
        }

      case 41:
        if ($var157[3].ThereIsAnExtraDotAtTheEnd) {
          return TcLongIdentThen(cenv_1, overallTy, env, tpenv, $var157[3], new List());
        } else {
          return TcLongIdentThen(cenv_1, overallTy, env, tpenv, $var157[3], ofArray([new DelayedItem(1, [0, $var157[1], $var157[4]]), MakeDelayedSet($var157[2], $var157[4])]));
        }

      case 42:
        const synTypes = map_1(function (tp) {
          return new SynType(7, [tp, $var157[2]]);
        }, $var157[4]);
        const patternInput_47 = TcPseudoMemberSpec(cenv_1, new ImplictlyBoundTyparsAllowed(1), env, synTypes, tpenv, $var157[3], $var157[2]);
        const returnTy = patternInput_47[0].data[4];
        const logicalCompiledName = patternInput_47[0].data[1];
        const argtys_2 = patternInput_47[0].data[3];

        if (BakedInTraitConstraintNames.has(logicalCompiledName)) {
          warning(new BakedInMemberConstraintName(logicalCompiledName, $var157[2]));
        }

        const returnTy_1 = GetFSharpViewOfReturnType(cenv_1.g, returnTy);
        const patternInput_48 = GetMethodArgs($var157[1]);

        if (!(patternInput_48[1].tail == null)) {
          errorR(new _Error(SR.tcNamedArgumentsCannotBeUsedInMemberTraits(), $var157[2]));
        }

        const flexes_2 = map_1($var163 => !isTyparTy(cenv_1.g, $var163), argtys_2);
        const patternInput_49 = TcExprs(cenv_1, env, $var157[2], patternInput_47[1], flexes_2, argtys_2, patternInput_48[0]);
        AddCxMethodConstraint(env.DisplayEnv, cenv_1.css, $var157[2], new OptionalTrace(0), patternInput_47[0]);
        UnifyTypes(cenv_1, env, $var157[2], overallTy, returnTy_1);
        return [new Expr(11, [new TOp(29, patternInput_47[0]), new List(), patternInput_49[0], $var157[2]]), patternInput_49[1]];

      case 43:
        const patternInput_50 = TcExprOfUnknownType(cenv_1, env, tpenv, $var157[2]);
        const patternInput_51 = TcUnionCaseOrExnField(cenv_1, env, patternInput_50[1], $var157[3], $var157[1], $var157[4], $var164 => $var165 => function (tupledArg, n) {
          return mkUnionCaseFieldGetUnproven(cenv_1.g, patternInput_50[0], tupledArg[0], tupledArg[1], n, $var157[3]);
        }($var164, $var165), $var166 => $var167 => function (a, n_1) {
          return mkExnCaseFieldGet(patternInput_50[0], a, n_1, $var157[3]);
        }($var166, $var167));
        UnifyTypes(cenv_1, env, $var157[3], overallTy, patternInput_51[1]);
        return [patternInput_51[0]($var157[4]), patternInput_50[2]];

      case 44:
        UnifyTypes(cenv_1, env, $var157[4], overallTy, cenv_1.g.unit_ty);
        const patternInput_52 = TcExprOfUnknownType(cenv_1, env, tpenv, $var157[2]);
        const patternInput_53 = TcUnionCaseOrExnField(cenv_1, env, patternInput_52[1], $var157[4], $var157[1], $var157[5], $var168 => CurriedLambda(function (tupledArg_1, n_2, e2_) {
          if (!isUnionCaseFieldMutable(cenv_1.g, tupledArg_1[0], n_2)) {
            errorR(new _Error(SR.tcFieldIsNotMutable(), $var157[4]));
          }

          return mkUnionCaseFieldSet(patternInput_52[0], tupledArg_1[0], tupledArg_1[1], n_2, e2_, $var157[4]);
        })($var168), $var169 => CurriedLambda(function (a_1, n_3, e2__1) {
          if (!isExnFieldMutable(a_1, n_3)) {
            errorR(new _Error(SR.tcFieldIsNotMutable(), $var157[4]));
          }

          return mkExnCaseFieldSet(patternInput_52[0], a_1, n_3, e2__1, $var157[4]);
        })($var169));
        const patternInput_54 = TcExpr(cenv_1, patternInput_53[1], env, patternInput_52[2], $var157[3]);
        return [patternInput_53[0]($var157[5], patternInput_54[0]), patternInput_54[1]];

      case 45:
        const argtys_3 = NewInferenceTypes($var157[1]);
        const patternInput_55 = TcTypes(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, $var157[5]);
        const flexes_3 = map_1(function (_arg20) {
          return false;
        }, argtys_3);
        const patternInput_56 = TcExprs(cenv_1, env, $var157[2], patternInput_55[1], flexes_3, argtys_3, $var157[1]);
        const patternInput_57 = TcTypes(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, patternInput_56[1], $var157[3]);
        const returnTy_2 = patternInput_57[0].tail != null ? patternInput_57[0].tail.tail == null ? patternInput_57[0].head : error_1(new InternalError("Only zero or one pushed items are permitted in IL assembly code", $var157[2])) : cenv_1.g.unit_ty;
        UnifyTypes(cenv_1, env, $var157[2], overallTy, returnTy_2);
        return [mkAsmExpr(toList($var157[4]), patternInput_55[0], patternInput_56[0], patternInput_57[0], $var157[2]), patternInput_57[1]];

      case 46:
        CallExprHasTypeSink(cenv_1.tcSink, $var157[3], env.NameEnv, overallTy, env.DisplayEnv, env.eAccessRights);
        return TcQuotationExpr(cenv_1, overallTy, env, tpenv, $var157[4], $var157[5], $var157[1], $var157[2], $var157[3]);

      case 47:
        return error_1(new _Error(SR.tcConstructRequiresListArrayOrSequence(), $var157[2]));

      case 48:
        const $var170 = expr.tag === 47 ? (isTrueReturn = expr.data[0][1], isTrueReturn) ? [0, expr.data[0][1], expr.data[2]] : [1] : expr.tag === 48 ? (isTrueReturn_1 = expr.data[0][1], isTrueReturn_1) ? [0, expr.data[0][1], expr.data[2]] : [1] : [1];

        switch ($var170[0]) {
          case 0:
            return error_1(new _Error(SR.tcConstructRequiresComputationExpressions(), $var170[2]));

          case 1:
            const $var171 = expr.tag === 47 ? [0, expr.data[2]] : expr.tag === 48 ? [0, expr.data[2]] : expr.tag === 46 ? [0, expr.data] : expr.tag === 50 ? [1, expr.data[1]] : expr.tag === 49 ? [1, expr.data[6]] : [2];

            switch ($var171[0]) {
              case 0:
                return error_1(new _Error(SR.tcConstructRequiresSequenceOrComputations(), $var171[1]));

              case 1:
                return error_1(new _Error(SR.tcConstructRequiresComputationExpression(), $var171[1]));

              case 2:
                throw new Error("C:/projects/fcs/src/fsharp/TypeChecker.fs", 5672, 10);
            }

        }

    }
  }
}
export function TcIteratedLambdas(cenv_1, isFirst, env, overallTy, takenNames, tpenv, e) {
  const $var172 = e.tag === 15 ? ((e.data[0] ? true : isFirst) ? true : e.data[1]) ? [0, e.data[3], e.data[0], e.data[1], e.data[4], e.data[2]] : [1] : [1];

  switch ($var172[0]) {
    case 0:
      const patternInput = UnifyFunctionType(null, cenv_1, env.DisplayEnv, $var172[4], overallTy);
      const patternInput_1 = TcSimplePats(cenv_1, $var172[2], new CheckConstraints(0), patternInput[0], env, tpenv, create(null, new Comparer(comparePrimitives)), takenNames, $var172[5]);
      const tpenv_1 = patternInput_1[1][0];
      const takenNames_1 = patternInput_1[1][2];
      const names = patternInput_1[1][1];
      const patternInput_2 = MakeAndPublishSimpleVals(cenv_1, env, $var172[4], names, true);
      const byrefs = map_4(function (_arg21, v) {
        return [isByrefTy(cenv_1.g, v.Type), v];
      }, patternInput_2[2]);
      const envinner = $var172[2] ? patternInput_2[0] : ExitFamilyRegion(patternInput_2[0]);
      const patternInput_3 = TcIteratedLambdas(cenv_1, false, envinner, patternInput[1], takenNames_1, tpenv_1, $var172[1]);
      iterate_1(function (_arg22, tupledArg) {
        if (!tupledArg[0] ? isByrefTy(cenv_1.g, tupledArg[1].Type) : false) {
          errorR(new _Error(SR.tcParameterInferredByref(tupledArg[1].DisplayName), tupledArg[1].Range));
        }
      }, byrefs);
      return [mkMultiLambda($var172[4], map_1(function (nm) {
        return NameMapModule.find(nm, patternInput_2[2]);
      }, patternInput_1[0]), patternInput_3[0], patternInput[1]), patternInput_3[1]];

    case 1:
      return conditionallySuppressErrorReporting(!isFirst ? synExprContainsError(e) : false, function () {
        return TcExpr(cenv_1, overallTy, env, tpenv, e);
      });
  }
}
export function TcIndexerThen(cenv_1, env, overallTy, mWholeExpr, mDot, tpenv, wholeExpr, e1, indexArgs, delayed) {
  const patternInput = TcExprOfUnknownType(cenv_1, env, tpenv, e1);
  let propName;
  const $var173 = indexArgs.tail != null ? indexArgs.head.tag === 1 ? indexArgs.tail.tail == null ? [0] : [1] : [1] : [1];

  switch ($var173[0]) {
    case 0:
      propName = FoldPrimaryHierarchyOfType(function (typ, acc) {
        if (acc == null) {
          const matchValue = tryDestAppTy(cenv_1.g, typ);

          if (matchValue == null) {
            const matchValue_1 = AllPropInfosOfTypeInScope(cenv_1.infoReader, env.NameEnv, "Item", env.eAccessRights, new FindMemberFlag(0), mWholeExpr, typ);

            if (matchValue_1.tail == null) {
              return null;
            } else {
              return "Item";
            }
          } else {
            return TryFindTyconRefStringAttribute(cenv_1.g, mWholeExpr, cenv_1.g.attrib_DefaultMemberAttribute, getValue(matchValue));
          }
        } else {
          return acc;
        }
      }, cenv_1.g, cenv_1.amap, mWholeExpr, new AllowMultiIntfInstantiations(0), patternInput[1], null);
      break;

    case 1:
      propName = "GetSlice";
      break;
  }

  const isNominal = isAppTy(cenv_1.g, patternInput[1]);
  const isArray = isArrayTy(cenv_1.g, patternInput[1]);
  const isString = typeEquiv(cenv_1.g, cenv_1.g.string_ty, patternInput[1]);

  const idxRange = function (list) {
    return reduce(function (arg00_, arg10_) {
      return unionRanges(arg00_, arg10_);
    }, list);
  }(map_1(function (e) {
    return e.Range;
  }, indexArgs));

  const GetIndexArgs = function (es) {
    return toList(delay(function () {
      return collect_1(function (e_1) {
        return e_1.Exprs;
      }, es);
    }));
  };

  const MakeIndexParam = function (vopt) {
    const $var174 = indexArgs.tail != null ? indexArgs.head.tag === 1 ? indexArgs.tail.tail == null ? [1, indexArgs.head.data] : [2] : [2] : [0];

    switch ($var174[0]) {
      case 0:
        throw new Error("unexpected empty index list");

      case 1:
        return new SynExpr(0, [$var174[1], range0, null, idxRange]);

      case 2:
        return new SynExpr(0, [new SynExpr(4, [append(GetIndexArgs(indexArgs), toList(defaultArg(vopt, [], $var175 => [$var175]))), new List(), idxRange]), range0, null, idxRange]);
    }
  };

  let attemptArrayString;

  if (isArray ? true : isString) {
    const indexOpPath = ofArray(["Microsoft", "FSharp", "Core", "LanguagePrimitives", "IntrinsicFunctions"]);
    const sliceOpPath = ofArray(["Microsoft", "FSharp", "Core", "Operators", "OperatorIntrinsics"]);
    let info;
    const matchValue_2 = [isString, isArray, wholeExpr];
    const $var176 = matchValue_2[0] ? matchValue_2[1] ? [22] : matchValue_2[2].tag === 33 ? matchValue_2[2].data[1].tail != null ? matchValue_2[2].data[1].head.tag === 1 ? matchValue_2[2].data[1].tail.tail == null ? [9] : [22] : matchValue_2[2].data[1].tail.tail == null ? [8] : [22] : [22] : [22] : matchValue_2[1] ? matchValue_2[2].tag === 33 ? matchValue_2[2].data[1].tail != null ? matchValue_2[2].data[1].head.tag === 0 ? matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail != null ? matchValue_2[2].data[1].tail.tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail.tail != null ? matchValue_2[2].data[1].tail.tail.tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail.tail.tail == null ? [15] : [22] : [22] : [14] : [22] : [13] : matchValue_2[2].data[1].tail.tail.tail == null ? [12] : [22] : [10] : matchValue_2[2].data[1].head.data.tag === 4 ? matchValue_2[2].data[1].head.data.data[0].tail != null ? matchValue_2[2].data[1].head.data.data[0].tail.tail != null ? matchValue_2[2].data[1].head.data.data[0].tail.tail.tail != null ? matchValue_2[2].data[1].head.data.data[0].tail.tail.tail.tail != null ? matchValue_2[2].data[1].head.data.data[0].tail.tail.tail.tail.tail == null ? matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [11] : [22] : [22] : [2, matchValue_2[2].data[1].head.data.data[0]] : matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [11] : [22] : [22] : [3, matchValue_2[2].data[1].head.data] : matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [11] : [22] : [22] : [1, matchValue_2[2].data[1].head.data.data[0]] : matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [11] : [22] : [22] : [0, matchValue_2[2].data[1].head.data.data[0]] : matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [11] : [22] : [22] : [3, matchValue_2[2].data[1].head.data] : matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [11] : [22] : [22] : [3, matchValue_2[2].data[1].head.data] : matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [11] : [22] : [22] : [3, matchValue_2[2].data[1].head.data] : [22] : matchValue_2[2].tag === 34 ? matchValue_2[2].data[1].tail != null ? matchValue_2[2].data[1].head.tag === 0 ? matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 1 ? matchValue_2[2].data[1].tail.tail.tail == null ? [19, matchValue_2[2].data[2]] : [22] : matchValue_2[2].data[1].tail.tail.tail != null ? matchValue_2[2].data[1].tail.tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail.tail != null ? matchValue_2[2].data[1].tail.tail.tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail.tail.tail == null ? [21, matchValue_2[2].data[2]] : [22] : [22] : [20, matchValue_2[2].data[2]] : [22] : [17, matchValue_2[2].data[2]] : [16, matchValue_2[2].data[2]] : matchValue_2[2].data[1].head.data.tag === 4 ? matchValue_2[2].data[1].head.data.data[0].tail != null ? matchValue_2[2].data[1].head.data.data[0].tail.tail != null ? matchValue_2[2].data[1].head.data.data[0].tail.tail.tail != null ? matchValue_2[2].data[1].head.data.data[0].tail.tail.tail.tail != null ? matchValue_2[2].data[1].head.data.data[0].tail.tail.tail.tail.tail == null ? matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [18, matchValue_2[2].data[2]] : [22] : [22] : [6, matchValue_2[2].data[2], matchValue_2[2].data[1].head.data.data[0]] : matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [18, matchValue_2[2].data[2]] : [22] : [22] : [7, matchValue_2[2].data[2]] : matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [18, matchValue_2[2].data[2]] : [22] : [22] : [5, matchValue_2[2].data[2], matchValue_2[2].data[1].head.data.data[0]] : matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [18, matchValue_2[2].data[2]] : [22] : [22] : [4, matchValue_2[2].data[2], matchValue_2[2].data[1].head.data.data[0]] : matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [18, matchValue_2[2].data[2]] : [22] : [22] : [7, matchValue_2[2].data[2]] : matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [18, matchValue_2[2].data[2]] : [22] : [22] : [7, matchValue_2[2].data[2]] : matchValue_2[2].data[1].tail.tail != null ? matchValue_2[2].data[1].tail.head.tag === 0 ? matchValue_2[2].data[1].tail.tail.tail == null ? [18, matchValue_2[2].data[2]] : [22] : [22] : [7, matchValue_2[2].data[2]] : [22] : [22] : [22];

    switch ($var176[0]) {
      case 0:
        info = [indexOpPath, "GetArray2D", $var176[1]];
        break;

      case 1:
        info = [indexOpPath, "GetArray3D", $var176[1]];
        break;

      case 2:
        info = [indexOpPath, "GetArray4D", $var176[1]];
        break;

      case 3:
        info = [indexOpPath, "GetArray", ofArray([$var176[1]])];
        break;

      case 4:
        info = [indexOpPath, "SetArray2D", append($var176[2], ofArray([$var176[1]]))];
        break;

      case 5:
        info = [indexOpPath, "SetArray3D", append($var176[2], ofArray([$var176[1]]))];
        break;

      case 6:
        info = [indexOpPath, "SetArray4D", append($var176[2], ofArray([$var176[1]]))];
        break;

      case 7:
        info = [indexOpPath, "SetArray", append(GetIndexArgs(indexArgs), ofArray([$var176[1]]))];
        break;

      case 8:
        info = [sliceOpPath, "GetStringSlice", GetIndexArgs(indexArgs)];
        break;

      case 9:
        info = [indexOpPath, "GetString", GetIndexArgs(indexArgs)];
        break;

      case 10:
        info = [sliceOpPath, "GetArraySlice", GetIndexArgs(indexArgs)];
        break;

      case 11:
        info = [sliceOpPath, "GetArraySlice2DFixed1", GetIndexArgs(indexArgs)];
        break;

      case 12:
        info = [sliceOpPath, "GetArraySlice2DFixed2", GetIndexArgs(indexArgs)];
        break;

      case 13:
        info = [sliceOpPath, "GetArraySlice2D", GetIndexArgs(indexArgs)];
        break;

      case 14:
        info = [sliceOpPath, "GetArraySlice3D", GetIndexArgs(indexArgs)];
        break;

      case 15:
        info = [sliceOpPath, "GetArraySlice4D", GetIndexArgs(indexArgs)];
        break;

      case 16:
        info = [sliceOpPath, "SetArraySlice", append(GetIndexArgs(indexArgs), ofArray([$var176[1]]))];
        break;

      case 17:
        info = [sliceOpPath, "SetArraySlice2D", append(GetIndexArgs(indexArgs), ofArray([$var176[1]]))];
        break;

      case 18:
        info = [sliceOpPath, "SetArraySlice2DFixed1", append(GetIndexArgs(indexArgs), ofArray([$var176[1]]))];
        break;

      case 19:
        info = [sliceOpPath, "SetArraySlice2DFixed2", append(GetIndexArgs(indexArgs), ofArray([$var176[1]]))];
        break;

      case 20:
        info = [sliceOpPath, "SetArraySlice3D", append(GetIndexArgs(indexArgs), ofArray([$var176[1]]))];
        break;

      case 21:
        info = [sliceOpPath, "SetArraySlice4D", append(GetIndexArgs(indexArgs), ofArray([$var176[1]]))];
        break;

      case 22:
        info = null;
        break;
    }

    if (info != null) {
      const path = getValue(info)[0];
      const indexArgs_1 = getValue(info)[2];
      const functionName = getValue(info)[1];
      const operPath = mkSynLidGet(mDot, path, CompileOpName(functionName));
      const patternInput_1 = TcExprOfUnknownType(cenv_1, env, patternInput[2], operPath);
      const patternInput_2 = UnifyFunctionType(mWholeExpr, cenv_1, env.DisplayEnv, mWholeExpr, patternInput_1[1]);
      UnifyTypes(cenv_1, env, mWholeExpr, patternInput_2[0], patternInput[1]);
      const f_ = buildApp(cenv_1, MakeApplicableExprNoFlex(cenv_1, patternInput_1[0]), patternInput_1[1], patternInput[0], mWholeExpr);
      const delayed_1 = foldBack(function (idx, acc_1) {
        return new List(new DelayedItem(1, [0, idx, mWholeExpr]), acc_1);
      }, indexArgs_1, delayed);
      attemptArrayString = PropagateThenTcDelayed(cenv_1, overallTy, env, patternInput_1[2], mWholeExpr, f_, patternInput_2[1], 0, delayed_1);
    } else {
      attemptArrayString = null;
    }
  } else {
    attemptArrayString = null;
  }

  if (attemptArrayString == null) {
    if (isNominal ? true : propName != null) {
      const nm = propName != null ? getValue(propName) : "Item";
      let delayed_2;

      if (wholeExpr.tag === 33) {
        delayed_2 = ofArray([new DelayedItem(2, [ofArray([ident(nm, mWholeExpr)]), mWholeExpr]), new DelayedItem(1, [0, MakeIndexParam(null), mWholeExpr])], delayed);
      } else if (wholeExpr.tag === 34) {
        const $var177 = indexArgs.tail != null ? indexArgs.head.tag === 1 ? indexArgs.tail.tail == null ? [0] : [1] : [1] : [1];

        switch ($var177[0]) {
          case 0:
            delayed_2 = ofArray([new DelayedItem(2, [ofArray([ident(nm, wholeExpr.data[3])]), wholeExpr.data[3]]), new DelayedItem(1, [0, MakeIndexParam(null), wholeExpr.data[3]]), MakeDelayedSet(wholeExpr.data[2], mWholeExpr)], delayed);
            break;

          case 1:
            delayed_2 = ofArray([new DelayedItem(2, [ofArray([ident("SetSlice", wholeExpr.data[3])]), wholeExpr.data[3]]), new DelayedItem(1, [0, MakeIndexParam(wholeExpr.data[2]), mWholeExpr])], delayed);
            break;
        }
      } else {
        delayed_2 = error_1(new InternalError("unreachable", mWholeExpr));
      }

      return PropagateThenTcDelayed(cenv_1, overallTy, env, patternInput[2], mDot, MakeApplicableExprNoFlex(cenv_1, patternInput[0]), patternInput[1], 0, delayed_2);
    } else {
      return error_1(new _Error(SR.tcObjectOfIndeterminateTypeUsedRequireTypeConstraint(), mWholeExpr));
    }
  } else {
    return getValue(attemptArrayString);
  }
}
export function TcNewExpr(cenv_1, env, tpenv, objTy, mObjTyOpt, superInit, arg, mWholeExprOrObjTy) {
  if (isTyparTy(cenv_1.g, objTy)) {
    if (superInit) {
      error_1(new _Error(SR.tcCannotInheritFromVariableType(), mWholeExprOrObjTy));
    }

    AddCxTypeMustSupportDefaultCtor(env.DisplayEnv, cenv_1.css, mWholeExprOrObjTy, new OptionalTrace(0), objTy);
    const $var178 = arg.tag === 2 ? arg.data[0].tag === 0 ? [0] : [1] : [1];

    switch ($var178[0]) {
      case 0:
        break;

      case 1:
        errorR(new _Error(SR.tcObjectConstructorsOnTypeParametersCannotTakeArguments(), mWholeExprOrObjTy));
        break;
    }

    return [mkCallCreateInstance(cenv_1.g, mWholeExprOrObjTy, objTy), tpenv];
  } else {
    if (!isAppTy(cenv_1.g, objTy) ? !isAnyTupleTy(cenv_1.g, objTy) : false) {
      error_1(new _Error(SR.tcNamedTypeRequired(superInit ? "inherit" : "new"), mWholeExprOrObjTy));
    }

    const item = ResultOrExceptionModule.ForceRaise(ResolveObjectConstructor(cenv_1.nameResolver, env.DisplayEnv, mWholeExprOrObjTy, env.eAccessRights, objTy));
    return TcCtorCall(false, cenv_1, env, tpenv, objTy, objTy, mObjTyOpt, item, superInit, ofArray([arg]), mWholeExprOrObjTy, new List(), null);
  }
}
export function TcCtorCall(isNaked, cenv_1, env, tpenv, overallTy, objTy, mObjTyOpt, item, superInit, args, mWholeCall, delayed, afterTcOverloadResolutionOpt) {
  const isSuperInit = superInit ? new ValUseFlag(2) : new ValUseFlag(1);
  const mItem = mObjTyOpt == null ? mWholeCall : getValue(mObjTyOpt);

  if (isInterfaceTy(cenv_1.g, objTy)) {
    error_1(new _Error(superInit ? SR.tcInheritCannotBeUsedOnInterfaceType() : SR.tcNewCannotBeUsedOnInterfaceType(), mWholeCall));
  }

  const matchValue = [item, args];
  const $var179 = matchValue[0].tag === 11 ? [0, matchValue[0].data[0], matchValue[0].data[1]] : matchValue[0].tag === 13 ? matchValue[1].tail != null ? matchValue[1].tail.tail == null ? [1, matchValue[1].head, matchValue[0].data] : [2] : [2] : [2];

  switch ($var179[0]) {
    case 0:
      const meths = map_1(function (minfo) {
        return [minfo, null];
      }, $var179[2]);

      if (isNaked ? TypeFeasiblySubsumesType(0, cenv_1.g, cenv_1.amap, mWholeCall, cenv_1.g.system_IDisposable_typ, new CanCoerce(1), objTy) : false) {
        warning(new _Error(SR.tcIDisposableTypeShouldUseNew(), mWholeCall));
      }

      if (!(superInit ? true : AreWithinCtorShape(env))) {
        CheckSuperInit(cenv_1, objTy, mWholeCall);
      }

      let afterResolution;
      const matchValue_1 = [mObjTyOpt, afterTcOverloadResolutionOpt];

      if (matchValue_1[1] == null) {
        if (matchValue_1[0] == null) {
          afterResolution = new AfterResolution(0);
        } else {
          const mObjTy = getValue(matchValue_1[0]);
          afterResolution = ForNewConstructors(cenv_1.tcSink, env, mObjTy, $var179[1], $var179[2]);
        }
      } else {
        const action = getValue(matchValue_1[1]);
        afterResolution = action;
      }

      return TcMethodApplicationThen(cenv_1, env, overallTy, objTy, tpenv, null, new List(), mWholeCall, mItem, $var179[1], env.eAccessRights, new Mutates(1), false, meths, afterResolution, isSuperInit, args, 1, delayed);

    case 1:
      if (mObjTyOpt == null) {} else {
        CallNameResolutionSink(cenv_1.tcSink, getValue(mObjTyOpt), env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, env.eAccessRights);
      }

      return TcNewDelegateThen(cenv_1, objTy, env, tpenv, mItem, mWholeCall, $var179[2], $var179[1], 1, delayed);

    case 2:
      return error_1(new _Error(SR.tcSyntaxCanOnlyBeUsedToCreateObjectTypes(superInit ? "inherit" : "new"), mWholeCall));
  }
}
export function TcRecordConstruction(cenv_1, overallTy, env, tpenv, optOrigExpr, objTy, fldsList, m) {
  const patternInput = destAppTy(cenv_1.g, objTy);
  const tycon = patternInput[0].Deref;
  UnifyTypes(cenv_1, env, m, overallTy, objTy);

  if (NameMultiMapModule.existsInRange(function (v) {
    return v.IsIncrClassConstructor;
  }, tycon.MembersOfFSharpTyconByName)) {
    errorR(new _Error(SR.tcConstructorRequiresCall(tycon.DisplayName), m));
  }

  const fspecs = tycon.TrueInstanceFieldsAsList;
  const fldsList_1 = toList(delay(function () {
    return collect_1(function (matchValue) {
      let fspec_1;

      try {
        fspec_1 = find(function (fspec) {
          return fspec.Name === matchValue[0];
        }, fspecs);
      } catch (matchValue_1) {
        if (matchValue_1 instanceof Error) {
          fspec_1 = error_1(new _Error(SR.tcUndefinedField(matchValue[0], minimalStringOfType(env.DisplayEnv, objTy)), m));
        } else {
          throw matchValue_1;
        }
      }

      const fty = actualTyOfRecdFieldForTycon(tycon, patternInput[1], fspec_1);
      const flex = !isTyparTy(cenv_1.g, fty);
      return singleton([matchValue[0], matchValue[1], fty, flex]);
    }, fldsList);
  }));
  let patternInput_2;
  let env_1;
  const eContextInfo = new ContextInfo(4);
  env_1 = new TcEnv(env.eNameResEnv, env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  patternInput_2 = mapFold(function (tpenv_1, tupledArg) {
    const patternInput_1 = TcExprFlex(cenv_1, tupledArg[3], tupledArg[2], env_1, tpenv_1, tupledArg[1]);
    return [[tupledArg[0], patternInput_1[0]], patternInput_1[1]];
  }, tpenv, fldsList_1, ofArray);
  let patternInput_4;

  if (optOrigExpr != null) {
    const oldve = getValue(optOrigExpr)[2];
    const patternInput_3 = mkExprAddrOfExpr(cenv_1.g, tycon.IsStructOrEnumTycon, false, new Mutates(2), oldve, null, m);

    const fieldNameUnbound = function (nom) {
      return forAll(function (tupledArg_1) {
        return tupledArg_1[0] !== nom;
      }, patternInput_2[0]);
    };

    const flds = choose_1(function (rfld) {
      return (fieldNameUnbound(rfld.Name) ? !rfld.IsZeroInit : false) ? [rfld.Name, mkRecdFieldGetViaExprAddr(patternInput_3[1], patternInput[0].MakeNestedRecdFieldRef(rfld), patternInput[1], m)] : null;
    }, fspecs);
    patternInput_4 = [flds, patternInput_3[0]];
  } else {
    patternInput_4 = [new List(), function (x) {
      return x;
    }];
  }

  const fldsList_2 = append(patternInput_2[0], patternInput_4[0]);
  const fspecs_1 = filter(function (f) {
    return !f.IsZeroInit;
  }, fspecs);
  iterate(function (fspec_2) {
    if (!exists_1(function (tupledArg_2) {
      return tupledArg_2[0] === fspec_2.Name;
    }, fldsList_2)) {
      error_1(new _Error(SR.tcFieldRequiresAssignment(fspec_2.rfield_id.idText, fullDisplayTextOfTyconRef(patternInput[0])), m));
    }
  }, fspecs_1);
  const ns1 = NameSetModule.ofList(map_1(function (tuple) {
    return tuple[0];
  }, fldsList_2));
  const ns2 = NameSetModule.ofList(map_1(function (x_1) {
    return x_1.rfield_id.idText;
  }, fspecs_1));

  if (optOrigExpr == null ? !ZsetModule.subset(ns2, ns1) : false) {
    error_1(new MissingFields(ZsetModule.elements(ZsetModule.diff(ns2, ns1)), m));
  }

  if (!ZsetModule.subset(ns1, ns2)) {
    error_1(new _Error(SR.tcExtraneousFieldsGivenValues(), m));
  }

  const rfrefs = map_1($var180 => function (f_1) {
    return mkRecdFieldRef(patternInput[0], f_1);
  }(function (tuple_1) {
    return tuple_1[0];
  }($var180)), fldsList_2);
  iterate(function (rfref) {
    CheckRecdFieldAccessible(cenv_1.amap, m, env.eAccessRights, rfref);
    CommitOperationResult(CheckFSharpAttributes(cenv_1.g, rfref.PropertyAttribs, m));
  }, rfrefs);
  const args = map_1(function (tuple_2) {
    return tuple_2[1];
  }, fldsList_2);
  const expr = patternInput_4[1](mkRecordExpr(cenv_1.g, GetRecdInfo(env), patternInput[0], patternInput[1], rfrefs, args, m));
  let expr_1;

  if (optOrigExpr != null) {
    const oldv = getValue(optOrigExpr)[1];
    const old = getValue(optOrigExpr)[0];
    expr_1 = mkCompGenLet(m, oldv, old, expr);
  } else {
    expr_1 = expr;
  }

  return [expr_1, patternInput_2[1]];
}
export function GetNameAndArityOfObjExprBinding(_cenv, _env, b) {
  const matchValue = [b.data[8], b.data[7].data[0]];
  const $var181 = matchValue[0].tag === 18 ? matchValue[0].data[3] == null ? matchValue[1] != null ? [0, matchValue[0].data[0], getValue(matchValue[1]), matchValue[0].data[1]] : [1] : [1] : [1];

  switch ($var181[0]) {
    case 0:
      const logicalMethId = ident(ComputeLogicalName($var181[3], $var181[2]), $var181[3].idRange);
      return [logicalMethId.idText, b.data[7].data[1]];

    case 1:
      const lookPat = function (pat) {
        lookPat: while (true) {
          const $var182 = pat.tag === 3 ? [0, pat.data[0]] : pat.tag === 19 ? [1, pat.data[0]] : pat.tag === 2 ? pat.data[0].tag === 1 ? pat.data[3] == null ? [2, pat.data[1]] : [3] : [3] : [3];

          switch ($var182[0]) {
            case 0:
              pat = $var182[1];
              continue lookPat;

            case 1:
              pat = $var182[1];
              continue lookPat;

            case 2:
              const infosForExplicitArgs = function (list) {
                return map_1(function (x) {
                  return SynInfo.InferSynArgInfoFromSimplePats(x);
                }, list);
              }(b.data[9].data[0]);

              const infosForExplicitArgs_1 = SynInfo.AdjustMemberArgs(new MemberKind_2(2), infosForExplicitArgs);
              const infosForExplicitArgs_2 = SynInfo.AdjustArgsForUnitElimination(infosForExplicitArgs_1);
              const argInfos = append(ofArray([SynInfo.selfMetadata]), infosForExplicitArgs_2);
              const retInfo = SynInfo.unnamedRetVal;
              const valSynData = new SynValInfo(0, [argInfos, retInfo]);
              return [$var182[1].idText, valSynData];

            case 3:
              return error_1(new _Error(SR.tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual(), b.data[10]));
          }
        }
      };

      return lookPat(b.data[8]);
  }
}
export function FreshenObjExprAbstractSlot(cenv_1, env, implty, virtNameAndArityPairs, bind, bindAttribs, bindName, absSlots) {
  const $var183 = absSlots.tail == null ? !CompileAsEvent(cenv_1.g, bindAttribs) ? [0] : [1] : [1];

  switch ($var183[0]) {
    case 0:
      const absSlotsByName = filter($var185 => function (y) {
        return bindName === y;
      }(($var184 => $var184[0][0])($var185)), virtNameAndArityPairs);

      const getSignature = function (absSlot) {
        return replace(stringOfMethInfo(cenv_1.amap, bind.data[10], env.DisplayEnv, absSlot), "abstract ", "");
      };

      const getDetails = function (absSlot_1) {
        if (List_1.existsSquared(function (arg10_) {
          return isAnyTupleTy(cenv_1.g, arg10_);
        }, absSlot_1.GetParamTypes(cenv_1.amap, bind.data[10], new List()))) {
          return SR.tupleRequiredInAbstractMethod();
        } else {
          return "";
        }
      };

      const patternInput = GetNameAndArityOfObjExprBinding(cenv_1, env, bind);
      let arity;
      const matchValue = SynInfo.AritiesOfArgs(patternInput[1]);
      const $var186 = matchValue.tail != null ? matchValue.tail.tail != null ? [0, matchValue.tail.head] : [1] : [1];

      switch ($var186[0]) {
        case 0:
          arity = $var186[1] | 0;
          break;

        case 1:
          arity = 0;
          break;
      }

      if (absSlotsByName.tail != null) {
        if (absSlotsByName.tail.tail == null) {
          errorR(new _Error(SR.tcArgumentArityMismatch(bindName, sum(absSlotsByName.head[1].NumArgs), arity, getSignature(absSlotsByName.head[1]), getDetails(absSlotsByName.head[1])), bind.data[10]));
        } else {
          errorR(new _Error(SR.tcArgumentArityMismatchOneOverload(bindName, sum(absSlotsByName.head[1].NumArgs), arity, getSignature(absSlotsByName.head[1]), getDetails(absSlotsByName.head[1])), bind.data[10]));
        }
      } else {
        const tcref = tcrefOfAppTy(cenv_1.g, implty);
        const containsNonAbstractMemberWithSameName = exists_1(function (kv) {
          return exists_1(function (valRef) {
            return valRef.DisplayName === bindName;
          }, kv[1]);
        }, tcref.MembersOfFSharpTyconByName);

        const suggestVirtualMembers = function () {
          return new Set(map_1($var187 => $var187[0][0], virtNameAndArityPairs));
        };

        if (containsNonAbstractMemberWithSameName) {
          errorR(new ErrorWithSuggestions(SR.tcMemberFoundIsNotAbstractOrVirtual(tcref.DisplayName, bindName), bind.data[10], bindName, suggestVirtualMembers));
        } else {
          errorR(new ErrorWithSuggestions(SR.tcNoAbstractOrVirtualMemberFound(bindName), bind.data[10], bindName, suggestVirtualMembers));
        }
      }

      return null;

    case 1:
      const $var188 = absSlots.tail != null ? absSlots.tail.tail == null ? [0, absSlots.head[1]] : [1] : [1];

      switch ($var188[0]) {
        case 0:
          const patternInput_1 = FreshenAbstractSlot(cenv_1.g, cenv_1.amap, bind.data[10], bind.data[6], $var188[1]);
          const bindingTy = op_MinusMinusGreater(implty, mkMethodTy(cenv_1.g, patternInput_1[2], patternInput_1[3]));
          return [patternInput_1[0], patternInput_1[1], bindingTy];

        case 1:
          return null;
      }

  }
}
export function TcObjectExprBinding(cenv_1, env, implty, tpenv, absSlotInfo, bind) {
  let patternInput;

  const lookPat = function (p) {
    lookPat: while (true) {
      const matchValue = [p, bind.data[7].data[0]];
      const $var189 = matchValue[0].tag === 19 ? [0, matchValue[0].data[0]] : matchValue[0].tag === 2 ? matchValue[0].data[0].tag === 1 ? matchValue[1] == null ? [1, matchValue[0].data[1]] : [3] : [3] : matchValue[0].tag === 18 ? matchValue[1] != null ? [2, getValue(matchValue[1]), matchValue[0].data[1], matchValue[0].data[0]] : [3] : [3];

      switch ($var189[0]) {
        case 0:
          p = $var189[1];
          continue lookPat;

        case 1:
          const bindingRhs = PushOnePatternToRhs(cenv_1, true, mkSynThisPatVar(ident(CompilerGeneratedName("this"), $var189[1].idRange)), bind.data[9]);
          const memberFlags = OverrideMemberFlags(new MemberKind_2(2));
          return [bindingRhs, $var189[1], memberFlags];

        case 2:
          CheckMemberFlags(null, new NewSlotsOK(0), new OverridesOK(0), $var189[1], bind.data[10]);
          const bindingRhs_1 = PushOnePatternToRhs(cenv_1, true, mkSynThisPatVar($var189[3]), bind.data[9]);
          const logicalMethId = ident(ComputeLogicalName($var189[2], $var189[1]), $var189[2].idRange);
          return [bindingRhs_1, logicalMethId, $var189[1]];

        case 3:
          return error_1(new InternalError("unexpected member binding", bind.data[10]));
      }
    }
  };

  patternInput = lookPat(bind.data[8]);
  const bind_1 = new NormalizedBinding(0, [bind.data[0], bind.data[1], bind.data[2], bind.data[3], bind.data[4], bind.data[5], bind.data[6], bind.data[7], mkSynPatVar(bind.data[0], patternInput[1]), patternInput[0], bind.data[10], bind.data[11]]);
  let bindingTy;

  if (absSlotInfo != null) {
    const memberTyFromAbsSlot = getValue(absSlotInfo)[2];
    bindingTy = memberTyFromAbsSlot;
  } else {
    bindingTy = op_MinusMinusGreater(implty, NewInferenceType());
  }

  let patternInput_2;
  const patternInput_1 = TcNonrecBindingTyparDecls(cenv_1, env, tpenv, bind_1);
  patternInput_2 = TcNormalizedBinding(new DeclKind(4), cenv_1, env, patternInput_1[1], bindingTy, null, new SafeInitData(1), new List(), patternInput_1[0], bind_1);
  const rhsExpr = patternInput_2[0].data[6];
  const nameToPrelimValSchemeMap = patternInput_2[0].data[5];
  const m = patternInput_2[0].data[9];
  const inlineFlag = patternInput_2[0].data[0];
  const declaredTypars = patternInput_2[0].data[4].data[1];
  const bindingAttribs = patternInput_2[0].data[1];
  const matchValue_1 = NameMapModule.range(nameToPrelimValSchemeMap);
  const $var190 = matchValue_1.tail != null ? matchValue_1.tail.tail == null ? [0, matchValue_1.head.data[0]] : [1] : [1];

  switch ($var190[0]) {
    case 0:
      const denv = env.DisplayEnv;
      let declaredTypars_1;

      if (absSlotInfo != null) {
        const typarsFromAbsSlotAreRigid = getValue(absSlotInfo)[0];
        const typarsFromAbsSlot = getValue(absSlotInfo)[1];

        if (typarsFromAbsSlotAreRigid) {
          declaredTypars_1 = typarsFromAbsSlot;
        } else {
          declaredTypars_1 = declaredTypars;
        }
      } else {
        declaredTypars_1 = declaredTypars;
      }

      GeneralizationHelpers.CanonicalizePartialInferenceProblem(cenv_1, denv, m, declaredTypars_1);
      const freeInEnv = GeneralizationHelpers.ComputeUngeneralizableTypars(env);
      const generalizedTypars = GeneralizationHelpers.ComputeAndGeneralizeGenericTypars(cenv_1, denv, m, freeInEnv, false, new GeneralizeConstrainedTyparOptions(0), inlineFlag, rhsExpr, declaredTypars_1, new List(), bindingTy, false);
      const declaredTypars_2 = ChooseCanonicalDeclaredTyparsAfterInference(cenv_1.g, env.DisplayEnv, declaredTypars_1, m);
      const generalizedTypars_1 = PlaceTyparsInDeclarationOrder(declaredTypars_2, generalizedTypars);
      return [[$var190[1], patternInput[2], op_PlusMinusGreater(generalizedTypars_1, bindingTy), bindingAttribs, rhsExpr], patternInput_2[1]];

    case 1:
      return error_1(new _Error(SR.tcSimpleMethodNameRequired(), m));
  }
}
export function ComputeObjectExprOverrides(cenv_1, env, tpenv, impls) {
  const slotImplSets = DispatchSlotChecking.GetSlotImplSets(cenv_1.infoReader, env.DisplayEnv, true, map_1(function (tupledArg) {
    return [tupledArg[1], tupledArg[0]];
  }, impls));
  const allImpls = toList(map2(function (tupledArg_1, implTySet) {
    var isObjExprBinding;
    const binds = map_1((isObjExprBinding = new IsObjExprBinding(0), function (b) {
      return BindingNormalization.NormalizeBinding(isObjExprBinding, cenv_1, env, b);
    }), tupledArg_1[2]);
    return [tupledArg_1[0], tupledArg_1[1], binds, implTySet];
  }, impls, slotImplSets));
  const patternInput_3 = mapFold(function (tpenv_1, tupledArg_2) {
    const patternInput = unzip(toList(delay(function () {
      return collect_1(function (binding) {
        const attrTgt = function (arg00, arg10) {
          return DeclKind.AllowedAttribTargets(arg00, arg10);
        }(binding.data[7].data[0], new DeclKind(4)) | 0;

        const bindingAttribs = TcAttributes(cenv_1, env, attrTgt, binding.data[4]);
        return append_1(singleton([binding, bindingAttribs]), delay(function () {
          return map_2(function (extraBinding) {
            return [extraBinding, new List()];
          }, EventDeclarationNormalization.GenerateExtraBindings(cenv_1, bindingAttribs, binding));
        }));
      }, tupledArg_2[2]);
    })));
    const dispatchSlots = map_1(function (_arg26) {
      return _arg26.data[0];
    }, tupledArg_2[3].data[0]);
    const virtNameAndArityPairs = map_1(function (virt) {
      const vkey = [virt.LogicalName, virt.NumArgs];
      return [vkey, virt];
    }, dispatchSlots);
    const bindNameAndSynInfoPairs = map_1(function (b_1) {
      return GetNameAndArityOfObjExprBinding(cenv_1, env, b_1);
    }, patternInput[0]);
    const bindNames = map_1(function (tuple) {
      return tuple[0];
    }, bindNameAndSynInfoPairs);
    const bindKeys = map_1(function (tupledArg_3) {
      const argCounts = SynInfo.AritiesOfArgs(tupledArg_3[1]).tail;
      return [tupledArg_3[0], argCounts];
    }, bindNameAndSynInfoPairs);
    const preAssignedVirtsPerBinding = map_1(function (bkey) {
      return filter($var191 => function (y) {
        return equals(bkey, y);
      }(function (tuple_1) {
        return tuple_1[0];
      }($var191)), virtNameAndArityPairs);
    }, bindKeys);
    const absSlotInfo = map_1(function (tupledArg_4) {
      return FreshenObjExprAbstractSlot(cenv_1, env, tupledArg_2[1], virtNameAndArityPairs, tupledArg_4[0], tupledArg_4[1], tupledArg_4[2], tupledArg_4[3]);
    }, List_1.zip4(patternInput[0], patternInput[1], bindNames, preAssignedVirtsPerBinding));
    const patternInput_1 = mapFold(function (tpenv_2, tupledArg_5) {
      return TcObjectExprBinding(cenv_1, env, tupledArg_2[1], tpenv_2, tupledArg_5[0], tupledArg_5[1]);
    }, tpenv_1, toList(zip(absSlotInfo, patternInput[0])), ofArray);
    const overrides = toList(map2(function (tupledArg_6, tupledArg_7) {
      const partialValInfo = TranslateTopValSynInfo(tupledArg_6[0].idRange, function (attrTgt_1, synAttribs) {
        return TcAttributes(cenv_1, env, attrTgt_1, synAttribs);
      }, tupledArg_7[1]);
      const patternInput_2 = tryDestForallTy(cenv_1.g, tupledArg_6[2]);
      const valInfo = TranslatePartialArity(patternInput_2[0], partialValInfo);
      return DispatchSlotChecking.GetObjectExprOverrideInfo(cenv_1.g, cenv_1.amap, tupledArg_2[1], tupledArg_6[0], tupledArg_6[1], tupledArg_6[2], valInfo, tupledArg_6[3], tupledArg_6[4]);
    }, patternInput_1[0], bindNameAndSynInfoPairs));
    return [[tupledArg_2[0], tupledArg_2[1], tupledArg_2[3].data[0], tupledArg_2[3].data[1], tupledArg_2[3].data[2], overrides], patternInput_1[1]];
  }, tpenv, allImpls, ofArray);
  return [patternInput_3[0], patternInput_3[1]];
}
export function CheckSuperType(cenv_1, typ, m) {
  if ((((typeEquiv(cenv_1.g, typ, cenv_1.g.system_Value_typ) ? true : typeEquiv(cenv_1.g, typ, cenv_1.g.system_Enum_typ)) ? true : typeEquiv(cenv_1.g, typ, cenv_1.g.system_Array_typ)) ? true : typeEquiv(cenv_1.g, typ, cenv_1.g.system_MulticastDelegate_typ)) ? true : typeEquiv(cenv_1.g, typ, cenv_1.g.system_Delegate_typ)) {
    error_1(new _Error(SR.tcPredefinedTypeCannotBeUsedAsSuperType(), m));
  }

  if (isErasedType(cenv_1.g, typ)) {
    errorR(new _Error(SR.tcCannotInheritFromErasedType(), m));
  }
}
export function TcObjectExpr(cenv_1, overallTy, env, tpenv, synObjTy, argopt, binds, extraImpls, mNewExpr, mWholeExpr) {
  const mObjTy = synObjTy.Range;
  const patternInput = TcType(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, synObjTy);
  const matchValue = tryDestAppTy(cenv_1.g, patternInput[0]);

  if (matchValue != null) {
    const isRecordTy = isRecdTy(cenv_1.g, patternInput[0]);

    if ((!isRecordTy ? !isInterfaceTy(cenv_1.g, patternInput[0]) : false) ? isSealedTy(cenv_1.g, patternInput[0]) : false) {
      errorR(new _Error(SR.tcCannotCreateExtensionOfSealedType(), mNewExpr));
    }

    CheckSuperType(cenv_1, patternInput[0], synObjTy.Range);
    let env_1;
    const eUngeneralizableItems = addFreeItemOfTy(patternInput[0], env.eUngeneralizableItems);
    env_1 = new TcEnv(env.eNameResEnv, eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
    const env_2 = EnterFamilyRegion(getValue(matchValue), env_1);

    if (isRecordTy ? true : (isFSharpObjModelTy(cenv_1.g, patternInput[0]) ? !isInterfaceTy(cenv_1.g, patternInput[0]) : false) ? argopt == null : false) {
      if (argopt != null) {
        error_1(new _Error(SR.tcNoArgumentsForRecordValue(), mWholeExpr));
      }

      if (!(extraImpls.tail == null)) {
        error_1(new _Error(SR.tcNoInterfaceImplementationForConstructionExpression(), mNewExpr));
      }

      if (isFSharpObjModelTy(cenv_1.g, patternInput[0]) ? GetCtorShapeCounter(env_2) !== 1 : false) {
        error_1(new _Error(SR.tcObjectConstructionCanOnlyBeUsedInClassTypes(), mNewExpr));
      }

      const fldsList = map_1(function (b) {
        const matchValue_1 = BindingNormalization.NormalizeBinding(new IsObjExprBinding(0), cenv_1, env_2, b);
        const $var192 = matchValue_1.data[4].tail == null ? matchValue_1.data[8].tag === 2 ? matchValue_1.data[8].data[0].tag === 1 ? [0, matchValue_1.data[8].data[1], matchValue_1.data[9].data[2]] : [1] : [1] : [1];

        switch ($var192[0]) {
          case 0:
            return [$var192[1].idText, $var192[2]];

          case 1:
            return error_1(new _Error(SR.tcOnlySimpleBindingsCanBeUsedInConstructionExpressions(), b.RangeOfBindingSansRhs));
        }
      }, binds);
      return TcRecordConstruction(cenv_1, overallTy, env_2, patternInput[1], null, patternInput[0], fldsList, mWholeExpr);
    } else {
      const item = ResultOrExceptionModule.ForceRaise(ResolveObjectConstructor(cenv_1.nameResolver, env_2.DisplayEnv, mObjTy, env_2.eAccessRights, patternInput[0]));

      if (isFSharpObjModelTy(cenv_1.g, patternInput[0]) ? GetCtorShapeCounter(env_2) === 1 : false) {
        error_1(new _Error(SR.tcObjectsMustBeInitializedWithObjectExpression(), mNewExpr));
      }

      const patternInput_2 = mapFold(function (tpenv_1, _arg29) {
        const patternInput_1 = TcType(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env_2, tpenv_1, _arg29.data[0]);

        if (!isInterfaceTy(cenv_1.g, patternInput_1[0])) {
          error_1(new _Error(SR.tcExpectedInterfaceType(), _arg29.data[2]));
        }

        if (isErasedType(cenv_1.g, patternInput_1[0])) {
          errorR(new _Error(SR.tcCannotInheritFromErasedType(), _arg29.data[2]));
        }

        return [[_arg29.data[2], patternInput_1[0], _arg29.data[1]], patternInput_1[1]];
      }, patternInput[1], extraImpls, ofArray);
      let realObjTy;

      if (isObjTy(cenv_1.g, patternInput[0]) ? !(patternInput_2[0].tail == null) : false) {
        const tupledArg = patternInput_2[0].head;
        realObjTy = p23(tupledArg[0], tupledArg[1], tupledArg[2]);
      } else {
        realObjTy = patternInput[0];
      }

      UnifyTypes(cenv_1, env_2, mWholeExpr, overallTy, realObjTy);
      let patternInput_4;
      const matchValue_2 = [item, argopt];

      if (matchValue_2[0].tag === 11) {
        if (matchValue_2[1] == null) {
          patternInput_4 = error_1(new _Error(SR.tcConstructorRequiresArguments(), mNewExpr));
        } else {
          const meths = map_1(function (minfo) {
            return [minfo, null];
          }, matchValue_2[0].data[1]);
          const afterResolution = ForNewConstructors(cenv_1.tcSink, env_2, synObjTy.Range, matchValue_2[0].data[0], matchValue_2[0].data[1]);
          const patternInput_3 = TcMethodApplicationThen(cenv_1, env_2, patternInput[0], null, patternInput_2[1], null, new List(), mWholeExpr, mObjTy, matchValue_2[0].data[0], env_2.eAccessRights, new Mutates(1), false, meths, afterResolution, new ValUseFlag(2), ofArray([getValue(matchValue_2[1])[0]]), 0, new List());
          const baseIdOpt = getValue(matchValue_2[1])[1] != null ? getValue(getValue(matchValue_2[1])[1]) : ident("base", mObjTy);
          patternInput_4 = [patternInput_3[0], baseIdOpt, patternInput_3[1]];
        }
      } else if (matchValue_2[0].tag === 12) {
        if (matchValue_2[1] != null) {
          patternInput_4 = error_1(new _Error(SR.tcConstructorForInterfacesDoNotTakeArguments(), mNewExpr));
        } else {
          UnifyTypes(cenv_1, env_2, mWholeExpr, patternInput[0], matchValue_2[0].data);
          const expr = BuildObjCtorCall(cenv_1.g, mWholeExpr);
          patternInput_4 = [expr, null, patternInput_2[1]];
        }
      } else {
        patternInput_4 = error_1(new _Error(SR.tcNewRequiresObjectConstructor(), mNewExpr));
      }

      const baseValOpt = MakeAndPublishBaseVal(cenv_1, env_2, patternInput_4[1], patternInput[0]);
      const env_4 = foldBack(function (v, env_3) {
        return AddLocalVal(cenv_1.tcSink, mNewExpr, v, env_3);
      }, defaultArg(baseValOpt, [], $var193 => [$var193]), env_2);
      const impls = new List([mWholeExpr, patternInput[0], binds], patternInput_2[0]);
      const patternInput_5 = ComputeObjectExprOverrides(cenv_1, env_4, patternInput_4[2], impls);
      iterate(function (tupledArg_1) {
        const overrideSpecs = map_1(function (tuple) {
          return tuple[0];
        }, tupledArg_1[5]);
        DispatchSlotChecking.CheckOverridesAreAllUsedOnce(env_4.DisplayEnv, cenv_1.g, cenv_1.amap, true, tupledArg_1[1], tupledArg_1[3], tupledArg_1[4], overrideSpecs);
        DispatchSlotChecking.CheckDispatchSlotsAreImplemented(env_4.DisplayEnv, cenv_1.g, cenv_1.amap, tupledArg_1[0], env_4.NameEnv, cenv_1.tcSink, false, tupledArg_1[1], tupledArg_1[2], tupledArg_1[4], overrideSpecs);
      }, patternInput_5[0]);
      const allTypeImpls = map_1(function (tupledArg_2) {
        const overrides_ = toList(delay(function () {
          return collect_1(function (overrideMeth) {
            const thisVal = overrideMeth[1][1];
            const mtps = overrideMeth[0].data[3][0];
            const methodVars = overrideMeth[1][2];
            const isFakeEventProperty = overrideMeth[0].data[6];
            const id = overrideMeth[0].data[2];
            const bindingBody = overrideMeth[1][4];
            const bindingAttribs = overrideMeth[1][3];

            if (!isFakeEventProperty) {
              const searchForOverride = tryPick(function (_arg30) {
                return DispatchSlotChecking.IsExactMatch(cenv_1.g, cenv_1.amap, tupledArg_2[0], _arg30.data[0], overrideMeth[0]) ? _arg30.data[0] : null;
              }, NameMultiMapModule.find(id.idText, tupledArg_2[3]));
              const overridden = searchForOverride == null ? error_1(new _Error(SR.tcAtLeastOneOverrideIsInvalid(), synObjTy.Range)) : getValue(searchForOverride);
              return singleton(new ObjExprMethod(0, [overridden.GetSlotSig(cenv_1.amap, tupledArg_2[0]), bindingAttribs, mtps, new List(ofArray([thisVal]), methodVars), bindingBody, id.idRange]));
            } else {
              return empty();
            }
          }, tupledArg_2[5]);
        }));
        return [tupledArg_2[1], overrides_];
      }, patternInput_5[0]);
      const patternInput_6 = allTypeImpls.head;
      const extraImpls_1 = allTypeImpls.tail;
      const expr_1 = mkObjExpr(patternInput_6[0], baseValOpt, patternInput_4[0], patternInput_6[1], extraImpls_1, mWholeExpr);
      const expr_2 = mkCoerceIfNeeded(cenv_1.g, realObjTy, patternInput_6[0], expr_1);
      return [expr_2, patternInput_5[1]];
    }
  } else {
    return error_1(new _Error(SR.tcNewMustBeUsedWithNamedType(), mNewExpr));
  }
}
export function TcConstStringExpr(cenv_1, overallTy, env, m, tpenv, s) {
  if (AddCxTypeEqualsTypeUndoIfFailed(env.DisplayEnv, cenv_1.css, m, overallTy, cenv_1.g.string_ty)) {
    return [mkString(cenv_1.g, m, s), tpenv];
  } else {
    const aty = NewInferenceType();
    const bty = NewInferenceType();
    const cty = NewInferenceType();
    const dty = NewInferenceType();
    const ety = NewInferenceType();
    const ty_ = mkPrintfFormatTy(cenv_1.g, aty, bty, cty, dty, ety);

    if (!isObjTy(cenv_1.g, overallTy) ? AddCxTypeMustSubsumeTypeUndoIfFailed(env.DisplayEnv, cenv_1.css, m, overallTy, ty_) : false) {
      let source;
      const matchValue = cenv_1.tcSink.CurrentSink;

      if (matchValue != null) {
        source = getValue(matchValue).CurrentSource;
      } else {
        source = null;
      }

      const normalizedString = replace(replace(s, "\r\n", "\n"), "\r", "\n");
      let patternInput;

      try {
        patternInput = ParseFormatString(m, cenv_1.g, source, normalizedString, bty, cty, dty);
      } catch (matchValue_1) {
        const activePatternResult41797 = Microsoft.FSharp.Core.Operators["|Failure|_|"](matchValue_1);

        if (activePatternResult41797 != null) {
          patternInput = error_1(new _Error(SR.tcUnableToParseFormatString(getValue(activePatternResult41797)), m));
        } else {
          throw matchValue_1;
        }
      }

      const ety_ = patternInput[0][1];
      const aty_ = patternInput[0][0];
      const matchValue_2 = cenv_1.tcSink.CurrentSink;

      if (matchValue_2 != null) {
        for (let forLoopVar of patternInput[1]) {
          getValue(matchValue_2).NotifyFormatSpecifierLocation(forLoopVar[0], forLoopVar[1]);
        }
      }

      UnifyTypes(cenv_1, env, m, aty, aty_);
      UnifyTypes(cenv_1, env, m, ety, ety_);
      return [mkCallNewFormat(cenv_1.g, m, aty, bty, cty, dty, ety, mkString(cenv_1.g, m, s)), tpenv];
    } else {
      UnifyTypes(cenv_1, env, m, overallTy, cenv_1.g.string_ty);
      return [mkString(cenv_1.g, m, s), tpenv];
    }
  }
}
export function TcConstExpr(cenv_1, overallTy, env, m, tpenv, c) {
  if (c.tag === 18) {
    UnifyTypes(cenv_1, env, c.data[1], overallTy, mkByteArrayTy(cenv_1.g));
    return [new Expr(11, [new TOp(4, c.data[0]), new List(), new List(), c.data[1]]), tpenv];
  } else if (c.tag === 19) {
    UnifyTypes(cenv_1, env, m, overallTy, mkArrayType(cenv_1.g, cenv_1.g.uint16_ty));
    return [new Expr(11, [new TOp(5, c.data), new List(), new List(), m]), tpenv];
  } else if (c.tag === 16) {
    let expr_1;
    const modName = "NumericLiteral" + c.data[1];
    const matchValue = ResolveLongIndentAsModuleOrNamespace(cenv_1.tcSink, new ResultCollectionSettings(1), cenv_1.amap, m, true, new FullyQualifiedFlag(1), env.eNameResEnv, env.eAccessRights, ident(modName, m), new List(), false);
    const $var194 = matchValue.tag === 1 ? [0] : matchValue.data.tail != null ? [1, matchValue.data.head[1]] : [0];

    switch ($var194[0]) {
      case 0:
        expr_1 = error_1(new _Error(SR.tcNumericLiteralRequiresModule(modName), m));
        break;

      case 1:
        let expr;

        try {
          const matchValue_1 = parse(c.data[0]) | 0;

          if (matchValue_1 === 0) {
            expr = new SynExpr(20, [0, false, mkSynLidGet(m, ofArray([modName]), "FromZero"), new SynExpr(2, [new SynConst(0), m]), m]);
          } else if (matchValue_1 === 1) {
            expr = new SynExpr(20, [0, false, mkSynLidGet(m, ofArray([modName]), "FromOne"), new SynExpr(2, [new SynConst(0), m]), m]);
          } else {
            expr = new SynExpr(20, [0, false, mkSynLidGet(m, ofArray([modName]), "FromInt32"), new SynExpr(2, [new SynConst(6, matchValue_1), m]), m]);
          }
        } catch (matchValue_2) {
          try {
            const i64 = fromString(c.data[0], false);
            expr = new SynExpr(20, [0, false, mkSynLidGet(m, ofArray([modName]), "FromInt64"), new SynExpr(2, [new SynConst(8, i64), m]), m]);
          } catch (matchValue_3) {
            expr = new SynExpr(20, [0, false, mkSynLidGet(m, ofArray([modName]), "FromString"), new SynExpr(2, [new SynConst(17, [c.data[0], m]), m]), m]);
          }
        }

        if (c.data[1] !== "I") {
          expr_1 = expr;
        } else {
          const matchValue_4 = ccuOfTyconRef($var194[1]);
          const $var195 = matchValue_4 != null ? ccuEq(getValue(matchValue_4), cenv_1.g.fslibCcu) ? [0, getValue(matchValue_4)] : [1] : [1];

          switch ($var195[0]) {
            case 0:
              expr_1 = new SynExpr(3, [expr, new SynType(0, new LongIdentWithDots(0, [pathToSynLid(m, ofArray(["System", "Numerics", "BigInteger"])), new List()])), m]);
              break;

            case 1:
              expr_1 = expr;
              break;
          }
        }

        break;
    }

    return TcExpr(cenv_1, overallTy, env, tpenv, expr_1);
  } else {
    const c_ = TcConst(cenv_1, overallTy, m, env, c);
    return [new Expr(0, [c_, m, overallTy]), tpenv];
  }
}
export function TcAssertExpr(cenv_1, overallTy, env, m, tpenv, x) {
  const synm = m.MakeSynthetic();
  const callDiagnosticsExpr = new SynExpr(20, [0, false, mkSynLidGet(synm, ofArray(["System", "Diagnostics", "Debug"]), "Assert"), new SynExpr(0, [x, range0, null, synm]), synm]);
  return TcExpr(cenv_1, overallTy, env, tpenv, callDiagnosticsExpr);
}
export function TcRecdExpr(cenv_1, overallTy, env, tpenv, inherits, optOrigExpr, flds, mWholeExpr) {
  var realSuperTyp;
  const requiresCtor = GetCtorShapeCounter(env) === 1;
  const haveCtor = inherits != null;
  let patternInput_2;

  if (optOrigExpr != null) {
    const origExpr = getValue(optOrigExpr)[0];

    if (inherits == null) {
      const patternInput = TcExpr(cenv_1, overallTy, env, tpenv, origExpr);
      const patternInput_1 = mkCompGenLocal(mWholeExpr, "inputRecord", overallTy);
      patternInput_2 = [[patternInput[0], patternInput_1[0], patternInput_1[1]], patternInput[1]];
    } else {
      const mInherits = getValue(inherits)[2];
      patternInput_2 = error_1(new _Error(SR.tcInvalidRecordConstruction(), mInherits));
    }
  } else {
    patternInput_2 = [null, tpenv];
  }

  const hasOrigExpr = patternInput_2[0] != null;
  let fldsList;
  const flds_1 = toList(delay(function () {
    return collect_1(function (matchValue) {
      const lidwd = matchValue[0][0];
      const isOk = matchValue[0][1];
      return append_1(!isOk ? (() => {
        throw new ReportedError(null);
        return empty();
      })() : empty(), delay(function () {
        return singleton([List_1.frontAndBack(lidwd.Lid), matchValue[1]]);
      }));
    }, flds);
  }));

  if (flds_1.tail == null) {
    fldsList = new List();
  } else {
    const patternInput_3 = BuildFieldMap(cenv_1, env, hasOrigExpr, overallTy, flds_1, mWholeExpr);
    const patternInput_4 = infoOfTyconRef(mWholeExpr, patternInput_3[0]);
    UnifyTypes(cenv_1, env, mWholeExpr, overallTy, patternInput_4[3]);
    fldsList = toList(delay(function () {
      return collect_1(function (matchValue_1) {
        return matchValue_1[1] == null ? empty() : singleton([matchValue_1[0], getValue(matchValue_1[1])]);
      }, patternInput_3[2]);
    }));
  }

  if (hasOrigExpr ? !isRecdTy(cenv_1.g, overallTy) : false) {
    errorR(new _Error(SR.tcExpressionFormRequiresRecordTypes(), mWholeExpr));
  }

  if (requiresCtor ? true : haveCtor) {
    if (!isFSharpObjModelTy(cenv_1.g, overallTy)) {
      error_1(new _Error(SR.tcInheritedTypeIsNotObjectModelType(), mWholeExpr));
    }

    if (!requiresCtor) {
      errorR(new _Error(SR.tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes(), mWholeExpr));
    }
  } else {
    if (flds.tail == null) {
      const errorInfo = hasOrigExpr ? SR.tcEmptyCopyAndUpdateRecordInvalid() : SR.tcEmptyRecordInvalid();
      error_1(new _Error(errorInfo, mWholeExpr));
    }

    if (isFSharpObjModelTy(cenv_1.g, overallTy)) {
      errorR(new _Error(SR.tcTypeIsNotARecordTypeNeedConstructor(), mWholeExpr));
    } else if (!isRecdTy(cenv_1.g, overallTy)) {
      errorR(new _Error(SR.tcTypeIsNotARecordType(), mWholeExpr));
    }
  }

  let patternInput_7;
  const matchValue_2 = [inherits, GetSuperTypeOfType(cenv_1.g, cenv_1.amap, mWholeExpr, overallTy)];
  const $var196 = matchValue_2[0] == null ? matchValue_2[1] != null ? (realSuperTyp = getValue(matchValue_2[1]), requiresCtor) ? [1, getValue(matchValue_2[1])] : [2] : [2] : matchValue_2[1] != null ? [0, getValue(matchValue_2[0])[1], getValue(matchValue_2[0])[2], getValue(matchValue_2[1]), getValue(matchValue_2[0])[0]] : [2];

  switch ($var196[0]) {
    case 0:
      const patternInput_5 = TcExpr(cenv_1, $var196[3], env, patternInput_2[1], new SynExpr(8, [true, $var196[4], $var196[1], $var196[2]]));
      patternInput_7 = [patternInput_5[0], patternInput_5[1]];
      break;

    case 1:
      const patternInput_6 = TcNewExpr(cenv_1, env, patternInput_2[1], $var196[1], null, true, new SynExpr(2, [new SynConst(0), mWholeExpr]), mWholeExpr);
      patternInput_7 = [patternInput_6[0], patternInput_6[1]];
      break;

    case 2:
      if (matchValue_2[0] == null) {
        patternInput_7 = [null, patternInput_2[1]];
      } else if (matchValue_2[1] == null) {
        errorR(new InternalError("Unexpected failure in getting super type", mWholeExpr));
        patternInput_7 = [null, patternInput_2[1]];
      } else {
        throw new Error("C:/projects/fcs/src/fsharp/TypeChecker.fs", 6927, 14);
      }

      break;
  }

  const patternInput_8 = TcRecordConstruction(cenv_1, overallTy, env, patternInput_7[1], patternInput_2[0], overallTy, fldsList, mWholeExpr);
  const expr = isStructTy(cenv_1.g, overallTy) ? patternInput_8[0] : patternInput_7[0] == null ? patternInput_8[0] : mkCompGenSequential(mWholeExpr, getValue(patternInput_7[0]), patternInput_8[0]);
  return [expr, patternInput_8[1]];
}
export function TcForEachExpr(cenv_1, overallTy, env, tpenv, pat, enumSynExpr, bodySynExpr, mWholeExpr, spForLoop) {
  var vf;
  var tyarg;
  var startExpr;
  var finishExpr;
  var cleanupE;
  var spBind;
  UnifyTypes(cenv_1, env, mWholeExpr, overallTy, cenv_1.g.unit_ty);
  const mPat = pat.Range;
  const mEnumExpr = enumSynExpr.Range;
  const mForLoopStart = spForLoop.tag === 1 ? mEnumExpr : spForLoop.data;
  const patternInput = TcExprOfUnknownType(cenv_1, env, tpenv, enumSynExpr);
  let patternInput_5;
  const $var197 = patternInput[0].tag === 5 ? patternInput[0].data[0].tag === 1 ? patternInput[0].data[2].tail != null ? patternInput[0].data[2].tail.tail == null ? patternInput[0].data[3].tail != null ? patternInput[0].data[3].tail.tail != null ? patternInput[0].data[3].tail.tail.tail == null ? (vf = patternInput[0].data[0].data[0], tyarg = patternInput[0].data[2].head, startExpr = patternInput[0].data[3].head, finishExpr = patternInput[0].data[3].tail.head, valRefEq(cenv_1.g, vf, cenv_1.g.range_op_vref) ? typeEquiv(cenv_1.g, tyarg, cenv_1.g.int_ty) : false) ? [0, patternInput[0].data[3].tail.head, patternInput[0].data[3].head, patternInput[0].data[2].head, patternInput[0].data[0].data[0]] : [1] : [1] : [1] : [1] : [1] : [1] : [1] : [1];

  switch ($var197[0]) {
    case 0:
      patternInput_5 = [cenv_1.g.int32_ty, function (_arg33, x) {
        return x;
      }, function (x_1) {
        return x_1;
      }, new Choice(0, [$var197[2], $var197[1]])];
      break;

    case 1:
      if (isArray1DTy(cenv_1.g, patternInput[1])) {
        const patternInput_1 = mkCompGenLocal(mEnumExpr, "arr", patternInput[1]);
        const patternInput_2 = mkCompGenLocal(mPat, "idx", cenv_1.g.int32_ty);
        const elemTy = destArrayTy(cenv_1.g, patternInput[1]);

        const bodyExprFixup = function (elemVar, bodyExpr) {
          return mkCompGenLet(mForLoopStart, elemVar, mkLdelem(cenv_1.g, mForLoopStart, elemTy, patternInput_1[1], patternInput_2[1]), bodyExpr);
        };

        const overallExprFixup = function (overallExpr) {
          return mkCompGenLet(mForLoopStart, patternInput_1[0], patternInput[0], overallExpr);
        };

        patternInput_5 = [elemTy, bodyExprFixup, overallExprFixup, new Choice(1, [patternInput_2[0], mkZero(cenv_1.g, mForLoopStart), mkDecr(cenv_1.g, mForLoopStart, mkLdlen(cenv_1.g, mForLoopStart, patternInput_1[1]))])];
      } else {
        const patternInput_3 = mkCompGenLocal(mEnumExpr, "inputSequence", patternInput[1]);
        const patternInput_4 = AnalyzeArbitraryExprAsEnumerable(cenv_1, env, true, mEnumExpr, patternInput[1], patternInput_3[1]);
        patternInput_5 = [patternInput_4[3], function (_arg34, x_2) {
          return x_2;
        }, function (x_3) {
          return x_3;
        }, new Choice(2, [patternInput_3[0], patternInput_4[0], patternInput_4[1], patternInput_4[4], patternInput_4[5], patternInput_4[6], patternInput_4[8]])];
      }

      break;
  }

  const patternInput_6 = TcMatchPattern(cenv_1, patternInput_5[0], env, patternInput[2], pat, null);
  let patternInput_8;
  const $var198 = patternInput_6[0].tag === 2 ? patternInput_6[0].data[1].data[1].data[0].tail == null ? [0, patternInput_6[0].data[0], patternInput_6[0].data[1].data[0]] : [1] : [1];

  switch ($var198[0]) {
    case 0:
      patternInput_8 = [$var198[2], $var198[1]];
      break;

    case 1:
      const patternInput_7 = mkCompGenLocal(patternInput_6[0].Range, "forLoopVar", patternInput_5[0]);
      patternInput_8 = [patternInput_7[0], patternInput_6[0]];
      break;
  }

  const patternInput_9 = TcStmt(cenv_1, patternInput_6[3], patternInput_6[4], bodySynExpr);
  let bodyExpr_1;
  const valsDefinedByMatching = ListSet.remove(function (lv1, lv2) {
    return valEq(lv1, lv2);
  }, patternInput_8[0], patternInput_6[2]);
  bodyExpr_1 = CompilePatternForMatch(cenv_1, env, enumSynExpr.Range, patternInput_8[1].Range, false, new ActionOnFailure(1), patternInput_8[0], new List(), ofArray([new TypedMatchClause(0, [patternInput_8[1], null, new DecisionTreeTarget(0, [valsDefinedByMatching, patternInput_9[0], new SequencePointInfoForTarget(0)]), mForLoopStart])]), patternInput_5[0], overallTy);
  const bodyExpr_2 = patternInput_5[1](patternInput_8[0], bodyExpr_1);
  let overallExpr_1;

  if (patternInput_5[3].tag === 1) {
    const startExpr_1 = patternInput_5[3].data[1];
    const idxVar = patternInput_5[3].data[0];
    const finishExpr_1 = patternInput_5[3].data[2];
    overallExpr_1 = mkFastForLoop(cenv_1.g, spForLoop, mWholeExpr, idxVar, startExpr_1, true, finishExpr_1, bodyExpr_2);
  } else if (patternInput_5[3].tag === 2) {
    const guardExpr = patternInput_5[3].data[5];
    const getEnumExpr = patternInput_5[3].data[3];
    const enumeratorVar = patternInput_5[3].data[1];
    const enumerableVar = patternInput_5[3].data[0];
    const currentExpr = patternInput_5[3].data[6];
    overallExpr_1 = mkCompGenLet(mForLoopStart, enumerableVar, patternInput[0], (cleanupE = BuildDisposableCleanup(cenv_1, env, mWholeExpr, enumeratorVar), spBind = spForLoop.tag === 1 ? new SequencePointInfoForBinding(3) : new SequencePointInfoForBinding(0, spForLoop.data), mkLet(spBind, mForLoopStart, enumeratorVar, getEnumExpr, mkTryFinally(cenv_1.g, mkWhile(cenv_1.g, new SequencePointInfoForWhileLoop(1), new SpecialWhileLoopMarker(1), guardExpr, mkCompGenLet(mForLoopStart, patternInput_8[0], currentExpr, bodyExpr_2), mForLoopStart), cleanupE, mForLoopStart, cenv_1.g.unit_ty, new SequencePointInfoForTry(2), new SequencePointInfoForFinally(1)))));
  } else {
    const startExpr_2 = patternInput_5[3].data[0];
    const finishExpr_2 = patternInput_5[3].data[1];
    overallExpr_1 = mkFastForLoop(cenv_1.g, spForLoop, mWholeExpr, patternInput_8[0], startExpr_2, true, finishExpr_2, bodyExpr_2);
  }

  const overallExpr_2 = patternInput_5[2](overallExpr_1);
  return [overallExpr_2, patternInput_9[1]];
}
export function TcQuotationExpr(cenv_1, overallTy, env, tpenv, _oper, raw, ast, isFromQueryExpression, m) {
  const astTy = NewInferenceType();
  UnifyTypes(cenv_1, env, m, overallTy, raw ? mkRawQuotedExprTy(cenv_1.g) : mkQuotedExprTy(cenv_1.g, astTy));
  const patternInput = TcExpr(cenv_1, astTy, env, tpenv, ast);
  const expr = new Expr(12, [patternInput[0], {
    contents: null
  }, isFromQueryExpression, m, overallTy]);
  const expr_1 = raw ? mkCoerceExpr(expr, mkRawQuotedExprTy(cenv_1.g), m, tyOfExpr(cenv_1.g, expr)) : expr;
  return [expr_1, patternInput[1]];
}
export function TcComputationOrSequenceExpression(cenv_1, env, overallTy, m, interpValOpt, tpenv, comp) {
  if (interpValOpt == null) {
    return TcSequenceExpression(cenv_1, env, tpenv, comp, overallTy, m);
  } else {
    const interpExpr = getValue(interpValOpt)[0];
    const builderTy = getValue(interpValOpt)[1];
    return TcComputationExpression(cenv_1, env, overallTy, m, interpExpr, builderTy, tpenv, comp);
  }
}
export function IgnoreAttribute(_arg3) {
  return null;
}
export function TcComputationExpression(cenv_1, env, overallTy, mWhole, interpExpr, builderTy, tpenv, comp) {
  const mkSynDelay2 = function (e) {
    var copyOfStruct;
    return mkSynDelay((copyOfStruct = e.Range, copyOfStruct.MakeSynthetic()), e);
  };

  const builderValName = CompilerGeneratedName("builder");
  const mBuilderVal = Expr_get_Range.bind(interpExpr)();
  let isQuery;

  if (interpExpr.tag === 1) {
    const item = new Item(16, [interpExpr.data[0].DisplayName, interpExpr.data[0]]);
    CallNameResolutionSink(cenv_1.tcSink, interpExpr.data[2], env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, env.eAccessRights);
    isQuery = valRefEq(cenv_1.g, interpExpr.data[0], cenv_1.g.query_value_vref);
  } else {
    isQuery = false;
  }

  const mkSynCall = function (nm, m, args) {
    const m_1 = m.MakeSynthetic();
    const args_1 = args.tail != null ? args.tail.tail == null ? new SynExpr(0, [new SynExpr(0, [args.head, range0, null, m_1]), range0, null, m_1]) : new SynExpr(0, [new SynExpr(4, [args, new List(), m_1]), range0, null, m_1]) : new SynExpr(2, [new SynConst(0), m_1]);
    const builderVal = mkSynIdGet(m_1, builderValName);
    return mkSynApp1(new SynExpr(31, [builderVal, range0, new LongIdentWithDots(0, [ofArray([mkSynId(m_1, nm)]), new List()]), m_1]), args_1, m_1);
  };

  const sourceMethInfo = TryFindIntrinsicOrExtensionMethInfo(cenv_1, env, mBuilderVal, env.eAccessRights, "Source", builderTy);

  const mkSourceExpr = function (callExpr) {
    if (sourceMethInfo.tail == null) {
      return callExpr;
    } else {
      return mkSynCall("Source", callExpr.Range, ofArray([callExpr]));
    }
  };

  let isAutoQuote;
  const matchValue = TryFindIntrinsicOrExtensionMethInfo(cenv_1, env, mBuilderVal, env.eAccessRights, "Quote", builderTy);

  if (matchValue.tail == null) {
    isAutoQuote = false;
  } else {
    isAutoQuote = true;
  }

  const customOperationMethods = choose_1(function (methInfo) {
    if (!IsMethInfoAccessible(cenv_1.amap, mBuilderVal, env.eAccessRights, methInfo)) {
      return null;
    } else {
      const nameSearch = TryBindMethInfoAttribute(cenv_1.g, mBuilderVal, cenv_1.g.attrib_CustomOperationAttribute, methInfo, function (arg00_) {
        return IgnoreAttribute(arg00_);
      }, function (_arg18) {
        let $var199;

        if (_arg18.data[2].tail != null) {
          const activePatternResult41869 = _AttribStringArg___(_arg18.data[2].head);

          if (activePatternResult41869 != null) {
            if (_arg18.data[2].tail.tail == null) {
              $var199 = [0, getValue(activePatternResult41869)];
            } else {
              $var199 = [1];
            }
          } else {
            $var199 = [1];
          }
        } else {
          $var199 = [1];
        }

        switch ($var199[0]) {
          case 0:
            return $var199[1];

          case 1:
            return null;
        }
      }, function (arg00__1) {
        return IgnoreAttribute(arg00__1);
      });

      if (nameSearch != null) {
        const joinConditionWord = TryBindMethInfoAttribute(cenv_1.g, mBuilderVal, cenv_1.g.attrib_CustomOperationAttribute, methInfo, function (arg00__2) {
          return IgnoreAttribute(arg00__2);
        }, function (_arg19) {
          let $var200;

          const activePatternResult41872 = _ExtractAttribNamedArg___("JoinConditionWord", _arg19.data[3]);

          if (activePatternResult41872 != null) {
            const activePatternResult41873 = _AttribStringArg___(getValue(activePatternResult41872));

            if (activePatternResult41873 != null) {
              $var200 = [0, getValue(activePatternResult41873)];
            } else {
              $var200 = [1];
            }
          } else {
            $var200 = [1];
          }

          switch ($var200[0]) {
            case 0:
              return $var200[1];

            case 1:
              return null;
          }
        }, function (arg00__3) {
          return IgnoreAttribute(arg00__3);
        });

        const flagSearch = function (propName) {
          return TryBindMethInfoAttribute(cenv_1.g, mBuilderVal, cenv_1.g.attrib_CustomOperationAttribute, methInfo, function (arg00__4) {
            return IgnoreAttribute(arg00__4);
          }, function (_arg20) {
            let $var201;

            const activePatternResult41876 = _ExtractAttribNamedArg___(propName, _arg20.data[3]);

            if (activePatternResult41876 != null) {
              const activePatternResult41877 = _AttribBoolArg___(getValue(activePatternResult41876));

              if (activePatternResult41877 != null) {
                $var201 = [0, getValue(activePatternResult41877)];
              } else {
                $var201 = [1];
              }
            } else {
              $var201 = [1];
            }

            switch ($var201[0]) {
              case 0:
                return $var201[1];

              case 1:
                return null;
            }
          }, function (arg00__5) {
            return IgnoreAttribute(arg00__5);
          });
        };

        const maintainsVarSpaceUsingBind = defaultArg(flagSearch("MaintainsVariableSpaceUsingBind"), false);
        const maintainsVarSpace = defaultArg(flagSearch("MaintainsVariableSpace"), false);
        const allowInto = defaultArg(flagSearch("AllowIntoPattern"), false);
        const isLikeZip = defaultArg(flagSearch("IsLikeZip"), false);
        const isLikeJoin = defaultArg(flagSearch("IsLikeJoin"), false);
        const isLikeGroupJoin = defaultArg(flagSearch("IsLikeGroupJoin"), false);
        return [getValue(nameSearch), maintainsVarSpaceUsingBind, maintainsVarSpace, allowInto, isLikeZip, isLikeJoin, isLikeGroupJoin, joinConditionWord, methInfo];
      } else {
        return null;
      }
    }
  }, AllMethInfosOfTypeInScope(cenv_1.infoReader, env.NameEnv, null, env.eAccessRights, new FindMemberFlag(0), mBuilderVal, builderTy));
  const customOperationMethodsIndexedByKeyword = new Map(map_2(function (tupledArg) {
    return [tupledArg[0], toList(tupledArg[1])];
  }, groupBy(function (tupledArg_1) {
    return tupledArg_1[0];
  }, customOperationMethods)));
  const customOperationMethodsIndexedByMethodName = new Map(map_2(function (tupledArg_2) {
    return [tupledArg_2[0], toList(tupledArg_2[1])];
  }, groupBy(function (tupledArg_3) {
    return tupledArg_3[8].LogicalName;
  }, customOperationMethods)));

  const tryGetDataForCustomOperation = function (nm_1) {
    const matchValue_1 = tryGetValue(customOperationMethodsIndexedByKeyword, nm_1.idText, null);
    const $var202 = matchValue_1[0] ? matchValue_1[1].tail != null ? matchValue_1[1].tail.tail == null ? [0, matchValue_1[1].head] : [1, matchValue_1[1].head] : [2] : [2];

    switch ($var202[0]) {
      case 0:
        if (((($var202[1][1] ? $var202[1][2] : false) ? true : $var202[1][4] ? $var202[1][5] : false) ? true : $var202[1][4] ? $var202[1][6] : false) ? true : $var202[1][5] ? $var202[1][6] : false) {
          errorR(new _Error(SR.tcCustomOperationInvalid($var202[1][0]), nm_1.idRange));
        }

        const matchValue_2 = tryGetValue(customOperationMethodsIndexedByMethodName, $var202[1][8].LogicalName, null);
        const $var203 = matchValue_2[0] ? matchValue_2[1].tail != null ? matchValue_2[1].tail.tail == null ? [0] : [1] : [1] : [1];

        switch ($var203[0]) {
          case 0:
            break;

          case 1:
            errorR(new _Error(SR.tcCustomOperationMayNotBeOverloaded(nm_1.idText), nm_1.idRange));
            break;
        }

        return $var202[1];

      case 1:
        errorR(new _Error(SR.tcCustomOperationMayNotBeOverloaded(nm_1.idText), nm_1.idRange));
        return $var202[1];

      case 2:
        return null;
    }
  };

  const hasCustomOperations = function () {
    return !(customOperationMethods.tail == null);
  };

  const isCustomOperation = function (nm_2) {
    return tryGetDataForCustomOperation(nm_2) != null;
  };

  const customOperationMaintainsVarSpace = function (nm_3) {
    const matchValue_3 = tryGetDataForCustomOperation(nm_3);

    if (matchValue_3 != null) {
      const maintainsVarSpace_1 = getValue(matchValue_3)[2];
      const _nm = getValue(matchValue_3)[0];
      const _methInfo = getValue(matchValue_3)[8];
      const _maintainsVarSpaceUsingBind = getValue(matchValue_3)[1];
      const _joinConditionWord = getValue(matchValue_3)[7];
      const _isLikeZip = getValue(matchValue_3)[4];
      const _isLikeJoin = getValue(matchValue_3)[5];
      const _isLikeGroupJoin = getValue(matchValue_3)[6];
      const _allowInto = getValue(matchValue_3)[3];
      return maintainsVarSpace_1;
    } else {
      return false;
    }
  };

  const customOperationMaintainsVarSpaceUsingBind = function (nm_4) {
    const matchValue_4 = tryGetDataForCustomOperation(nm_4);

    if (matchValue_4 != null) {
      const maintainsVarSpaceUsingBind_1 = getValue(matchValue_4)[1];
      const _nm_1 = getValue(matchValue_4)[0];
      const _methInfo_1 = getValue(matchValue_4)[8];
      const _maintainsVarSpace = getValue(matchValue_4)[2];
      const _joinConditionWord_1 = getValue(matchValue_4)[7];
      const _isLikeZip_1 = getValue(matchValue_4)[4];
      const _isLikeJoin_1 = getValue(matchValue_4)[5];
      const _isLikeGroupJoin_1 = getValue(matchValue_4)[6];
      const _allowInto_1 = getValue(matchValue_4)[3];
      return maintainsVarSpaceUsingBind_1;
    } else {
      return false;
    }
  };

  const customOperationIsLikeZip = function (nm_5) {
    const matchValue_5 = tryGetDataForCustomOperation(nm_5);

    if (matchValue_5 != null) {
      const isLikeZip_1 = getValue(matchValue_5)[4];
      const _nm_2 = getValue(matchValue_5)[0];
      const _methInfo_2 = getValue(matchValue_5)[8];
      const _maintainsVarSpaceUsingBind_1 = getValue(matchValue_5)[1];
      const _maintainsVarSpace_1 = getValue(matchValue_5)[2];
      const _joinConditionWord_2 = getValue(matchValue_5)[7];
      const _isLikeJoin_2 = getValue(matchValue_5)[5];
      const _isLikeGroupJoin_2 = getValue(matchValue_5)[6];
      const _allowInto_2 = getValue(matchValue_5)[3];
      return isLikeZip_1;
    } else {
      return false;
    }
  };

  const customOperationIsLikeJoin = function (nm_6) {
    const matchValue_6 = tryGetDataForCustomOperation(nm_6);

    if (matchValue_6 != null) {
      const isLikeJoin_1 = getValue(matchValue_6)[5];
      const _nm_3 = getValue(matchValue_6)[0];
      const _methInfo_3 = getValue(matchValue_6)[8];
      const _maintainsVarSpaceUsingBind_2 = getValue(matchValue_6)[1];
      const _maintainsVarSpace_2 = getValue(matchValue_6)[2];
      const _joinConditionWord_3 = getValue(matchValue_6)[7];
      const _isLikeZip_2 = getValue(matchValue_6)[4];
      const _isLikeGroupJoin_3 = getValue(matchValue_6)[6];
      const _allowInto_3 = getValue(matchValue_6)[3];
      return isLikeJoin_1;
    } else {
      return false;
    }
  };

  const customOperationIsLikeGroupJoin = function (nm_7) {
    const matchValue_7 = tryGetDataForCustomOperation(nm_7);

    if (matchValue_7 != null) {
      const isLikeGroupJoin_1 = getValue(matchValue_7)[6];
      const _nm_4 = getValue(matchValue_7)[0];
      const _methInfo_4 = getValue(matchValue_7)[8];
      const _maintainsVarSpaceUsingBind_3 = getValue(matchValue_7)[1];
      const _maintainsVarSpace_3 = getValue(matchValue_7)[2];
      const _joinConditionWord_4 = getValue(matchValue_7)[7];
      const _isLikeZip_3 = getValue(matchValue_7)[4];
      const _isLikeJoin_3 = getValue(matchValue_7)[5];
      const _allowInto_4 = getValue(matchValue_7)[3];
      return isLikeGroupJoin_1;
    } else {
      return false;
    }
  };

  const customOperationJoinConditionWord = function (nm_8) {
    const matchValue_8 = tryGetDataForCustomOperation(nm_8);
    const $var204 = matchValue_8 != null ? getValue(matchValue_8)[7] != null ? [0, getValue(matchValue_8)[3], getValue(matchValue_8)[6], getValue(matchValue_8)[5], getValue(matchValue_8)[4], getValue(matchValue_8)[2], getValue(matchValue_8)[1], getValue(matchValue_8)[8], getValue(matchValue_8)[0], getValue(getValue(matchValue_8)[7])] : [1] : [1];

    switch ($var204[0]) {
      case 0:
        return $var204[9];

      case 1:
        return "on";
    }
  };

  const customOperationAllowsInto = function (nm_9) {
    const matchValue_9 = tryGetDataForCustomOperation(nm_9);

    if (matchValue_9 != null) {
      const allowInto_1 = getValue(matchValue_9)[3];
      const _nm_5 = getValue(matchValue_9)[0];
      const _methInfo_5 = getValue(matchValue_9)[8];
      const _maintainsVarSpaceUsingBind_4 = getValue(matchValue_9)[1];
      const _maintainsVarSpace_4 = getValue(matchValue_9)[2];
      const _joinConditionWord_5 = getValue(matchValue_9)[7];
      const _isLikeZip_4 = getValue(matchValue_9)[4];
      const _isLikeJoin_4 = getValue(matchValue_9)[5];
      const _isLikeGroupJoin_4 = getValue(matchValue_9)[6];
      return allowInto_1;
    } else {
      return false;
    }
  };

  const customOpUsageText = function (nm_10) {
    const matchValue_10 = tryGetDataForCustomOperation(nm_10);

    if (matchValue_10 != null) {
      const isLikeZip_2 = getValue(matchValue_10)[4];
      const isLikeJoin_2 = getValue(matchValue_10)[5];
      const isLikeGroupJoin_2 = getValue(matchValue_10)[6];
      const _nm_6 = getValue(matchValue_10)[0];
      const _methInfo_6 = getValue(matchValue_10)[8];
      const _maintainsVarSpaceUsingBind_5 = getValue(matchValue_10)[1];
      const _maintainsVarSpace_5 = getValue(matchValue_10)[2];
      const _joinConditionWord_6 = getValue(matchValue_10)[7];
      const _allowInto_5 = getValue(matchValue_10)[3];

      if (isLikeGroupJoin_2) {
        return SR.customOperationTextLikeGroupJoin(nm_10.idText, customOperationJoinConditionWord(nm_10), customOperationJoinConditionWord(nm_10));
      } else if (isLikeJoin_2) {
        return SR.customOperationTextLikeJoin(nm_10.idText, customOperationJoinConditionWord(nm_10), customOperationJoinConditionWord(nm_10));
      } else if (isLikeZip_2) {
        return SR.customOperationTextLikeZip(nm_10.idText);
      } else {
        return null;
      }
    } else {
      return null;
    }
  };

  const env_1 = customOperationMethods.tail == null ? env : new TcEnv(fold(function (nenv, tupledArg_4) {
    return AddFakeNameToNameEnv(tupledArg_4[0], nenv, new Item(15, [tupledArg_4[0], function () {
      return customOpUsageText(ident(tupledArg_4[0], mBuilderVal));
    }, tupledArg_4[8]]));
  }, env.eNameResEnv, customOperationMethods), env.eUngeneralizableItems, env.ePath, env.eCompPath, env.eAccessPath, env.eAccessRights, env.eInternalsVisibleCompPaths, env.eModuleOrNamespaceTypeAccumulator, env.eContextInfo, env.eFamilyType, env.eCtorInfo, env.eCallerMemberName);
  CallEnvSink(cenv_1.tcSink, comp.Range, env_1.NameEnv, env.eAccessRights);

  const tryGetArgInfosForCustomOperator = function (nm_11) {
    const matchValue_11 = tryGetDataForCustomOperation(nm_11);

    if (matchValue_11 != null) {
      const methInfo_1 = getValue(matchValue_11)[8];
      const _nm_7 = getValue(matchValue_11)[0];
      const _maintainsVarSpace_6 = getValue(matchValue_11)[2];
      const _joinConditionWord_7 = getValue(matchValue_11)[7];
      const _isLikeZip_5 = getValue(matchValue_11)[4];
      const _isLikeJoin_5 = getValue(matchValue_11)[5];
      const _isLikeGroupJoin_5 = getValue(matchValue_11)[6];
      const _allowInto_6 = getValue(matchValue_11)[3];
      const __maintainsVarSpaceUsingBind = getValue(matchValue_11)[1];

      if (methInfo_1.tag === 0) {
        const matchValue_12 = ArgInfosOfMember(cenv_1.g, methInfo_1.data[2]);
        const $var205 = matchValue_12.tail != null ? matchValue_12.tail.tail == null ? [0, matchValue_12.head] : [1] : [1];

        switch ($var205[0]) {
          case 0:
            return $var205[1];

          case 1:
            return null;
        }
      } else {
        return null;
      }
    } else {
      return null;
    }
  };

  const expectedArgCountForCustomOperator = function (nm_12) {
    const matchValue_13 = tryGetArgInfosForCustomOperator(nm_12);

    if (matchValue_13 != null) {
      if (getValue(matchValue_13).length - 1 > 0) {
        return getValue(matchValue_13).length - 1 | 0;
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  };

  const isCustomOperationProjectionParameter = function (i, nm_13) {
    const matchValue_14 = tryGetArgInfosForCustomOperator(nm_13);

    if (matchValue_14 != null) {
      if (i < getValue(matchValue_14).length) {
        const patternInput = item_6(i, getValue(matchValue_14));
        return HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_ProjectionParameterAttribute, patternInput[1].Attribs);
      } else {
        return false;
      }
    } else {
      return false;
    }
  };

  const _ForEachThen___ = function (e_1) {
    const $var206 = e_1.tag === 12 ? e_1.data[1].data ? [1] : e_1.data[5].tag === 26 ? e_1.data[5].data[1] ? [0, e_1.data[0], e_1.data[5].data[2], e_1.data[4], e_1.data[2], e_1.data[3], e_1.data[5].data[3]] : [1] : [1] : [1];

    switch ($var206[0]) {
      case 0:
        return [$var206[4], $var206[5], $var206[3], $var206[2], $var206[6]];

      case 1:
        return null;
    }
  };

  const _CustomOpId___ = function (predicate, e_2) {
    let $var207;

    const activePatternResult41904 = _SingleIdent___(e_2);

    if (activePatternResult41904 != null) {
      if (isCustomOperation(getValue(activePatternResult41904)) ? predicate(getValue(activePatternResult41904)) : false) {
        $var207 = [0, getValue(activePatternResult41904)];
      } else {
        $var207 = [1];
      }
    } else {
      $var207 = [1];
    }

    switch ($var207[0]) {
      case 0:
        return $var207[1];

      case 1:
        return null;
    }
  };

  const _InExpr___ = function (e_3) {
    if (e_3.tag === 45) {
      return [e_3.data[0], e_3.data[2], e_3.data[3]];
    } else {
      return null;
    }
  };

  const _OnExpr___ = function (nm_14, e_4) {
    var e1;
    const matchValue_15 = tryGetDataForCustomOperation(nm_14);

    if (matchValue_15 != null) {
      let $var208;

      if (e_4.tag === 20) {
        if (e_4.data[2].tag === 20) {
          const activePatternResult41909 = _SingleIdent___(e_4.data[2].data[3]);

          if (activePatternResult41909 != null) {
            if (e1 = e_4.data[2].data[2], getValue(activePatternResult41909).idText === customOperationJoinConditionWord(nm_14)) {
              $var208 = [0, e_4.data[2].data[2], e_4.data[3], getValue(activePatternResult41909)];
            } else {
              $var208 = [1];
            }
          } else {
            $var208 = [1];
          }
        } else {
          $var208 = [1];
        }
      } else {
        $var208 = [1];
      }

      switch ($var208[0]) {
        case 0:
          const item_1 = new Item(15, [$var208[3].idText, function () {
            return null;
          }, null]);
          CallNameResolutionSink(cenv_1.tcSink, $var208[3].idRange, env_1.NameEnv, item_1, item_1, emptyTyparInst, new ItemOccurence(1), env_1.DisplayEnv, env_1.eAccessRights);
          return [$var208[1], $var208[2]];

        case 1:
          return null;
      }
    } else {
      return null;
    }
  };

  const _IntoSuffix___ = function (e_5) {
    var x;
    let $var209;

    if (e_5.tag === 20) {
      if (e_5.data[2].tag === 20) {
        const activePatternResult41912 = _SingleIdent___(e_5.data[2].data[3]);

        if (activePatternResult41912 != null) {
          const activePatternResult41913 = _ExprAsPat___(e_5.data[3]);

          if (activePatternResult41913 != null) {
            if (x = e_5.data[2].data[2], getValue(activePatternResult41912).idText === "into") {
              $var209 = [0, getValue(activePatternResult41913), getValue(activePatternResult41912), e_5.data[2].data[2]];
            } else {
              $var209 = [1];
            }
          } else {
            $var209 = [1];
          }
        } else {
          $var209 = [1];
        }
      } else {
        $var209 = [1];
      }
    } else {
      $var209 = [1];
    }

    switch ($var209[0]) {
      case 0:
        return [$var209[3], $var209[2].idRange, $var209[1]];

      case 1:
        return null;
    }
  };

  const arbPat = function (m_2) {
    return mkSynPatVar(null, mkSynId(m_2.MakeSynthetic(), "_missingVar"));
  };

  const MatchIntoSuffixOrRecover = function (alreadyGivenError, nm_15, e_6) {
    const activePatternResult41917 = _IntoSuffix___(e_6);

    if (activePatternResult41917 != null) {
      const item_2 = new Item(15, ["into", function () {
        return null;
      }, null]);
      CallNameResolutionSink(cenv_1.tcSink, getValue(activePatternResult41917)[1], env_1.NameEnv, item_2, item_2, emptyTyparInst, new ItemOccurence(1), env_1.DisplayEnv, env_1.eAccessRights);
      return [getValue(activePatternResult41917)[0], getValue(activePatternResult41917)[2], alreadyGivenError];
    } else {
      if (!alreadyGivenError) {
        errorR(new _Error(SR.tcOperatorIncorrectSyntax(nm_15.idText, getValue(customOpUsageText(nm_15))), nm_15.idRange));
      }

      return [e_6, arbPat(e_6.Range), true];
    }
  };

  const MatchOnExprOrRecover = function (alreadyGivenError_1, nm_16, onExpr) {
    let $var210;

    const activePatternResult41923 = _OnExpr___(nm_16, onExpr);

    if (activePatternResult41923 != null) {
      const activePatternResult41924 = _SynExprParen___(getValue(activePatternResult41923)[1]);

      if (activePatternResult41924 != null) {
        $var210 = [0, getValue(activePatternResult41923)[0], getValue(activePatternResult41924)[0]];
      } else {
        $var210 = [1];
      }
    } else {
      $var210 = [1];
    }

    switch ($var210[0]) {
      case 0:
        return [$var210[1], $var210[2]];

      case 1:
        if (!alreadyGivenError_1) {
          suppressErrorReporting(function () {
            return TcExprOfUnknownType(cenv_1, env_1, tpenv, onExpr);
          });
          errorR(new _Error(SR.tcOperatorIncorrectSyntax(nm_16.idText, getValue(customOpUsageText(nm_16))), nm_16.idRange));
        }

        return [arbExpr("_innerSource", onExpr.Range), mkSynBifix(onExpr.Range, "=", arbExpr("_keySelectors", onExpr.Range), arbExpr("_keySelector2", onExpr.Range))];
    }
  };

  const JoinOrGroupJoinOp = function (detector, e_7) {
    let $var211;

    if (e_7.tag === 20) {
      const activePatternResult41933 = _CustomOpId___(detector, e_7.data[2]);

      if (activePatternResult41933 != null) {
        const activePatternResult41934 = _ExprAsPat___(e_7.data[3]);

        if (activePatternResult41934 != null) {
          $var211 = [0, getValue(activePatternResult41934), e_7.data[4], getValue(activePatternResult41933)];
        } else {
          $var211 = [1];
        }
      } else {
        $var211 = [1];
      }
    } else {
      $var211 = [1];
    }

    switch ($var211[0]) {
      case 0:
        return [$var211[3], $var211[1], $var211[2], false];

      case 1:
        let $var212;

        if (e_7.tag === 20) {
          const activePatternResult41931 = _CustomOpId___(detector, e_7.data[2]);

          if (activePatternResult41931 != null) {
            $var212 = [0, e_7.data[3], e_7.data[4], getValue(activePatternResult41931)];
          } else {
            $var212 = [1];
          }
        } else {
          $var212 = [1];
        }

        switch ($var212[0]) {
          case 0:
            errorR(new _Error(SR.tcBinaryOperatorRequiresVariable($var212[3].idText, getValue(customOpUsageText($var212[3]))), $var212[3].idRange));
            return [$var212[3], arbPat($var212[2]), $var212[2], true];

          case 1:
            const activePatternResult41929 = _CustomOpId___(detector, e_7);

            if (activePatternResult41929 != null) {
              errorR(new _Error(SR.tcBinaryOperatorRequiresVariable(getValue(activePatternResult41929).idText, getValue(customOpUsageText(getValue(activePatternResult41929)))), getValue(activePatternResult41929).idRange));
              return [getValue(activePatternResult41929), arbPat(e_7.Range), e_7.Range, true];
            } else {
              return null;
            }

        }

    }
  };

  const _JoinOp___ = function (e_8) {
    return JoinOrGroupJoinOp(customOperationIsLikeJoin, e_8);
  };

  const _GroupJoinOp___ = function (e_9) {
    return JoinOrGroupJoinOp(customOperationIsLikeGroupJoin, e_9);
  };

  const arbKeySelectors = function (m_3) {
    return mkSynBifix(m_3, "=", arbExpr("_keySelectors", m_3), arbExpr("_keySelector2", m_3));
  };

  const _JoinExpr___ = function (e_10) {
    let $var213;

    const activePatternResult41941 = _InExpr___(e_10);

    if (activePatternResult41941 != null) {
      const activePatternResult41942 = _JoinOp___(getValue(activePatternResult41941)[0]);

      if (activePatternResult41942 != null) {
        $var213 = [0, getValue(activePatternResult41942)[3], getValue(activePatternResult41942)[1], getValue(activePatternResult41941)[2], getValue(activePatternResult41942)[0], getValue(activePatternResult41941)[1]];
      } else {
        $var213 = [1];
      }
    } else {
      $var213 = [1];
    }

    switch ($var213[0]) {
      case 0:
        const patternInput_1 = MatchOnExprOrRecover($var213[1], $var213[4], $var213[5]);
        return [$var213[4], $var213[2], patternInput_1[0], patternInput_1[1], $var213[3]];

      case 1:
        const activePatternResult41940 = _JoinOp___(e_10);

        if (activePatternResult41940 != null) {
          if (getValue(activePatternResult41940)[3]) {
            errorR(new _Error(SR.tcOperatorRequiresIn(getValue(activePatternResult41940)[0].idText, getValue(customOpUsageText(getValue(activePatternResult41940)[0]))), getValue(activePatternResult41940)[0].idRange));
          }

          return [getValue(activePatternResult41940)[0], getValue(activePatternResult41940)[1], arbExpr("_innerSource", e_10.Range), arbKeySelectors(e_10.Range), getValue(activePatternResult41940)[2]];
        } else {
          return null;
        }

    }
  };

  const _GroupJoinExpr___ = function (e_11) {
    let $var214;

    const activePatternResult41945 = _InExpr___(e_11);

    if (activePatternResult41945 != null) {
      const activePatternResult41946 = _GroupJoinOp___(getValue(activePatternResult41945)[0]);

      if (activePatternResult41946 != null) {
        $var214 = [0, getValue(activePatternResult41946)[3], getValue(activePatternResult41946)[1], getValue(activePatternResult41945)[1], getValue(activePatternResult41945)[2], getValue(activePatternResult41946)[0]];
      } else {
        $var214 = [1];
      }
    } else {
      $var214 = [1];
    }

    switch ($var214[0]) {
      case 0:
        const patternInput_2 = MatchIntoSuffixOrRecover($var214[1], $var214[5], $var214[3]);
        const patternInput_3 = MatchOnExprOrRecover(patternInput_2[2], $var214[5], patternInput_2[0]);
        return [$var214[5], $var214[2], patternInput_3[0], patternInput_3[1], patternInput_2[1], $var214[4]];

      case 1:
        const activePatternResult41944 = _GroupJoinOp___(e_11);

        if (activePatternResult41944 != null) {
          if (getValue(activePatternResult41944)[3]) {
            errorR(new _Error(SR.tcOperatorRequiresIn(getValue(activePatternResult41944)[0].idText, getValue(customOpUsageText(getValue(activePatternResult41944)[0]))), getValue(activePatternResult41944)[0].idRange));
          }

          return [getValue(activePatternResult41944)[0], getValue(activePatternResult41944)[1], arbExpr("_innerSource", e_11.Range), arbKeySelectors(e_11.Range), arbPat(e_11.Range), getValue(activePatternResult41944)[2]];
        } else {
          return null;
        }

    }
  };

  const _JoinOrGroupJoinOrZipClause___ = function (e_12) {
    const activePatternResult41958 = _JoinExpr___(e_12);

    if (activePatternResult41958 != null) {
      return [getValue(activePatternResult41958)[0], getValue(activePatternResult41958)[1], getValue(activePatternResult41958)[2], getValue(activePatternResult41958)[3], null, getValue(activePatternResult41958)[4]];
    } else {
      const activePatternResult41957 = _GroupJoinExpr___(e_12);

      if (activePatternResult41957 != null) {
        return [getValue(activePatternResult41957)[0], getValue(activePatternResult41957)[1], getValue(activePatternResult41957)[2], getValue(activePatternResult41957)[3], getValue(activePatternResult41957)[4], getValue(activePatternResult41957)[5]];
      } else {
        let $var215;

        const activePatternResult41953 = _InExpr___(e_12);

        if (activePatternResult41953 != null) {
          if (getValue(activePatternResult41953)[0].tag === 20) {
            const activePatternResult41955 = _CustomOpId___(customOperationIsLikeZip, getValue(activePatternResult41953)[0].data[2]);

            if (activePatternResult41955 != null) {
              const activePatternResult41956 = _ExprAsPat___(getValue(activePatternResult41953)[0].data[3]);

              if (activePatternResult41956 != null) {
                $var215 = [0, getValue(activePatternResult41953)[2], getValue(activePatternResult41955), getValue(activePatternResult41953)[1], getValue(activePatternResult41956)];
              } else {
                $var215 = [1];
              }
            } else {
              $var215 = [1];
            }
          } else {
            $var215 = [1];
          }
        } else {
          $var215 = [1];
        }

        switch ($var215[0]) {
          case 0:
            return [$var215[2], $var215[4], $var215[3], null, null, $var215[1]];

          case 1:
            const activePatternResult41952 = _CustomOpId___(customOperationIsLikeZip, e_12);

            if (activePatternResult41952 != null) {
              errorR(new _Error(SR.tcOperatorIncorrectSyntax(getValue(activePatternResult41952).idText, getValue(customOpUsageText(getValue(activePatternResult41952)))), getValue(activePatternResult41952).idRange));
              return [getValue(activePatternResult41952), arbPat(e_12.Range), arbExpr("_secondSource", e_12.Range), null, null, e_12.Range];
            } else {
              let $var216;

              if (e_12.tag === 20) {
                const activePatternResult41949 = _CustomOpId___(customOperationIsLikeZip, e_12.data[2]);

                if (activePatternResult41949 != null) {
                  const activePatternResult41950 = _ExprAsPat___(e_12.data[3]);

                  if (activePatternResult41950 != null) {
                    $var216 = [0, e_12.data[4], getValue(activePatternResult41949), getValue(activePatternResult41950)];
                  } else {
                    $var216 = [1];
                  }
                } else {
                  $var216 = [1];
                }
              } else {
                $var216 = [1];
              }

              switch ($var216[0]) {
                case 0:
                  errorR(new _Error(SR.tcOperatorIncorrectSyntax($var216[2].idText, getValue(customOpUsageText($var216[2]))), $var216[1]));
                  return [$var216[2], $var216[3], arbExpr("_innerSource", e_12.Range), null, null, $var216[1]];

                case 1:
                  return null;
              }
            }

        }
      }
    }
  };

  const _ForEachThenJoinOrGroupJoinOrZipClause___ = function (e_13) {
    var secondSourcePat;
    var secondSource;
    var pat3opt;
    var nm_17;
    var mOpCore;
    var keySelectorsOpt;
    var isFromSource;
    var innerComp;
    var firstSourcePat;
    var firstSource;
    var patternInput_4;
    let $var217;

    const activePatternResult41963 = _ForEachThen___(e_13);

    if (activePatternResult41963 != null) {
      const activePatternResult41964 = _JoinOrGroupJoinOrZipClause___(getValue(activePatternResult41963)[3]);

      if (activePatternResult41964 != null) {
        if (secondSourcePat = getValue(activePatternResult41964)[1], secondSource = getValue(activePatternResult41964)[2], pat3opt = getValue(activePatternResult41964)[4], nm_17 = getValue(activePatternResult41964)[0], mOpCore = getValue(activePatternResult41964)[5], keySelectorsOpt = getValue(activePatternResult41964)[3], isFromSource = getValue(activePatternResult41963)[0], innerComp = getValue(activePatternResult41963)[4], firstSourcePat = getValue(activePatternResult41963)[1], firstSource = getValue(activePatternResult41963)[2], patternInput_4 = (() => {
          const _holder = TemporarilySuspendReportingTypecheckResultsToSink(cenv_1.tcSink);

          try {
            return SimplePatsOfPat(cenv_1.synArgNameGenerator, firstSourcePat);
          } finally {
            if (hasInterface(_holder, "System.IDisposable")) {
              _holder.Dispose();
            }
          }
        })(), patternInput_4[1] == null) {
          $var217 = [0, getValue(activePatternResult41963)[2], getValue(activePatternResult41963)[1], getValue(activePatternResult41963)[4], getValue(activePatternResult41963)[0], getValue(activePatternResult41964)[3], getValue(activePatternResult41964)[5], getValue(activePatternResult41964)[0], getValue(activePatternResult41964)[4], getValue(activePatternResult41964)[2], getValue(activePatternResult41964)[1]];
        } else {
          $var217 = [1];
        }
      } else {
        $var217 = [1];
      }
    } else {
      $var217 = [1];
    }

    switch ($var217[0]) {
      case 0:
        return [$var217[4], $var217[2], $var217[1], $var217[7], $var217[10], $var217[9], $var217[5], $var217[8], $var217[6], $var217[3]];

      case 1:
        const activePatternResult41962 = _JoinOrGroupJoinOrZipClause___(e_13);

        if (activePatternResult41962 != null) {
          errorR(new _Error(SR.tcBinaryOperatorRequiresBody(getValue(activePatternResult41962)[0].idText, getValue(customOpUsageText(getValue(activePatternResult41962)[0]))), getValue(activePatternResult41962)[0].idRange));
          return [true, arbPat(e_13.Range), arbExpr("_outerSource", e_13.Range), getValue(activePatternResult41962)[0], getValue(activePatternResult41962)[1], getValue(activePatternResult41962)[2], getValue(activePatternResult41962)[3], getValue(activePatternResult41962)[4], getValue(activePatternResult41962)[5], arbExpr("_innerComp", e_13.Range)];
        } else {
          return null;
        }

    }
  };

  const _StripApps_ = function (e_14) {
    const strip = function (e_15) {
      const $var218 = e_15.tag === 56 ? e_15.data[0].tag === 20 ? [0, e_15.data[0].data[3], e_15.data[0].data[2]] : [1] : e_15.tag === 20 ? [0, e_15.data[3], e_15.data[2]] : [1];

      switch ($var218[0]) {
        case 0:
          const patternInput_5 = strip($var218[2]);
          return [patternInput_5[0], new List($var218[1], patternInput_5[1])];

        case 1:
          return [e_15, new List()];
      }
    };

    const patternInput_6 = strip(e_14);
    return [patternInput_6[0], reverse(patternInput_6[1])];
  };

  const _OptionalIntoSuffix_ = function (e_16) {
    const activePatternResult41968 = _IntoSuffix___(e_16);

    if (activePatternResult41968 != null) {
      return [getValue(activePatternResult41968)[0], [getValue(activePatternResult41968)[1], getValue(activePatternResult41968)[2]]];
    } else {
      return [e_16, null];
    }
  };

  const _CustomOperationClause___ = function (e_17) {
    let $var219;

    const activePatternResult41973 = _OptionalIntoSuffix_(e_17);

    const activePatternResult41974 = _StripApps_(activePatternResult41973[0]);

    const activePatternResult41975 = _SingleIdent___(activePatternResult41974[0]);

    if (activePatternResult41975 != null) {
      if (isCustomOperation(getValue(activePatternResult41975))) {
        $var219 = [0, activePatternResult41973[0], getValue(activePatternResult41975), activePatternResult41973[1]];
      } else {
        $var219 = [1];
      }
    } else {
      $var219 = [1];
    }

    switch ($var219[0]) {
      case 0:
        let optIntoInfo;

        if ($var219[3] == null) {
          optIntoInfo = null;
        } else {
          const optInfo = getValue($var219[3])[1];
          const intoWordRange = getValue($var219[3])[0];
          const item_3 = new Item(15, ["into", function () {
            return null;
          }, null]);
          CallNameResolutionSink(cenv_1.tcSink, intoWordRange, env_1.NameEnv, item_3, item_3, emptyTyparInst, new ItemOccurence(1), env_1.DisplayEnv, env_1.eAccessRights);
          optIntoInfo = optInfo;
        }

        return [$var219[2], getValue(tryGetDataForCustomOperation($var219[2])), $var219[1], $var219[1].Range, optIntoInfo];

      case 1:
        return null;
    }
  };

  const mkSynLambda = function (p, e_18, m_4) {
    return new SynExpr(15, [false, false, p, e_18, m_4]);
  };

  const mkExprForVarSpace = function (m_5, patvs) {
    if (patvs.tail != null) {
      if (patvs.tail.tail == null) {
        return new SynExpr(28, patvs.head.Id);
      } else {
        return new SynExpr(4, [map_1(function (v) {
          return new SynExpr(28, v.Id);
        }, patvs), new List(), m_5]);
      }
    } else {
      return new SynExpr(2, [new SynConst(0), m_5]);
    }
  };

  const mkSimplePatForVarSpace = function (m_6, patvs_1) {
    const spats = patvs_1.tail != null ? patvs_1.tail.tail == null ? ofArray([mkSynSimplePatVar(false, patvs_1.head.Id)]) : map_1(function (v_1) {
      return mkSynSimplePatVar(false, v_1.Id);
    }, patvs_1) : new List();
    return new SynSimplePats(0, [spats, m_6]);
  };

  const mkPatForVarSpace = function (m_7, patvs_2) {
    if (patvs_2.tail != null) {
      if (patvs_2.tail.tail == null) {
        return mkSynPatVar(null, patvs_2.head.Id);
      } else {
        return new SynPat(8, [map_1(function (x_1) {
          return mkSynPatVar(null, x_1.Id);
        }, patvs_2), m_7]);
      }
    } else {
      return new SynPat(0, [new SynConst(0), m_7]);
    }
  };

  const _OptionalSequential_ = function (e_19) {
    const $var220 = e_19.tag === 26 ? e_19.data[1] ? [0, e_19.data[0], e_19.data[2], e_19.data[3]] : [1] : [1];

    switch ($var220[0]) {
      case 0:
        return [$var220[2], $var220[3]];

      case 1:
        return [e_19, null];
    }
  };

  const checkForBinaryApp = function (comp_1) {
    var arg2;
    let $var221;

    const activePatternResult41994 = _StripApps_(comp_1);

    const activePatternResult41995 = _SingleIdent___(activePatternResult41994[0]);

    if (activePatternResult41995 != null) {
      if (activePatternResult41994[1].tail != null) {
        const activePatternResult41996 = _StripApps_(activePatternResult41994[1].head);

        const activePatternResult41997 = _SingleIdent___(activePatternResult41996[0]);

        if (activePatternResult41997 != null) {
          if (activePatternResult41994[1].tail.tail != null) {
            if (activePatternResult41994[1].tail.tail.tail == null) {
              if (arg2 = activePatternResult41994[1].tail.head, (IsInfixOperator(getValue(activePatternResult41995).idText) ? expectedArgCountForCustomOperator(getValue(activePatternResult41997)) > 0 : false) ? !(activePatternResult41996[1].tail == null) : false) {
                $var221 = [0, activePatternResult41994[1].tail.head, activePatternResult41996[1], getValue(activePatternResult41995), getValue(activePatternResult41997)];
              } else {
                $var221 = [1];
              }
            } else {
              $var221 = [1];
            }
          } else {
            $var221 = [1];
          }
        } else {
          $var221 = [1];
        }
      } else {
        $var221 = [1];
      }
    } else {
      $var221 = [1];
    }

    switch ($var221[0]) {
      case 0:
        const estimatedRangeOfIntendedLeftAndRightArguments = unionRanges(last($var221[2]).Range, $var221[1].Range);
        errorR(new _Error(SR.tcUnrecognizedQueryBinaryOperator(), estimatedRangeOfIntendedLeftAndRightArguments));
        return true;

      case 1:
        let $var222;

        if (comp_1.tag === 4) {
          if (comp_1.data[0].tail != null) {
            const activePatternResult41992 = _StripApps_(comp_1.data[0].head);

            const activePatternResult41993 = _SingleIdent___(activePatternResult41992[0]);

            if (activePatternResult41993 != null) {
              if (expectedArgCountForCustomOperator(getValue(activePatternResult41993)) > 0 ? !(activePatternResult41992[1].tail == null) : false) {
                $var222 = [0, activePatternResult41992[1], comp_1.data[2], getValue(activePatternResult41993)];
              } else {
                $var222 = [1];
              }
            } else {
              $var222 = [1];
            }
          } else {
            $var222 = [1];
          }
        } else {
          $var222 = [1];
        }

        switch ($var222[0]) {
          case 0:
            const estimatedRangeOfIntendedLeftAndRightArguments_1 = unionRanges(last($var222[1]).Range, $var222[2].EndRange);
            errorR(new _Error(SR.tcUnrecognizedQueryBinaryOperator(), estimatedRangeOfIntendedLeftAndRightArguments_1));
            return true;

          case 1:
            return false;
        }

    }
  };

  const addVarsToVarSpace = function (varSpace, f) {
    return LazyWithContext.Create(function (m_8) {
      const patternInput_7 = varSpace.Force(m_8);
      const patternInput_8 = f(m_8, patternInput_7[1]);
      const patvs_3 = append(patternInput_7[0], filter(function (v_2) {
        return !exists_1(function (v2) {
          return v_2.LogicalName === v2.LogicalName;
        }, patternInput_7[0]);
      }, patternInput_8[0]));
      return [patvs_3, patternInput_8[1]];
    }, function (x_2) {
      return x_2;
    });
  };

  const emptyVarSpace = LazyWithContext.NotLazy([new List(), env_1]);

  const tryTrans = function ($var567, $var568, $var569, $var570, $var571) {
    var secondResultPat;
    var relExpr_1;
    var relExpr;
    var mClause;
    var isObjExprBinding;

    tryTrans: while (true) {
      const firstTry = $var567;
      const q = $var568;
      const varSpace_1 = $var569;
      const comp_2 = $var570;
      const translatedCtxt = $var571;

      const activePatternResult42081 = _ForEachThenJoinOrGroupJoinOrZipClause___(comp_2);

      if (activePatternResult42081 != null) {
        if (!q) {
          error_1(new _Error(SR.tcCustomOperationMayNotBeUsedHere(), getValue(activePatternResult42081)[3].idRange));
        }

        const firstSource_1 = getValue(activePatternResult42081)[0] ? mkSourceExpr(getValue(activePatternResult42081)[2]) : getValue(activePatternResult42081)[2];
        const secondSource_1 = mkSourceExpr(getValue(activePatternResult42081)[5]);
        const varSpaceWithFirstVars = addVarsToVarSpace(varSpace_1, function (_mCustomOp, env_2) {
          const _holder_1 = TemporarilySuspendReportingTypecheckResultsToSink(cenv_1.tcSink);

          try {
            const patternInput_9 = TcMatchPattern(cenv_1, NewInferenceType(), env_2, tpenv, getValue(activePatternResult42081)[1], null);
            return [patternInput_9[2], patternInput_9[3]];
          } finally {
            if (hasInterface(_holder_1, "System.IDisposable")) {
              _holder_1.Dispose();
            }
          }
        });
        const varSpaceWithSecondVars = addVarsToVarSpace(varSpaceWithFirstVars, function (_mCustomOp_1, env_3) {
          const _holder_2 = TemporarilySuspendReportingTypecheckResultsToSink(cenv_1.tcSink);

          try {
            const patternInput_10 = TcMatchPattern(cenv_1, NewInferenceType(), env_3, tpenv, getValue(activePatternResult42081)[4], null);
            return [patternInput_10[2], patternInput_10[3]];
          } finally {
            if (hasInterface(_holder_2, "System.IDisposable")) {
              _holder_2.Dispose();
            }
          }
        });
        const varSpaceWithGroupJoinVars = getValue(activePatternResult42081)[7] == null ? varSpace_1 : addVarsToVarSpace(varSpaceWithFirstVars, function (_mCustomOp_2, env_4) {
          const _holder_3 = TemporarilySuspendReportingTypecheckResultsToSink(cenv_1.tcSink);

          try {
            const patternInput_11 = TcMatchPattern(cenv_1, NewInferenceType(), env_4, tpenv, getValue(getValue(activePatternResult42081)[7]), null);
            return [patternInput_11[2], patternInput_11[3]];
          } finally {
            if (hasInterface(_holder_3, "System.IDisposable")) {
              _holder_3.Dispose();
            }
          }
        });
        const patternInput_12 = SimplePatsOfPat(cenv_1.synArgNameGenerator, getValue(activePatternResult42081)[1]);
        const patternInput_13 = SimplePatsOfPat(cenv_1.synArgNameGenerator, getValue(activePatternResult42081)[4]);

        if (patternInput_12[1] != null) {
          errorR(new _Error(SR.tcJoinMustUseSimplePattern(getValue(activePatternResult42081)[3].idText), getValue(activePatternResult42081)[1].Range));
        }

        if (patternInput_13[1] != null) {
          errorR(new _Error(SR.tcJoinMustUseSimplePattern(getValue(activePatternResult42081)[3].idText), getValue(activePatternResult42081)[4].Range));
        }

        const matchValue_16 = tryGetDataForCustomOperation(getValue(activePatternResult42081)[3]);

        if (matchValue_16 != null) {
          const opName = getValue(matchValue_16)[0];
          const methInfo_2 = getValue(matchValue_16)[8];
          const item_4 = new Item(15, [opName, function () {
            return customOpUsageText(getValue(activePatternResult42081)[3]);
          }, methInfo_2]);
          CallNameResolutionSink(cenv_1.tcSink, getValue(activePatternResult42081)[3].idRange, env_1.NameEnv, item_4, item_4, emptyTyparInst, new ItemOccurence(1), env_1.DisplayEnv, env_1.eAccessRights);

          const mkJoinExpr = function (keySelector1, keySelector2, innerPat, e_20) {
            const mSynthetic = getValue(activePatternResult42081)[8].MakeSynthetic();
            return mkSynCall(methInfo_2.DisplayName, getValue(activePatternResult42081)[8], ofArray([firstSource_1, secondSource_1, mkSynLambda(patternInput_12[0], keySelector1, mSynthetic), mkSynLambda(patternInput_13[0], keySelector2, mSynthetic), mkSynLambda(patternInput_12[0], mkSynLambda(innerPat, e_20, mSynthetic), mSynthetic)]));
          };

          const mkZipExpr = function (e_21) {
            const mSynthetic_1 = getValue(activePatternResult42081)[8].MakeSynthetic();
            return mkSynCall(methInfo_2.DisplayName, getValue(activePatternResult42081)[8], ofArray([firstSource_1, secondSource_1, mkSynLambda(patternInput_12[0], mkSynLambda(patternInput_13[0], e_21, mSynthetic_1), mSynthetic_1)]));
          };

          const wrapInArbErrSequence = function (l, caption) {
            var copyOfStruct_1;
            return new SynExpr(26, [new SequencePointInfoForSeq(0), true, l, arbExpr(caption, (copyOfStruct_1 = l.Range, copyOfStruct_1.EndRange)), l.Range]);
          };

          let patternInput_15;

          const isNullableOp = function (opId) {
            const matchValue_17 = DecompileOpName(opId);
            const $var223 = matchValue_17 === "?=" ? [0] : matchValue_17 === "=?" ? [0] : matchValue_17 === "?=?" ? [0] : [1];

            switch ($var223[0]) {
              case 0:
                return true;

              case 1:
                return false;
            }
          };

          const matchValue_18 = [getValue(activePatternResult42081)[7], getValue(activePatternResult42081)[6]];
          const $var224 = matchValue_18[0] != null ? matchValue_18[1] != null ? (secondResultPat = getValue(matchValue_18[0]), relExpr_1 = getValue(matchValue_18[1]), customOperationIsLikeGroupJoin(getValue(activePatternResult42081)[3])) ? [0, getValue(matchValue_18[1]), getValue(matchValue_18[0])] : [1] : [1] : [1];

          switch ($var224[0]) {
            case 0:
              const patternInput_14 = SimplePatsOfPat(cenv_1.synArgNameGenerator, $var224[2]);

              if (patternInput_14[1] != null) {
                errorR(new _Error(SR.tcJoinMustUseSimplePattern(getValue(activePatternResult42081)[3].idText), $var224[2].Range));
              }

              const activePatternResult42028 = _JoinRelation___(cenv_1, env_1, $var224[1]);

              if (activePatternResult42028 != null) {
                patternInput_15 = [CurriedLambda(mkJoinExpr)(getValue(activePatternResult42028)[0], getValue(activePatternResult42028)[1], patternInput_14[0]), varSpaceWithGroupJoinVars];
              } else {
                const activePatternResult42026 = _BinOpExpr___($var224[1]);

                if (activePatternResult42026 != null) {
                  if (isNullableOp(getValue(activePatternResult42026)[0].idText)) {
                    errorR(new _Error(SR.cannotResolveNullableOperators(DecompileOpName(getValue(activePatternResult42026)[0].idText)), $var224[1].Range));
                  } else {
                    errorR(new _Error(SR.tcInvalidRelationInJoin(getValue(activePatternResult42081)[3].idText), $var224[1].Range));
                  }

                  const l_1 = wrapInArbErrSequence(getValue(activePatternResult42026)[1], "_keySelector1");
                  const r = wrapInArbErrSequence(getValue(activePatternResult42026)[2], "_keySelector2");
                  patternInput_15 = [CurriedLambda(mkJoinExpr)(l_1, r, patternInput_14[0]), varSpaceWithGroupJoinVars];
                } else {
                  errorR(new _Error(SR.tcInvalidRelationInJoin(getValue(activePatternResult42081)[3].idText), $var224[1].Range));
                  patternInput_15 = [CurriedLambda(mkJoinExpr)($var224[1], arbExpr("_keySelector2", $var224[1].Range), patternInput_14[0]), varSpaceWithGroupJoinVars];
                }
              }

              break;

            case 1:
              const $var225 = matchValue_18[0] == null ? matchValue_18[1] != null ? (relExpr = getValue(matchValue_18[1]), customOperationIsLikeJoin(getValue(activePatternResult42081)[3])) ? [0, getValue(matchValue_18[1])] : [1] : [1] : [1];

              switch ($var225[0]) {
                case 0:
                  const activePatternResult42031 = _JoinRelation___(cenv_1, env_1, $var225[1]);

                  if (activePatternResult42031 != null) {
                    patternInput_15 = [CurriedLambda(mkJoinExpr)(getValue(activePatternResult42031)[0], getValue(activePatternResult42031)[1], patternInput_13[0]), varSpaceWithSecondVars];
                  } else {
                    const activePatternResult42029 = _BinOpExpr___($var225[1]);

                    if (activePatternResult42029 != null) {
                      if (isNullableOp(getValue(activePatternResult42029)[0].idText)) {
                        errorR(new _Error(SR.cannotResolveNullableOperators(DecompileOpName(getValue(activePatternResult42029)[0].idText)), $var225[1].Range));
                      } else {
                        errorR(new _Error(SR.tcInvalidRelationInJoin(getValue(activePatternResult42081)[3].idText), $var225[1].Range));
                      }

                      const l_2 = wrapInArbErrSequence(getValue(activePatternResult42029)[1], "_keySelector1");
                      const r_1 = wrapInArbErrSequence(getValue(activePatternResult42029)[2], "_keySelector2");
                      patternInput_15 = [CurriedLambda(mkJoinExpr)(l_2, r_1, patternInput_13[0]), varSpaceWithGroupJoinVars];
                    } else {
                      errorR(new _Error(SR.tcInvalidRelationInJoin(getValue(activePatternResult42081)[3].idText), $var225[1].Range));
                      patternInput_15 = [CurriedLambda(mkJoinExpr)($var225[1], arbExpr("_keySelector2", $var225[1].Range), patternInput_13[0]), varSpaceWithGroupJoinVars];
                    }
                  }

                  break;

                case 1:
                  const $var226 = matchValue_18[0] == null ? matchValue_18[1] == null ? customOperationIsLikeZip(getValue(activePatternResult42081)[3]) ? [0] : [1] : [1] : [1];

                  switch ($var226[0]) {
                    case 0:
                      patternInput_15 = [mkZipExpr, varSpaceWithSecondVars];
                      break;

                    case 1:
                      throw new Error("unreachable");
                      break;
                  }

                  break;
              }

              break;
          }

          const patternInput_16 = patternInput_15[1].Force(getValue(activePatternResult42081)[8]);
          const varSpaceExpr = mkExprForVarSpace(getValue(activePatternResult42081)[8], patternInput_16[0]);
          const varSpacePat = mkPatForVarSpace(getValue(activePatternResult42081)[8], patternInput_16[0]);
          const joinExpr = patternInput_15[0](varSpaceExpr);
          return trans(true, q, patternInput_15[1], new SynExpr(12, [new SequencePointInfoForForLoop(1), new SeqExprOnly(0, false), false, varSpacePat, joinExpr, getValue(activePatternResult42081)[9], getValue(activePatternResult42081)[8]]), translatedCtxt);
        } else {
          return error_1(new _Error(SR.tcMissingCustomOperation(getValue(activePatternResult42081)[3].idText), getValue(activePatternResult42081)[3].idRange));
        }
      } else {
        let $var227;

        if (comp_2.tag === 12) {
          $var227 = [0, comp_2.data[1].data, comp_2.data[5], comp_2.data[2], comp_2.data[3], comp_2.data[4], comp_2.data[0]];
        } else if (comp_2.tag === 11) {
          $var227 = [1, comp_2.data[3], comp_2.data[4], comp_2.data[1], comp_2.data[5], comp_2.data[6], comp_2.data[0], comp_2.data[2]];
        } else if (comp_2.tag === 10) {
          $var227 = [2, comp_2.data[1], comp_2.data[2], comp_2.data[0]];
        } else if (comp_2.tag === 24) {
          $var227 = [3, comp_2.data[4], comp_2.data[0], comp_2.data[2], comp_2.data[3], comp_2.data[1]];
        } else if (comp_2.tag === 0) {
          $var227 = [4, comp_2.data[3]];
        } else if (comp_2.tag === 46) {
          $var227 = [5, comp_2.data];
        } else {
          const activePatternResult42079 = _OptionalSequential_(comp_2);

          const activePatternResult42080 = _JoinOrGroupJoinOrZipClause___(activePatternResult42079[0]);

          if (activePatternResult42080 != null) {
            if (mClause = getValue(activePatternResult42080)[5], firstTry) {
              $var227 = [6, getValue(activePatternResult42080)[5]];
            } else {
              $var227 = [7];
            }
          } else {
            $var227 = [7];
          }
        }

        switch ($var227[0]) {
          case 0:
            const wrappedSourceExpr = $var227[3] ? mkSourceExpr($var227[5]) : $var227[5];
            const mFor = $var227[6].tag === 0 ? $var227[6].data : $var227[4].Range;
            const mPat = $var227[4].Range;
            const spBind = $var227[6].tag === 1 ? new SequencePointInfoForBinding(3) : new SequencePointInfoForBinding(0, $var227[6].data);

            if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, mFor, env.eAccessRights, "For", builderTy).tail == null) {
              error_1(new _Error(SR.tcRequireBuilderMethod("For"), mFor));
            }

            const varSpace_2 = addVarsToVarSpace(varSpace_1, function (_mCustomOp_3, env_5) {
              const _holder_4 = TemporarilySuspendReportingTypecheckResultsToSink(cenv_1.tcSink);

              try {
                const patternInput_17 = TcMatchPattern(cenv_1, NewInferenceType(), env_5, tpenv, $var227[4], null);
                return [patternInput_17[2], patternInput_17[3]];
              } finally {
                if (hasInterface(_holder_4, "System.IDisposable")) {
                  _holder_4.Dispose();
                }
              }
            });
            return trans(true, q, varSpace_2, $var227[2], function (holeFill) {
              return translatedCtxt(mkSynCall("For", mFor, ofArray([wrappedSourceExpr, new SynExpr(16, [false, $var227[5].Range, ofArray([new SynMatchClause(0, [$var227[4], null, holeFill, mPat, new SequencePointInfoForTarget(0)])]), spBind, mFor])])));
            });

          case 1:
            const mFor_1 = $var227[6].tag === 0 ? $var227[6].data : $var227[5];

            if (isQuery) {
              errorR(new _Error(SR.tcNoIntegerForLoopInQuery(), mFor_1));
            }

            return trans(true, q, varSpace_1, elimFastIntegerForLoop($var227[6], $var227[3], $var227[7], $var227[1], $var227[2], $var227[4], $var227[5]), translatedCtxt);

          case 2:
            const mGuard = $var227[1].Range;
            const mWhile = $var227[3].tag === 0 ? $var227[3].data : mGuard;

            if (isQuery) {
              error_1(new _Error(SR.tcNoWhileInQuery(), mWhile));
            }

            if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, mWhile, env.eAccessRights, "While", builderTy).tail == null) {
              error_1(new _Error(SR.tcRequireBuilderMethod("While"), mWhile));
            }

            if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, mWhile, env.eAccessRights, "Delay", builderTy).tail == null) {
              error_1(new _Error(SR.tcRequireBuilderMethod("Delay"), mWhile));
            }

            return trans(true, q, varSpace_1, $var227[2], function (holeFill_1) {
              return translatedCtxt(mkSynCall("While", mWhile, ofArray([mkSynDelay2($var227[1]), mkSynCall("Delay", mWhile, ofArray([mkSynDelay($var227[2].Range, holeFill_1)]))])));
            });

          case 3:
            const mTry = $var227[4].tag === 0 ? $var227[4].data : $var227[3];

            if (isQuery) {
              error_1(new _Error(SR.tcNoTryFinallyInQuery(), mTry));
            }

            if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, mTry, env.eAccessRights, "TryFinally", builderTy).tail == null) {
              error_1(new _Error(SR.tcRequireBuilderMethod("TryFinally"), mTry));
            }

            if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, mTry, env.eAccessRights, "Delay", builderTy).tail == null) {
              error_1(new _Error(SR.tcRequireBuilderMethod("Delay"), mTry));
            }

            return translatedCtxt(mkSynCall("TryFinally", mTry, ofArray([mkSynCall("Delay", mTry, ofArray([mkSynDelay($var227[2].Range, transNoQueryOps($var227[2]))])), mkSynDelay2($var227[5])])));

          case 4:
            return error_1(new _Error(SR.tcConstructIsAmbiguousInComputationExpression(), $var227[1]));

          case 5:
            if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, $var227[1], env.eAccessRights, "Zero", builderTy).tail == null) {
              error_1(new _Error(SR.tcRequireBuilderMethod("Zero"), $var227[1]));
            }

            return translatedCtxt(mkSynCall("Zero", $var227[1], new List()));

          case 6:
            const patternInput_18 = varSpace_1.Force(comp_2.Range);
            const varSpaceExpr_1 = mkExprForVarSpace($var227[1], patternInput_18[0]);
            const varSpacePat_1 = mkPatForVarSpace($var227[1], patternInput_18[0]);
            const dataCompPrior = translatedCtxt(transNoQueryOps(new SynExpr(47, [[true, false], varSpaceExpr_1, $var227[1]])));
            const rebind = new SynExpr(12, [new SequencePointInfoForForLoop(1), new SeqExprOnly(0, false), false, varSpacePat_1, dataCompPrior, comp_2, comp_2.Range]);
            $var567 = false;
            $var568 = q;
            $var569 = varSpace_1;
            $var570 = rebind;

            $var571 = function (x_3) {
              return x_3;
            };

            continue tryTrans;

          case 7:
            const activePatternResult42077 = _OptionalSequential_(comp_2);

            const activePatternResult42078 = _CustomOperationClause___(activePatternResult42077[0]);

            if (activePatternResult42078 != null) {
              if (!q) {
                error_1(new _Error(SR.tcCustomOperationMayNotBeUsedHere(), getValue(activePatternResult42078)[2].Range));
              }

              const patternInput_19 = varSpace_1.Force(comp_2.Range);
              const varSpaceExpr_2 = mkExprForVarSpace(getValue(activePatternResult42078)[3], patternInput_19[0]);
              let dataCompPriorToOp;
              const isYield = !customOperationMaintainsVarSpaceUsingBind(getValue(activePatternResult42078)[0]);
              dataCompPriorToOp = translatedCtxt(transNoQueryOps(new SynExpr(47, [[isYield, false], varSpaceExpr_2, getValue(activePatternResult42078)[3]])));

              const consumeClauses = function (varSpace_3, dataCompPrior_1, compClausesExpr, lastUsesBind) {
                consumeClauses: while (true) {
                  const patternInput_20 = varSpace_3.Force(comp_2.Range);
                  const varSpaceSimplePat = mkSimplePatForVarSpace(getValue(activePatternResult42078)[3], patternInput_20[0]);
                  const varSpacePat_2 = mkPatForVarSpace(getValue(activePatternResult42078)[3], patternInput_20[0]);

                  const activePatternResult42046 = _OptionalSequential_(compClausesExpr);

                  const activePatternResult42047 = _CustomOperationClause___(activePatternResult42046[0]);

                  if (activePatternResult42047 != null) {
                    const item_5 = new Item(15, [getValue(activePatternResult42047)[1][0], function () {
                      return customOpUsageText(getValue(activePatternResult42047)[0]);
                    }, getValue(activePatternResult42047)[1][8]]);
                    CallNameResolutionSink(cenv_1.tcSink, getValue(activePatternResult42047)[0].idRange, env_1.NameEnv, item_5, item_5, emptyTyparInst, new ItemOccurence(1), env_1.DisplayEnv, env_1.eAccessRights);

                    if ((getValue(activePatternResult42047)[1][4] ? true : getValue(activePatternResult42047)[1][5]) ? true : getValue(activePatternResult42047)[1][6]) {
                      errorR(new _Error(SR.tcBinaryOperatorRequiresBody(getValue(activePatternResult42047)[0].idText, getValue(customOpUsageText(getValue(activePatternResult42047)[0]))), getValue(activePatternResult42047)[0].idRange));

                      if (activePatternResult42046[1] != null) {
                        varSpace_3 = varSpace_3;
                        dataCompPrior_1 = dataCompPrior_1;
                        compClausesExpr = getValue(activePatternResult42046[1]);
                        lastUsesBind = lastUsesBind;
                        continue consumeClauses;
                      } else {
                        RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects(cenv_1, env_1, tpenv, getValue(activePatternResult42047)[2]);
                        return dataCompPrior_1;
                      }
                    } else {
                      const maintainsVarSpace_2 = customOperationMaintainsVarSpace(getValue(activePatternResult42047)[0]);
                      const maintainsVarSpaceUsingBind_2 = customOperationMaintainsVarSpaceUsingBind(getValue(activePatternResult42047)[0]);
                      const expectedArgCount = expectedArgCountForCustomOperator(getValue(activePatternResult42047)[0]) | 0;
                      let dataCompAfterOp;

                      const activePatternResult42043 = _StripApps_(getValue(activePatternResult42047)[2]);

                      const activePatternResult42044 = _SingleIdent___(activePatternResult42043[0]);

                      if (activePatternResult42044 != null) {
                        if (activePatternResult42043[1].length === expectedArgCount) {
                          const args_2 = mapIndexed(function (i_1, arg) {
                            var copyOfStruct_2;
                            return isCustomOperationProjectionParameter(i_1 + 1, getValue(activePatternResult42044)) ? new SynExpr(15, [false, false, varSpaceSimplePat, arg, (copyOfStruct_2 = arg.Range, copyOfStruct_2.MakeSynthetic())]) : arg;
                          }, activePatternResult42043[1]);
                          dataCompAfterOp = mkSynCall(getValue(activePatternResult42047)[1][8].DisplayName, getValue(activePatternResult42047)[3], new List(dataCompPrior_1, args_2));
                        } else {
                          errorR(new _Error(SR.tcCustomOperationHasIncorrectArgCount(getValue(activePatternResult42044).idText, expectedArgCount, activePatternResult42043[1].length), getValue(activePatternResult42044).idRange));
                          dataCompAfterOp = mkSynCall(getValue(activePatternResult42047)[1][8].DisplayName, getValue(activePatternResult42047)[3], append(ofArray([dataCompPrior_1]), initialize(expectedArgCount, function (i_2) {
                            return arbExpr("_arg" + i_2.toString(), getValue(activePatternResult42047)[3]);
                          })));
                        }
                      } else {
                        throw new Error("unreachable");
                      }

                      if (activePatternResult42046[1] != null) {
                        if (getValue(activePatternResult42047)[4] == null) {
                          if (maintainsVarSpace_2 ? true : maintainsVarSpaceUsingBind_2) {
                            varSpace_3 = varSpace_3;
                            dataCompPrior_1 = dataCompAfterOp;
                            compClausesExpr = getValue(activePatternResult42046[1]);
                            lastUsesBind = maintainsVarSpaceUsingBind_2;
                            continue consumeClauses;
                          } else {
                            varSpace_3 = emptyVarSpace;
                            dataCompPrior_1 = dataCompAfterOp;
                            compClausesExpr = getValue(activePatternResult42046[1]);
                            lastUsesBind = false;
                            continue consumeClauses;
                          }
                        } else {
                          if (!customOperationAllowsInto(getValue(activePatternResult42047)[0])) {
                            error_1(new _Error(SR.tcOperatorDoesntAcceptInto(getValue(activePatternResult42047)[0].idText), getValue(getValue(activePatternResult42047)[4]).Range));
                          }

                          const rebind_1 = maintainsVarSpaceUsingBind_2 ? new SynExpr(49, [new SequencePointInfoForBinding(2), false, false, getValue(getValue(activePatternResult42047)[4]), dataCompAfterOp, getValue(activePatternResult42046[1]), getValue(getValue(activePatternResult42047)[4]).Range]) : new SynExpr(12, [new SequencePointInfoForForLoop(1), new SeqExprOnly(0, false), false, getValue(getValue(activePatternResult42047)[4]), dataCompAfterOp, getValue(activePatternResult42046[1]), getValue(getValue(activePatternResult42047)[4]).Range]);
                          return trans(true, q, emptyVarSpace, rebind_1, function (x_4) {
                            return x_4;
                          });
                        }
                      } else {
                        if (getValue(activePatternResult42047)[4] == null) {} else {
                          errorR(new _Error(SR.tcIntoNeedsRestOfQuery(), getValue(getValue(activePatternResult42047)[4]).Range));
                        }

                        return dataCompAfterOp;
                      }
                    }
                  } else {
                    const rebind_2 = lastUsesBind ? new SynExpr(49, [new SequencePointInfoForBinding(2), false, false, varSpacePat_2, dataCompPrior_1, compClausesExpr, compClausesExpr.Range]) : new SynExpr(12, [new SequencePointInfoForForLoop(1), new SeqExprOnly(0, false), false, varSpacePat_2, dataCompPrior_1, compClausesExpr, compClausesExpr.Range]);
                    return trans(true, q, varSpace_3, rebind_2, function (x_5) {
                      return x_5;
                    });
                  }
                }
              };

              return consumeClauses(varSpace_1, dataCompPriorToOp, comp_2, false);
            } else {
              const $var228 = comp_2.tag === 26 ? comp_2.data[1] ? [0, comp_2.data[2], comp_2.data[3], comp_2.data[4], comp_2.data[0]] : [11] : comp_2.tag === 27 ? [1, comp_2.data[2], comp_2.data[0], comp_2.data[4], comp_2.data[6], comp_2.data[5], comp_2.data[3], comp_2.data[1]] : comp_2.tag === 22 ? comp_2.data[1] ? comp_2.data[2].tail != null ? comp_2.data[2].head.data[1].tag === 1 ? comp_2.data[2].tail.tail == null ? [3, comp_2.data[3], comp_2.data[2].head.data[7], comp_2.data[2].head.data[9], comp_2.data[2].head.data[11]] : [11] : [11] : [11] : [2, comp_2.data[2], comp_2.data[3], comp_2.data[0], comp_2.data[4]] : comp_2.tag === 49 ? comp_2.data[1] ? comp_2.data[3].tag === 2 ? comp_2.data[3].data[0].tag === 1 ? comp_2.data[3].data[2] ? [6, comp_2.data[5], comp_2.data[2], comp_2.data[4], comp_2.data[0], comp_2.data[3]] : [5, comp_2.data[3].data[1], comp_2.data[5], comp_2.data[2], comp_2.data[3], comp_2.data[4], comp_2.data[0]] : [6, comp_2.data[5], comp_2.data[2], comp_2.data[4], comp_2.data[0], comp_2.data[3]] : comp_2.data[3].tag === 7 ? comp_2.data[3].data[0].data[0].tail != null ? comp_2.data[3].data[0].data[0].tail.tail == null ? [5, comp_2.data[3].data[0].data[0].head, comp_2.data[5], comp_2.data[2], comp_2.data[3], comp_2.data[4], comp_2.data[0]] : [6, comp_2.data[5], comp_2.data[2], comp_2.data[4], comp_2.data[0], comp_2.data[3]] : [6, comp_2.data[5], comp_2.data[2], comp_2.data[4], comp_2.data[0], comp_2.data[3]] : [6, comp_2.data[5], comp_2.data[2], comp_2.data[4], comp_2.data[0], comp_2.data[3]] : [4, comp_2.data[5], comp_2.data[2], comp_2.data[3], comp_2.data[4], comp_2.data[0]] : comp_2.tag === 17 ? comp_2.data[3] ? [11] : [7, comp_2.data[2], comp_2.data[1], comp_2.data[4], comp_2.data[0]] : comp_2.tag === 23 ? [8, comp_2.data[1], comp_2.data[3], comp_2.data[6], comp_2.data[2], comp_2.data[0], comp_2.data[4], comp_2.data[5]] : comp_2.tag === 48 ? [9, comp_2.data[0][0], comp_2.data[2], comp_2.data[1]] : comp_2.tag === 47 ? [10, comp_2.data[0][0], comp_2.data[2], comp_2.data[1]] : [11];

              switch ($var228[0]) {
                case 0:
                  if (isQuery ? checkForBinaryApp($var228[1]) : false) {
                    return trans(true, q, varSpace_1, $var228[2], translatedCtxt);
                  } else {
                    if (isQuery ? !$var228[1].IsArbExprAndThusAlreadyReportedError : false) {
                      if ($var228[1].tag === 45) {} else {
                        errorR(new _Error(SR.tcUnrecognizedQueryOperator(), $var228[1].RangeOfFirstPortion));
                      }
                    }

                    const matchValue_19 = tryTrans(true, false, varSpace_1, $var228[1], function (x_6) {
                      return x_6;
                    });

                    if (matchValue_19 == null) {
                      if ($var228[1].tag === 50) {
                        const sp = $var228[4].tag === 1 ? new SequencePointInfoForBinding(1) : $var228[4].tag === 0 ? new SequencePointInfoForBinding(0, $var228[1].data[1]) : new SequencePointInfoForBinding(0, $var228[1].data[1]);
                        return trans(true, q, varSpace_1, new SynExpr(49, [sp, false, true, new SynPat(0, [new SynConst(0), $var228[1].data[0].Range]), $var228[1].data[0], $var228[2], $var228[1].data[1]]), translatedCtxt);
                      } else {
                        return trans(true, q, varSpace_1, $var228[2], function (holeFill_2) {
                          return translatedCtxt(new SynExpr(26, [$var228[4], true, $var228[1], holeFill_2, $var228[3]]));
                        });
                      }
                    } else {
                      let m1;
                      const $var229 = $var228[1].tag === 27 ? [0, $var228[1].data[6], $var228[1].data[5]] : $var228[1].tag === 17 ? $var228[1].data[0].tag === 0 ? [1, $var228[1].data[0].data] : [7] : $var228[1].tag === 23 ? $var228[1].data[5].tag === 0 ? [2, $var228[1].data[5].data] : [7] : $var228[1].tag === 24 ? $var228[1].data[3].tag === 0 ? [3, $var228[1].data[3].data] : [7] : $var228[1].tag === 11 ? $var228[1].data[0].tag === 0 ? [4, $var228[1].data[0].data] : [7] : $var228[1].tag === 12 ? $var228[1].data[0].tag === 0 ? [5, $var228[1].data[0].data] : [7] : $var228[1].tag === 10 ? $var228[1].data[0].tag === 0 ? [6, $var228[1].data[0].data] : [7] : [7];

                      switch ($var229[0]) {
                        case 0:
                          m1 = $var229[2];
                          break;

                        case 1:
                          m1 = $var229[1];
                          break;

                        case 2:
                          m1 = $var229[1];
                          break;

                        case 3:
                          m1 = $var229[1];
                          break;

                        case 4:
                          m1 = $var229[1];
                          break;

                        case 5:
                          m1 = $var229[1];
                          break;

                        case 6:
                          m1 = $var229[1];
                          break;

                        case 7:
                          m1 = $var228[1].Range;
                          break;
                      }

                      if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, $var228[3], env.eAccessRights, "Combine", builderTy).tail == null) {
                        error_1(new _Error(SR.tcRequireBuilderMethod("Combine"), $var228[3]));
                      }

                      if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, $var228[3], env.eAccessRights, "Delay", builderTy).tail == null) {
                        error_1(new _Error(SR.tcRequireBuilderMethod("Delay"), $var228[3]));
                      }

                      return translatedCtxt(mkSynCall("Combine", m1, ofArray([getValue(matchValue_19), mkSynCall("Delay", m1, ofArray([mkSynDelay($var228[2].Range, transNoQueryOps($var228[2]))]))])));
                    }
                  }

                case 1:
                  if ($var228[1] == null) {
                    let elseComp;

                    if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, $var228[5], env.eAccessRights, "Zero", builderTy).tail == null) {
                      error_1(new _Error(SR.tcRequireBuilderMethod("Zero"), $var228[5]));
                    }

                    elseComp = mkSynCall("Zero", $var228[5], new List());
                    return trans(true, q, varSpace_1, $var228[7], function (holeFill_3) {
                      return translatedCtxt(new SynExpr(27, [$var228[2], holeFill_3, elseComp, $var228[6], $var228[3], $var228[5], $var228[4]]));
                    });
                  } else {
                    if (isQuery) {
                      error_1(new _Error(SR.tcIfThenElseMayNotBeUsedWithinQueries(), $var228[5]));
                    }

                    return translatedCtxt(new SynExpr(27, [$var228[2], transNoQueryOps($var228[7]), transNoQueryOps(getValue($var228[1])), $var228[6], $var228[3], $var228[5], $var228[4]]));
                  }

                case 2:
                  if (isQuery) {
                    const matchValue_20 = map_1((isObjExprBinding = new IsObjExprBinding(1), function (b) {
                      return BindingNormalization.NormalizeBinding(isObjExprBinding, cenv_1, env_1, b);
                    }), $var228[1]);
                    const $var230 = matchValue_20.tail != null ? matchValue_20.head.data[1].tag === 1 ? matchValue_20.head.data[2] ? [1] : matchValue_20.head.data[3] ? [1] : matchValue_20.tail.tail == null ? !$var228[3] ? [0] : [1] : [1] : [1] : [1];

                    switch ($var230[0]) {
                      case 0:
                        break;

                      case 1:
                        const failAt = function (m_9) {
                          return error_1(new _Error(SR.tcNonSimpleLetBindingInQuery(), m_9));
                        };

                        if (matchValue_20.tail != null) {
                          const mBinding = matchValue_20.head.data[10];
                          failAt(mBinding);
                        } else {
                          failAt($var228[4]);
                        }

                        break;
                    }
                  }

                  const varSpace_4 = addVarsToVarSpace(varSpace_1, function (mQueryOp, env_6) {
                    var isObjExprBinding_1;
                    const matchValue_21 = map_1((isObjExprBinding_1 = new IsObjExprBinding(1), function (b_1) {
                      return BindingNormalization.NormalizeBinding(isObjExprBinding_1, cenv_1, env_6, b_1);
                    }), $var228[1]);
                    const $var231 = matchValue_21.tail != null ? matchValue_21.head.data[1].tag === 1 ? matchValue_21.head.data[2] ? [1] : matchValue_21.head.data[3] ? [1] : matchValue_21.tail.tail == null ? [0, matchValue_21.head.data[0], matchValue_21.head.data[8]] : [1] : [1] : [1];

                    switch ($var231[0]) {
                      case 0:
                        const _holder_5 = TemporarilySuspendReportingTypecheckResultsToSink(cenv_1.tcSink);

                        try {
                          const patternInput_21 = TcMatchPattern(cenv_1, NewInferenceType(), env_6, tpenv, $var231[2], null);
                          return [patternInput_21[2], patternInput_21[3]];
                        } finally {
                          if (hasInterface(_holder_5, "System.IDisposable")) {
                            _holder_5.Dispose();
                          }
                        }

                      case 1:
                        return error_1(new _Error(SR.tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings(), mQueryOp));
                    }
                  });
                  return trans(true, q, varSpace_4, $var228[2], function (holeFill_4) {
                    return translatedCtxt(new SynExpr(22, [$var228[3], false, $var228[1], holeFill_4, $var228[4]]));
                  });

                case 3:
                  const bindRange = $var228[4].tag === 0 ? $var228[4].data : $var228[3].Range;

                  if (isQuery) {
                    error_1(new _Error(SR.tcUseMayNotBeUsedInQueries(), bindRange));
                  }

                  const innerCompRange = $var228[1].Range;
                  const consumeExpr = new SynExpr(16, [false, innerCompRange, ofArray([new SynMatchClause(0, [$var228[2], null, transNoQueryOps($var228[1]), innerCompRange, new SequencePointInfoForTarget(0)])]), $var228[4], innerCompRange]);

                  if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, bindRange, env.eAccessRights, "Using", builderTy).tail == null) {
                    error_1(new _Error(SR.tcRequireBuilderMethod("Using"), bindRange));
                  }

                  return translatedCtxt(mkSynCall("Using", bindRange, ofArray([$var228[3], consumeExpr])));

                case 4:
                  const bindRange_1 = $var228[5].tag === 0 ? $var228[5].data : $var228[4].Range;

                  if (isQuery) {
                    error_1(new _Error(SR.tcBindMayNotBeUsedInQueries(), bindRange_1));
                  }

                  const innerRange = $var228[1].Range;

                  if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, bindRange_1, env.eAccessRights, "Bind", builderTy).tail == null) {
                    error_1(new _Error(SR.tcRequireBuilderMethod("Bind"), bindRange_1));
                  }

                  const varSpace_5 = addVarsToVarSpace(varSpace_1, function (_mCustomOp_4, env_7) {
                    const _holder_6 = TemporarilySuspendReportingTypecheckResultsToSink(cenv_1.tcSink);

                    try {
                      const patternInput_22 = TcMatchPattern(cenv_1, NewInferenceType(), env_7, tpenv, $var228[3], null);
                      return [patternInput_22[2], patternInput_22[3]];
                    } finally {
                      if (hasInterface(_holder_6, "System.IDisposable")) {
                        _holder_6.Dispose();
                      }
                    }
                  });
                  const rhsExpr = $var228[2] ? mkSourceExpr($var228[4]) : $var228[4];
                  return trans(true, q, varSpace_5, $var228[1], function (holeFill_5) {
                    const consumeExpr_1 = new SynExpr(16, [false, $var228[3].Range, ofArray([new SynMatchClause(0, [$var228[3], null, holeFill_5, innerRange, new SequencePointInfoForTarget(0)])]), $var228[5], innerRange]);
                    return translatedCtxt(mkSynCall("Bind", bindRange_1, ofArray([rhsExpr, consumeExpr_1])));
                  });

                case 5:
                  const bindRange_2 = $var228[6].tag === 0 ? $var228[6].data : $var228[5].Range;

                  if (isQuery) {
                    error_1(new _Error(SR.tcBindMayNotBeUsedInQueries(), bindRange_2));
                  }

                  if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, bindRange_2, env.eAccessRights, "Using", builderTy).tail == null) {
                    error_1(new _Error(SR.tcRequireBuilderMethod("Using"), bindRange_2));
                  }

                  if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, bindRange_2, env.eAccessRights, "Bind", builderTy).tail == null) {
                    error_1(new _Error(SR.tcRequireBuilderMethod("Bind"), bindRange_2));
                  }

                  const consumeExpr_2 = new SynExpr(16, [false, bindRange_2, ofArray([new SynMatchClause(0, [$var228[4], null, transNoQueryOps($var228[2]), $var228[2].Range, new SequencePointInfoForTarget(0)])]), $var228[6], bindRange_2]);
                  const consumeExpr_3 = mkSynCall("Using", bindRange_2, ofArray([new SynExpr(28, $var228[1]), consumeExpr_2]));
                  const consumeExpr_4 = new SynExpr(16, [false, bindRange_2, ofArray([new SynMatchClause(0, [$var228[4], null, consumeExpr_3, $var228[1].idRange, new SequencePointInfoForTarget(0)])]), $var228[6], bindRange_2]);
                  const rhsExpr_1 = $var228[3] ? mkSourceExpr($var228[5]) : $var228[5];
                  return translatedCtxt(mkSynCall("Bind", bindRange_2, ofArray([rhsExpr_1, consumeExpr_4])));

                case 6:
                  return error_1(new _Error(SR.tcInvalidUseBangBinding(), $var228[5].Range));

                case 7:
                  const mMatch = $var228[4].tag === 0 ? $var228[4].data : $var228[3];

                  if (isQuery) {
                    error_1(new _Error(SR.tcMatchMayNotBeUsedWithQuery(), mMatch));
                  }

                  const clauses = map_1(function (_arg58) {
                    return new SynMatchClause(0, [_arg58.data[0], _arg58.data[1], transNoQueryOps(_arg58.data[2]), _arg58.data[3], _arg58.data[4]]);
                  }, $var228[1]);
                  return translatedCtxt(new SynExpr(17, [$var228[4], $var228[2], clauses, false, $var228[3]]));

                case 8:
                  const mTry_1 = $var228[7].tag === 0 ? $var228[7].data : $var228[6];

                  if (isQuery) {
                    error_1(new _Error(SR.tcTryWithMayNotBeUsedInQueries(), mTry_1));
                  }

                  const clauses_1 = map_1(function (_arg59) {
                    return new SynMatchClause(0, [_arg59.data[0], _arg59.data[1], transNoQueryOps(_arg59.data[2]), _arg59.data[3], _arg59.data[4]]);
                  }, $var228[4]);
                  const consumeExpr_5 = new SynExpr(16, [true, $var228[6], clauses_1, new SequencePointInfoForBinding(3), $var228[6]]);

                  if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, mTry_1, env.eAccessRights, "TryWith", builderTy).tail == null) {
                    error_1(new _Error(SR.tcRequireBuilderMethod("TryWith"), mTry_1));
                  }

                  if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, mTry_1, env.eAccessRights, "Delay", builderTy).tail == null) {
                    error_1(new _Error(SR.tcRequireBuilderMethod("Delay"), mTry_1));
                  }

                  return translatedCtxt(mkSynCall("TryWith", mTry_1, ofArray([mkSynCall("Delay", mTry_1, ofArray([mkSynDelay2(transNoQueryOps($var228[5]))])), consumeExpr_5])));

                case 9:
                  const yieldExpr = mkSourceExpr($var228[3]);

                  if ($var228[1]) {
                    if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, $var228[2], env.eAccessRights, "YieldFrom", builderTy).tail == null) {
                      error_1(new _Error(SR.tcRequireBuilderMethod("YieldFrom"), $var228[2]));
                    }

                    return translatedCtxt(mkSynCall("YieldFrom", $var228[2], ofArray([yieldExpr])));
                  } else {
                    if (isQuery) {
                      error_1(new _Error(SR.tcReturnMayNotBeUsedInQueries(), $var228[2]));
                    }

                    if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, $var228[2], env.eAccessRights, "ReturnFrom", builderTy).tail == null) {
                      errorR(new _Error(SR.tcRequireBuilderMethod("ReturnFrom"), $var228[2]));
                      return translatedCtxt(yieldExpr);
                    } else {
                      return translatedCtxt(mkSynCall("ReturnFrom", $var228[2], ofArray([yieldExpr])));
                    }
                  }

                case 10:
                  const methName = $var228[1] ? "Yield" : "Return";

                  if (isQuery ? !$var228[1] : false) {
                    error_1(new _Error(SR.tcReturnMayNotBeUsedInQueries(), $var228[2]));
                  }

                  if (TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, $var228[2], env.eAccessRights, methName, builderTy).tail == null) {
                    error_1(new _Error(SR.tcRequireBuilderMethod(methName), $var228[2]));
                  }

                  return translatedCtxt(mkSynCall(methName, $var228[2], ofArray([$var228[3]])));

                case 11:
                  return null;
              }
            }

        }
      }
    }
  };

  const transNoQueryOps = function (comp_3) {
    return trans(true, false, emptyVarSpace, comp_3, function (x_7) {
      return x_7;
    });
  };

  const trans = function ($var572, $var573, $var574, $var575, $var576) {
    trans: while (true) {
      const firstTry_1 = $var572;
      const q_1 = $var573;
      const varSpace_6 = $var574;
      const comp_4 = $var575;
      const translatedCtxt_1 = $var576;
      const matchValue_22 = tryTrans(firstTry_1, q_1, varSpace_6, comp_4, translatedCtxt_1);

      if (matchValue_22 == null) {
        if (comp_4.tag === 50) {
          const mUnit = comp_4.data[0].Range;
          const rhsExpr_2 = mkSourceExpr(comp_4.data[0]);

          if (isQuery) {
            error_1(new _Error(SR.tcBindMayNotBeUsedInQueries(), comp_4.data[1]));
          }

          const bodyExpr = TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, comp_4.data[1], env.eAccessRights, "Return", builderTy).tail == null ? new SynExpr(46, comp_4.data[1]) : new SynExpr(47, [[false, true], new SynExpr(2, [new SynConst(0), comp_4.data[1]]), comp_4.data[1]]);
          $var572 = true;
          $var573 = q_1;
          $var574 = varSpace_6;
          $var575 = new SynExpr(49, [new SequencePointInfoForBinding(1), false, false, new SynPat(0, [new SynConst(0), mUnit]), rhsExpr_2, bodyExpr, comp_4.data[1]]);
          $var576 = translatedCtxt_1;
          continue trans;
        } else if (isQuery ? checkForBinaryApp(comp_4) : false) {
          $var572 = true;
          $var573 = q_1;
          $var574 = varSpace_6;
          $var575 = new SynExpr(46, comp_4.Range);
          $var576 = translatedCtxt_1;
          continue trans;
        } else {
          if (isQuery ? !comp_4.IsArbExprAndThusAlreadyReportedError : false) {
            if (comp_4.tag === 45) {} else {
              errorR(new _Error(SR.tcUnrecognizedQueryOperator(), comp_4.RangeOfFirstPortion));
            }
          }

          $var572 = true;
          $var573 = q_1;
          $var574 = varSpace_6;
          $var575 = new SynExpr(46, comp_4.Range);

          $var576 = function (holeFill_6) {
            return translatedCtxt_1(new SynExpr(26, [new SequencePointInfoForSeq(2), true, comp_4, holeFill_6, comp_4.Range]));
          };

          continue trans;
        }
      } else {
        return getValue(matchValue_22);
      }
    }
  };

  const basicSynExpr = trans(true, hasCustomOperations(), LazyWithContext.NotLazy([new List(), env_1]), comp, function (holeFill_7) {
    return holeFill_7;
  });
  let delayedExpr;
  const matchValue_23 = TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, mBuilderVal, env.eAccessRights, "Delay", builderTy);

  if (matchValue_23.tail == null) {
    delayedExpr = basicSynExpr;
  } else {
    delayedExpr = mkSynCall("Delay", mBuilderVal, ofArray([mkSynDelay2(basicSynExpr)]));
  }

  const quotedSynExpr = isAutoQuote ? new SynExpr(1, [mkSynIdGet(mBuilderVal.MakeSynthetic(), CompileOpName("<@ @>")), false, delayedExpr, true, mWhole]) : delayedExpr;
  let runExpr;
  const matchValue_24 = TryFindIntrinsicOrExtensionMethInfo(cenv_1, env_1, mBuilderVal, env.eAccessRights, "Run", builderTy);

  if (matchValue_24.tail == null) {
    runExpr = quotedSynExpr;
  } else {
    runExpr = mkSynCall("Run", mBuilderVal, ofArray([quotedSynExpr]));
  }

  let lambdaExpr;
  const mBuilderVal_1 = mBuilderVal.MakeSynthetic();
  lambdaExpr = new SynExpr(15, [false, false, new SynSimplePats(0, [ofArray([mkSynSimplePatVar(false, mkSynId(mBuilderVal_1, builderValName))]), mBuilderVal_1]), runExpr, mBuilderVal_1]);
  let env_8;
  const $var232 = comp.tag === 47 ? comp.data[0][0] ? [0] : comp.data[0][1] ? [1] : [2] : [2];

  switch ($var232[0]) {
    case 0:
      const eContextInfo = new ContextInfo(8);
      env_8 = new TcEnv(env_1.eNameResEnv, env_1.eUngeneralizableItems, env_1.ePath, env_1.eCompPath, env_1.eAccessPath, env_1.eAccessRights, env_1.eInternalsVisibleCompPaths, env_1.eModuleOrNamespaceTypeAccumulator, eContextInfo, env_1.eFamilyType, env_1.eCtorInfo, env_1.eCallerMemberName);
      break;

    case 1:
      const eContextInfo_1 = new ContextInfo(7);
      env_8 = new TcEnv(env_1.eNameResEnv, env_1.eUngeneralizableItems, env_1.ePath, env_1.eCompPath, env_1.eAccessPath, env_1.eAccessRights, env_1.eInternalsVisibleCompPaths, env_1.eModuleOrNamespaceTypeAccumulator, eContextInfo_1, env_1.eFamilyType, env_1.eCtorInfo, env_1.eCallerMemberName);
      break;

    case 2:
      env_8 = env_1;
      break;
  }

  const patternInput_23 = TcExpr(cenv_1, op_MinusMinusGreater(builderTy, overallTy), env_8, tpenv, lambdaExpr);
  const coreExpr = mkApps(cenv_1.g, [patternInput_23[0], tyOfExpr(cenv_1.g, patternInput_23[0])], new List(), ofArray([interpExpr]), mBuilderVal);
  return [coreExpr, patternInput_23[1]];
}
export function TcSequenceExpression(cenv_1, env, tpenv, comp, overallTy, m) {
  const mkDelayedExpr = function (coreExpr) {
    const m_1 = Expr_get_Range.bind(coreExpr)();
    const overallTy_1 = tyOfExpr(cenv_1.g, coreExpr);
    return mkSeqDelay(cenv_1, env, m_1, overallTy_1, coreExpr);
  };

  const tryTcSequenceExprBody = function (env_1, genOuterTy, tpenv_1, comp_1) {
    var yexpr;
    var vf;
    var v;
    var genEnumElemTy;
    const $var233 = comp_1.tag === 12 ? [0, comp_1.data[2], comp_1.data[1].data, comp_1.data[0], comp_1.data[5], comp_1.data[6], comp_1.data[3], comp_1.data[4]] : comp_1.tag === 11 ? [1, comp_1.data[3], comp_1.data[4], comp_1.data[1], comp_1.data[5], comp_1.data[6], comp_1.data[0], comp_1.data[2]] : comp_1.tag === 10 ? [2, comp_1.data[3], comp_1.data[0], comp_1.data[1], comp_1.data[2]] : comp_1.tag === 24 ? [3, comp_1.data[2], comp_1.data[4], comp_1.data[3], comp_1.data[0], comp_1.data[1]] : comp_1.tag === 0 ? [4, comp_1.data[3]] : comp_1.tag === 46 ? [5, comp_1.data] : comp_1.tag === 50 ? [6, comp_1.data[0], comp_1.data[1]] : comp_1.tag === 26 ? comp_1.data[1] ? [7, comp_1.data[2], comp_1.data[3], comp_1.data[4], comp_1.data[0]] : [16] : comp_1.tag === 27 ? [8, comp_1.data[4], comp_1.data[2], comp_1.data[0], comp_1.data[6], comp_1.data[5], comp_1.data[3], comp_1.data[1]] : comp_1.tag === 22 ? comp_1.data[1] ? comp_1.data[2].tail != null ? comp_1.data[2].head.data[1].tag === 1 ? comp_1.data[2].tail.tail == null ? [10, comp_1.data[0], comp_1.data[2].head.data[11], comp_1.data[2].head.data[0], comp_1.data[3], comp_1.data[2].head.data[7], comp_1.data[2].head.data[9], comp_1.data[4]] : [16] : [16] : [16] : [9] : comp_1.tag === 49 ? [11, comp_1.data[6]] : comp_1.tag === 17 ? comp_1.data[3] ? [16] : [12, comp_1.data[2], comp_1.data[1], comp_1.data[0]] : comp_1.tag === 23 ? [13, comp_1.data[1]] : comp_1.tag === 48 ? [14, comp_1.data[0][0], comp_1.data[2], comp_1.data[1]] : comp_1.tag === 47 ? [15, comp_1.data[0][0], comp_1.data[2], comp_1.data[1]] : [16];

    switch ($var233[0]) {
      case 0:
        const patternInput = TcExprOfUnknownType(cenv_1, env_1, tpenv_1, $var233[7]);
        const patternInput_1 = ConvertArbitraryExprToEnumerable(cenv_1, patternInput[1], env_1, patternInput[0]);
        const patternInput_2 = TcMatchPattern(cenv_1, patternInput_1[1], env_1, patternInput[2], $var233[6], null);
        const patternInput_3 = tcSequenceExprBody(patternInput_2[3], genOuterTy, patternInput_2[4], $var233[4]);
        const matchValue = [patternInput_2[0], patternInput_2[2], patternInput_3[0]];
        const $var234 = matchValue[0].tag === 2 ? matchValue[0].data[0].tag === 1 ? matchValue[2].tag === 5 ? matchValue[2].data[0].tag === 1 ? matchValue[2].data[2].tail != null ? matchValue[2].data[2].tail.tail == null ? matchValue[2].data[3].tail != null ? matchValue[2].data[3].tail.tail == null ? (yexpr = matchValue[2].data[3].head, vf = matchValue[2].data[0].data[0], v = matchValue[0].data[1].data[0], genEnumElemTy = matchValue[2].data[2].head, matchValue[1].length === 1 ? valRefEq(cenv_1.g, vf, cenv_1.g.seq_singleton_vref) : false) ? [0, matchValue[2].data[2].head, matchValue[0].data[1].data[0], matchValue[2].data[0].data[0], matchValue[1], matchValue[2].data[3].head] : [1] : [1] : [1] : [1] : [1] : [1] : [1] : [1] : [1];

        switch ($var234[0]) {
          case 0:
            const enumExprMark = Expr_get_Range.bind(patternInput_1[0])();
            const lam = mkLambda_1(enumExprMark, $var234[2], $var234[5], $var234[1]);
            const enumExpr = mkCoerceIfNeeded(cenv_1.g, mkSeqTy(cenv_1.g, patternInput_1[1]), tyOfExpr(cenv_1.g, patternInput_1[0]), patternInput_1[0]);
            return [mkCallSeqMap(cenv_1.g, $var233[5], patternInput_1[1], $var234[1], lam, enumExpr), patternInput_3[1]];

          case 1:
            const enumExprMark_1 = Expr_get_Range.bind(patternInput_1[0])();
            const patternInput_4 = compileSeqExprMatchClauses(cenv_1, env_1, enumExprMark_1, patternInput_2[0], patternInput_2[2], patternInput_3[0], patternInput_1[1], genOuterTy);
            const lam_1 = mkLambda_1(enumExprMark_1, patternInput_4[0], patternInput_4[1], tyOfExpr(cenv_1.g, patternInput_4[1]));
            return [mkSeqCollect(cenv_1, env_1, $var233[5], patternInput_1[1], genOuterTy, lam_1, patternInput_1[0]), patternInput_3[1]];
        }

      case 1:
        return tcSequenceExprBody(env_1, genOuterTy, tpenv_1, elimFastIntegerForLoop($var233[6], $var233[3], $var233[7], $var233[1], $var233[2], $var233[4], $var233[5]));

      case 2:
        const patternInput_5 = TcExpr(cenv_1, cenv_1.g.bool_ty, env_1, tpenv_1, $var233[3]);
        const patternInput_6 = tcSequenceExprBody(env_1, genOuterTy, patternInput_5[1], $var233[4]);
        const guardExprMark = Expr_get_Range.bind(patternInput_5[0])();
        const guardExpr = mkUnitDelayLambda(cenv_1.g, guardExprMark, patternInput_5[0]);
        const innerExpr = mkDelayedExpr(patternInput_6[0]);
        return [mkSeqFromFunctions(cenv_1, env_1, guardExprMark, genOuterTy, guardExpr, innerExpr), patternInput_6[1]];

      case 3:
        const patternInput_7 = tcSequenceExprBody(env_1, genOuterTy, tpenv_1, $var233[4]);
        const patternInput_8 = TcExpr(cenv_1, cenv_1.g.unit_ty, env_1, patternInput_7[1], $var233[5]);
        const unwindExprMark = Expr_get_Range.bind(patternInput_8[0])();
        const unwindExpr = mkUnitDelayLambda(cenv_1.g, unwindExprMark, patternInput_8[0]);
        const innerExpr_1 = mkDelayedExpr(patternInput_7[0]);
        const innerExprMark = Expr_get_Range.bind(innerExpr_1)();
        return [mkSeqFinally(cenv_1, env_1, innerExprMark, genOuterTy, innerExpr_1, unwindExpr), patternInput_8[1]];

      case 4:
        return error_1(new _Error(SR.tcConstructIsAmbiguousInSequenceExpression(), $var233[1]));

      case 5:
        return [mkSeqEmpty(cenv_1, env_1, $var233[1], genOuterTy), tpenv_1];

      case 6:
        return error_1(new _Error(SR.tcDoBangIllegalInSequenceExpression(), $var233[2]));

      case 7:
        const matchValue_1 = tryTcSequenceExprBody(env_1, genOuterTy, tpenv_1, $var233[1]);

        if (matchValue_1 != null) {
          const tpenv_2 = getValue(matchValue_1)[1];
          const innerExpr1 = getValue(matchValue_1)[0];
          const patternInput_9 = tcSequenceExprBody(env_1, genOuterTy, tpenv_2, $var233[2]);
          const innerExpr2 = mkDelayedExpr(patternInput_9[0]);
          return [mkSeqAppend(cenv_1, env_1, $var233[1].Range, genOuterTy, innerExpr1, innerExpr2), patternInput_9[1]];
        } else {
          const patternInput_10 = TcStmtThatCantBeCtorBody(cenv_1, env_1, tpenv_1, $var233[1]);
          const patternInput_11 = tcSequenceExprBody(env_1, genOuterTy, patternInput_10[1], $var233[2]);
          return [new Expr(2, [patternInput_10[0], patternInput_11[0], new SequentialOpKind(0), $var233[4], $var233[3]]), patternInput_11[1]];
        }

      case 8:
        const patternInput_12 = TcExpr(cenv_1, cenv_1.g.bool_ty, env_1, tpenv_1, $var233[3]);
        const patternInput_13 = tcSequenceExprBody(env_1, genOuterTy, patternInput_12[1], $var233[7]);
        const elseComp = $var233[2] == null ? new SynExpr(46, $var233[5]) : getValue($var233[2]);
        const patternInput_14 = tcSequenceExprBody(env_1, genOuterTy, patternInput_13[1], elseComp);
        return [mkCond($var233[6], new SequencePointInfoForTarget(0), $var233[4], genOuterTy, patternInput_12[0], patternInput_13[0], patternInput_14[0]), patternInput_14[1]];

      case 9:
        return TcLinearExprs(function (ty, envinner, tpenv_3, e) {
          return tcSequenceExprBody(envinner, ty, tpenv_3, e);
        }, cenv_1, env_1, overallTy, tpenv_1, true, comp_1, function (x) {
          return x;
        });

      case 10:
        const bindPatTy = NewInferenceType();
        const inputExprTy = NewInferenceType();
        const patternInput_15 = TcMatchPattern(cenv_1, bindPatTy, env_1, tpenv_1, $var233[5], null);
        UnifyTypes(cenv_1, env_1, m, inputExprTy, bindPatTy);
        const patternInput_16 = TcExpr(cenv_1, inputExprTy, env_1, patternInput_15[4], $var233[6]);
        const patternInput_17 = tcSequenceExprBody(patternInput_15[3], genOuterTy, patternInput_16[1], $var233[4]);
        const inputExprMark = Expr_get_Range.bind(patternInput_16[0])();
        const patternInput_18 = compileSeqExprMatchClauses(cenv_1, env_1, inputExprMark, patternInput_15[0], patternInput_15[2], patternInput_17[0], bindPatTy, genOuterTy);
        const consumeExpr = mkLambda_1($var233[7], patternInput_18[0], patternInput_18[1], genOuterTy);
        return [mkSeqUsing(cenv_1, env_1, $var233[7], bindPatTy, genOuterTy, patternInput_16[0], consumeExpr), patternInput_17[1]];

      case 11:
        return error_1(new _Error(SR.tcUseForInSequenceExpression(), $var233[1]));

      case 12:
        const patternInput_19 = TcExprOfUnknownType(cenv_1, env_1, tpenv_1, $var233[2]);
        const patternInput_22 = mapFold(function (tpenv_4, _arg60) {
          const patternInput_20 = TcMatchPattern(cenv_1, patternInput_19[1], env_1, tpenv_4, _arg60.data[0], _arg60.data[1]);
          const patternInput_21 = tcSequenceExprBody(patternInput_20[3], genOuterTy, patternInput_20[4], _arg60.data[2]);
          return [new TypedMatchClause(0, [patternInput_20[0], patternInput_20[1], new DecisionTreeTarget(0, [patternInput_20[2], patternInput_21[0], _arg60.data[4]]), patternInput_20[0].Range]), patternInput_21[1]];
        }, patternInput_19[2], $var233[1], ofArray);
        const inputExprTy_1 = tyOfExpr(cenv_1.g, patternInput_19[0]);
        const inputExprMark_1 = Expr_get_Range.bind(patternInput_19[0])();
        const patternInput_23 = CompilePatternForMatchClauses(cenv_1, env_1, inputExprMark_1, inputExprMark_1, true, new ActionOnFailure(0), inputExprTy_1, genOuterTy, patternInput_22[0]);
        return [mkLet($var233[3], inputExprMark_1, patternInput_23[0], patternInput_19[0], patternInput_23[1]), patternInput_22[1]];

      case 13:
        return error_1(new _Error(SR.tcTryIllegalInSequenceExpression(), $var233[1]));

      case 14:
        const patternInput_24 = TcExprOfUnknownType(cenv_1, env_1, tpenv_1, $var233[3]);

        if (!$var233[1]) {
          errorR(new _Error(SR.tcUseYieldBangForMultipleResults(), $var233[2]));
        }

        AddCxTypeMustSubsumeType(new ContextInfo(0), env_1.DisplayEnv, cenv_1.css, $var233[2], new OptionalTrace(0), genOuterTy, patternInput_24[1]);
        return [mkCoerceExpr(patternInput_24[0], genOuterTy, $var233[2], patternInput_24[1]), patternInput_24[2]];

      case 15:
        const genResultTy = NewInferenceType();

        if (!$var233[1]) {
          errorR(new _Error(SR.tcSeqResultsUseYield(), $var233[2]));
        }

        UnifyTypes(cenv_1, env_1, $var233[2], genOuterTy, mkSeqTy(cenv_1.g, genResultTy));
        const patternInput_25 = TcExpr(cenv_1, genResultTy, env_1, tpenv_1, $var233[3]);
        return [mkCallSeqSingleton(cenv_1.g, $var233[2], genResultTy, patternInput_25[0]), patternInput_25[1]];

      case 16:
        return null;
    }
  };

  const tcSequenceExprBody = function (env_2, genOuterTy_1, tpenv_5, comp_2) {
    const matchValue_2 = tryTcSequenceExprBody(env_2, genOuterTy_1, tpenv_5, comp_2);

    if (matchValue_2 == null) {
      const m_2 = comp_2.Range;
      let env_3;
      const eContextInfo = new ContextInfo(13, genOuterTy_1);
      env_3 = new TcEnv(env_2.eNameResEnv, env_2.eUngeneralizableItems, env_2.ePath, env_2.eCompPath, env_2.eAccessPath, env_2.eAccessRights, env_2.eInternalsVisibleCompPaths, env_2.eModuleOrNamespaceTypeAccumulator, eContextInfo, env_2.eFamilyType, env_2.eCtorInfo, env_2.eCallerMemberName);
      const patternInput_26 = TcStmtThatCantBeCtorBody(cenv_1, env_3, tpenv_5, comp_2);
      return [new Expr(2, [patternInput_26[0], mkSeqEmpty(cenv_1, env_3, m_2, genOuterTy_1), new SequentialOpKind(0), new SequencePointInfoForSeq(2), m_2]), patternInput_26[1]];
    } else {
      return getValue(matchValue_2);
    }
  };

  const genEnumElemTy_1 = NewInferenceType();
  UnifyTypes(cenv_1, env, m, overallTy, mkSeqTy(cenv_1.g, genEnumElemTy_1));
  const patternInput_27 = tcSequenceExprBody(env, overallTy, tpenv, comp);
  const delayedExpr = mkDelayedExpr(patternInput_27[0]);
  return [delayedExpr, patternInput_27[1]];
}
export function Propagate(cenv_1, overallTy, env, tpenv, expr, exprty, delayed) {
  const propagate = function (delayedList, mExpr, exprty_1) {
    const $var235 = delayedList.tail != null ? delayedList.head.tag === 4 ? [1] : delayedList.head.tag === 2 ? [1] : delayedList.head.tag === 0 ? [2, delayedList.head.data[1], delayedList.tail, delayedList.head.data[2]] : delayedList.head.tag === 1 ? [3, delayedList.head.data[1], delayedList.tail, delayedList.head.data[2]] : [1] : [0];

    switch ($var235[0]) {
      case 0:
        if (!(delayed.tail == null)) {
          UnifyTypesAndRecover(cenv_1, env, mExpr, overallTy, exprty_1);
        }

        break;

      case 1:
        break;

      case 2:
        propagate($var235[2], $var235[3], exprty_1);
        break;

      case 3:
        const denv = env.DisplayEnv;
        const matchValue = UnifyFunctionTypeUndoIfFailed(cenv_1, denv, mExpr, exprty_1);

        if (matchValue == null) {
          const mArg = $var235[1].Range;
          const $var236 = $var235[1].tag === 14 ? [0] : $var235[1].tag === 13 ? $var235[1].data[0] ? [2] : [1] : [2];

          switch ($var236[0]) {
            case 0:
              break;

            case 1:
              RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects_Delayed(cenv_1, env, tpenv, delayed);

              if (IsIndexerType(cenv_1.g, cenv_1.amap, expr.Type)) {
                const matchValue_1 = expr.Expr;

                if (matchValue_1.tag === 1) {
                  error_1(new NotAFunctionButIndexer(denv, overallTy, matchValue_1.data[0].DisplayName, mExpr, mArg));
                } else {
                  error_1(new NotAFunctionButIndexer(denv, overallTy, null, mExpr, mArg));
                }
              } else {
                error_1(new NotAFunction(denv, overallTy, mExpr, mArg));
              }

              break;

            case 2:
              RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects_Delayed(cenv_1, env, tpenv, delayed);
              error_1(new NotAFunction(denv, overallTy, mExpr, mArg));
              break;
          }
        } else {
          const resultTy = getValue(matchValue)[1];
          propagate($var235[2], $var235[3], resultTy);
        }

        break;
    }
  };

  propagate(delayed, expr.Range, exprty);
}
export function PropagateThenTcDelayed(cenv_1, overallTy, env, tpenv, mExpr, expr, exprty, atomicFlag, delayed) {
  Propagate(cenv_1, overallTy, env, tpenv, expr, exprty, delayed);
  return TcDelayed(cenv_1, overallTy, env, tpenv, mExpr, expr, exprty, atomicFlag, delayed);
}
export function TcDelayed(cenv_1, overallTy, env, tpenv, mExpr, expr, exprty, atomicFlag, delayed) {
  if (atomicFlag === 0) {
    CallExprHasTypeSink(cenv_1.tcSink, mExpr, env.NameEnv, exprty, env.DisplayEnv, env.eAccessRights);
  }

  const $var237 = delayed.tail != null ? delayed.head.tag === 2 ? [1, delayed.head.data[0], delayed.head.data[1], delayed.tail] : delayed.head.tag === 1 ? [2, delayed.head.data[1], delayed.head.data[0], delayed.head.data[2], delayed.tail] : delayed.head.tag === 0 ? [3, delayed.head.data[2], delayed.head.data[1]] : delayed.head.tag === 4 ? [4] : [0] : [0];

  switch ($var237[0]) {
    case 0:
      UnifyTypesAndRecover(cenv_1, env, mExpr, overallTy, exprty);
      return [expr.Expr, tpenv];

    case 1:
      return TcLookupThen(cenv_1, overallTy, env, tpenv, mExpr, expr.Expr, exprty, $var237[1], $var237[3], $var237[2]);

    case 2:
      return TcFunctionApplicationThen(cenv_1, overallTy, env, tpenv, $var237[3], expr, exprty, $var237[1], $var237[2], $var237[4]);

    case 3:
      return error_1(new _Error(SR.tcUnexpectedTypeArguments(), $var237[2]));

    case 4:
      return error_1(new _Error(SR.tcInvalidAssignment(), mExpr));
  }
}
export function delayRest(rest, mPrior, delayed) {
  if (rest.tail == null) {
    return delayed;
  } else {
    const mPriorAndLongId = unionRanges(mPrior, rangeOfLid(rest));
    return new List(new DelayedItem(2, [rest, mPriorAndLongId]), delayed);
  }
}
export function TcFunctionApplicationThen(cenv_1, overallTy, env, tpenv, mExprAndArg, expr, exprty, synArg, atomicFlag, delayed) {
  var vf;
  const denv = env.DisplayEnv;
  const mArg = synArg.Range;
  const mFunExpr = expr.Range;
  const matchValue = UnifyFunctionTypeUndoIfFailed(cenv_1, denv, mFunExpr, exprty);

  if (matchValue == null) {
    const $var238 = synArg.tag === 14 ? synArg.data[0] ? [1] : [0, synArg.data[1], synArg.data[3], synArg.data[2]] : [1];

    switch ($var238[0]) {
      case 0:
        const patternInput = TcComputationOrSequenceExpression(cenv_1, env, overallTy, mFunExpr, [expr.Expr, exprty], tpenv, $var238[3]);
        return TcDelayed(cenv_1, overallTy, env, patternInput[1], mExprAndArg, MakeApplicableExprNoFlex(cenv_1, patternInput[0]), tyOfExpr(cenv_1.g, patternInput[0]), 1, delayed);

      case 1:
        return error_1(new NotAFunction(denv, overallTy, mFunExpr, mArg));
    }
  } else {
    const resultTy = getValue(matchValue)[1];
    const domainTy = getValue(matchValue)[0];
    const $var239 = synArg.tag === 14 ? synArg.data[0] ? [1] : [0, synArg.data[2], synArg.data[3], synArg.data[1]] : [1];

    switch ($var239[0]) {
      case 0:
        if ($var239[3].contents) {
          $var239[3].contents = true;
        } else {
          const $var240 = expr.data[1].tag === 11 ? expr.data[1].data[0].tag === 24 ? expr.data[1].data[2].tail != null ? expr.data[1].data[2].head.tag === 5 ? expr.data[1].data[2].head.data[0].tag === 1 ? expr.data[1].data[2].tail.tail == null ? (vf = expr.data[1].data[2].head.data[0].data[0], valRefEq(cenv_1.g, vf, cenv_1.g.seq_vref)) ? [0, expr.data[1].data[2].head.data[0].data[0]] : [1] : [1] : [1] : [1] : [1] : [1] : [1];

          switch ($var240[0]) {
            case 0:
              $var239[3].contents = true;
              break;

            case 1:
              $var239[3].contents = false;
              break;
          }
        }

        break;

      case 1:
        break;
    }

    const patternInput_1 = TcExpr(cenv_1, domainTy, env, tpenv, synArg);
    const exprAndArg = buildApp(cenv_1, expr, exprty, patternInput_1[0], mExprAndArg);
    return TcDelayed(cenv_1, overallTy, env, patternInput_1[1], mExprAndArg, exprAndArg, resultTy, atomicFlag, delayed);
  }
}
export function TcLongIdentThen(cenv_1, overallTy, env, tpenv, _arg4, delayed) {
  let typeNameResInfo;
  const $var241 = delayed.tail != null ? delayed.head.tag === 0 ? delayed.tail.tail != null ? delayed.tail.head.tag === 3 ? [0, delayed.head.data[0]] : delayed.tail.head.tag === 2 ? [0, delayed.head.data[0]] : [1, delayed.head.data[0]] : [1, delayed.head.data[0]] : [2] : [2];

  switch ($var241[0]) {
    case 0:
      typeNameResInfo = new TypeNameResolutionInfo(0, [new TypeNameResolutionFlag(1), TypeNameResolutionStaticArgsInfo.FromTyArgs($var241[1].length)]);
      break;

    case 1:
      typeNameResInfo = new TypeNameResolutionInfo(0, [new TypeNameResolutionFlag(0), TypeNameResolutionStaticArgsInfo.FromTyArgs($var241[1].length)]);
      break;

    case 2:
      typeNameResInfo = TypeNameResolutionInfo.Default;
      break;
  }

  const nameResolutionResult = ResolveLongIdentAsExprAndComputeRange(cenv_1.tcSink, cenv_1.nameResolver, rangeOfLid(_arg4.data[0]), env.eAccessRights, env.eNameResEnv, typeNameResInfo, _arg4.data[0]);
  return TcItemThen(cenv_1, overallTy, env, tpenv, nameResolutionResult[0], nameResolutionResult[1], nameResolutionResult[2], nameResolutionResult[3], delayed);
}
export function TcItemThen(cenv_1, overallTy, env, tpenv, item, mItem, rest, afterResolution, delayed) {
  TcItemThen: while (true) {
    const delayed_1 = delayRest(rest, mItem, delayed);
    const $var242 = item.tag === 1 ? [0, item] : item.tag === 4 ? [0, item] : item.tag === 2 ? [0, item] : item.tag === 14 ? item.data[1].tail != null ? [1, item.data[0], item.data[1].head] : [13] : item.tag === 10 ? [2, item.data[0], item.data[1]] : item.tag === 11 ? [3, item.data[1], item.data[0]] : item.tag === 12 ? [4] : item.tag === 19 ? [5, item.data[0], item.data[1]] : item.tag === 13 ? [6, item.data] : item.tag === 0 ? [7, item.data] : item.tag === 9 ? [8, item.data[0], item.data[1]] : item.tag === 7 ? [9, item.data] : item.tag === 5 ? [10, item.data] : item.tag === 8 ? [11, item.data] : item.tag === 15 ? [12, item.data[0], item.data[1]] : [13];

    switch ($var242[0]) {
      case 0:
        const ucaseAppTy = NewInferenceType();
        let patternInput_1;

        if ($var242[1].tag === 2) {
          const aparity = ActivePatternInfo_get_Names.bind($var242[1].data[0])().length | 0;
          const $var243 = aparity === 0 ? [0] : aparity === 1 ? [0] : [1];

          switch ($var243[0]) {
            case 0:
              const mkConstrApp = function (_mArgs, _arg21) {
                const $var244 = _arg21.tail != null ? _arg21.tail.tail == null ? [0, _arg21.head] : [1] : [1];

                switch ($var244[0]) {
                  case 0:
                    return $var244[1];

                  case 1:
                    return error_1(new InternalError("ApplyUnionCaseOrExn", mItem));
                }
              };

              patternInput_1 = [mkConstrApp, ofArray([ucaseAppTy]), toList(delay(function () {
                return collect_1(function (matchValue) {
                  return singleton(mkSynId(matchValue[1], matchValue[0]));
                }, $var242[1].data[0].ActiveTagsWithRanges);
              }))];
              break;

            case 1:
              const ucref = mkChoiceCaseRef(cenv_1.g, mItem, aparity, $var242[1].data[2]);
              const patternInput = infoOfTyconRef(mItem, ucref.TyconRef);
              const ucinfo = new UnionCaseInfo(0, [patternInput[2], ucref]);
              patternInput_1 = ApplyUnionCaseOrExnTypes(mItem, cenv_1, env, ucaseAppTy, new Item(1, [ucinfo, false]));
              break;
          }
        } else {
          patternInput_1 = ApplyUnionCaseOrExnTypes(mItem, cenv_1, env, ucaseAppTy, $var242[1]);
        }

        const nargtys = patternInput_1[1].length | 0;
        const flexes = map_1($var245 => !isTyparTy(cenv_1.g, $var245), patternInput_1[1]);

        const _FittedArgs___ = function (arg) {
          var args;
          var arg_1;
          let $var246;

          const activePatternResult42179 = _SynExprParen___(arg);

          if (activePatternResult42179 != null) {
            if (getValue(activePatternResult42179)[0].tag === 4) {
              if (args = getValue(activePatternResult42179)[0].data[0], nargtys > 1) {
                $var246 = [0, getValue(activePatternResult42179)[0].data[0]];
              } else if (arg.tag === 4) {
                if (nargtys > 1) {
                  $var246 = [0, arg.data[0]];
                } else {
                  $var246 = [1];
                }
              } else {
                $var246 = [1];
              }
            } else if (arg.tag === 4) {
              if (nargtys > 1) {
                $var246 = [0, arg.data[0]];
              } else {
                $var246 = [1];
              }
            } else {
              $var246 = [1];
            }
          } else if (arg.tag === 4) {
            if (nargtys > 1) {
              $var246 = [0, arg.data[0]];
            } else {
              $var246 = [1];
            }
          } else {
            $var246 = [1];
          }

          switch ($var246[0]) {
            case 0:
              return $var246[1];

            case 1:
              let $var247;

              const activePatternResult42178 = _SynExprParen___(arg);

              if (activePatternResult42178 != null) {
                if (arg_1 = getValue(activePatternResult42178)[0], nargtys === 1) {
                  $var247 = [0, getValue(activePatternResult42178)[0]];
                } else if (nargtys === 1) {
                  $var247 = [0, arg];
                } else {
                  $var247 = [1];
                }
              } else if (nargtys === 1) {
                $var247 = [0, arg];
              } else {
                $var247 = [1];
              }

              switch ($var247[0]) {
                case 0:
                  return ofArray([$var247[1]]);

                case 1:
                  return null;
              }

          }
        };

        let $var248;

        if (delayed_1.tail != null) {
          if (delayed_1.head.tag === 1) {
            const activePatternResult42195 = _FittedArgs___(delayed_1.head.data[1]);

            if (activePatternResult42195 != null) {
              $var248 = [0, getValue(activePatternResult42195), delayed_1.head.data[0], delayed_1.head.data[2], delayed_1.head.data[1], delayed_1.tail];
            } else {
              $var248 = [1];
            }
          } else {
            $var248 = [1];
          }
        } else {
          $var248 = [1];
        }

        switch ($var248[0]) {
          case 0:
            if ($var248[5].tail == null) {
              UnifyTypes(cenv_1, env, $var248[3], overallTy, ucaseAppTy);
            }

            const nargs = $var248[1].length | 0;
            UnionCaseOrExnCheck(env, nargtys, nargs, $var248[3]);
            let args_1;
            const patternInput_2 = GetMethodArgs($var248[4]);

            if (patternInput_2[1].tail == null) {
              args_1 = $var248[1];
            } else {
              const fittedArgs = new Array(nargtys).fill(null);
              let currentIndex = 0;

              for (let arg_2 of patternInput_2[0]) {
                fittedArgs[currentIndex] = arg_2;
                currentIndex = currentIndex + 1 | 0;
              }

              for (let forLoopVar of patternInput_2[1]) {
                const matchValue_1 = tryFindIndex(function (id2) {
                  return forLoopVar[1].idText === id2.idText;
                }, patternInput_1[2]);

                if (matchValue_1 == null) {
                  let isSpecialCaseForBackwardCompatibility;

                  if (currentIndex !== -1 ? currentIndex < nargtys : false) {
                    const matchValue_2 = stripTyEqns(cenv_1.g, item_6(currentIndex, patternInput_1[1]));

                    if (matchValue_2.tag === 1) {
                      if (tyconRefEq(cenv_1.g, cenv_1.g.bool_tcr, matchValue_2.data[0])) {
                        isSpecialCaseForBackwardCompatibility = true;
                      } else {
                        isSpecialCaseForBackwardCompatibility = tyconRefEq(cenv_1.g, cenv_1.g.system_Bool_tcref, matchValue_2.data[0]);
                      }
                    } else if (matchValue_2.tag === 5) {
                      isSpecialCaseForBackwardCompatibility = true;
                    } else {
                      isSpecialCaseForBackwardCompatibility = false;
                    }
                  } else {
                    isSpecialCaseForBackwardCompatibility = false;
                  }

                  if (isSpecialCaseForBackwardCompatibility) {
                    fittedArgs[currentIndex] = item_6(currentIndex, $var248[1]);
                    currentIndex = currentIndex + 1 | 0;
                  } else {
                    let caseName;

                    if ($var242[1].tag === 1) {
                      caseName = $var242[1].data[0].Name;
                    } else if ($var242[1].tag === 4) {
                      caseName = $var242[1].data.DisplayName;
                    } else {
                      throw new Error("impossible");
                    }

                    error_1(new _Error(SR.tcUnionCaseConstructorDoesNotHaveFieldWithGivenName(caseName, forLoopVar[1].idText), forLoopVar[1].idRange));
                  }
                } else {
                  if (fittedArgs[getValue(matchValue_1)] == null) {
                    fittedArgs[getValue(matchValue_1)] = forLoopVar[2];
                    const argContainerOpt = $var242[1].tag === 1 ? new ArgumentContainer(2, $var242[1].data[0]) : $var242[1].tag === 4 ? new ArgumentContainer(1, $var242[1].data) : null;
                    const argItem = new Item(20, [item_6(getValue(matchValue_1), patternInput_1[2]), item_6(getValue(matchValue_1), patternInput_1[1]), argContainerOpt]);
                    CallNameResolutionSink(cenv_1.tcSink, forLoopVar[1].idRange, env.NameEnv, argItem, argItem, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, env.eAccessRights);
                  } else {
                    error_1(new _Error(SR.tcUnionCaseFieldCannotBeUsedMoreThanOnce(forLoopVar[1].idText), forLoopVar[1].idRange));
                  }

                  currentIndex = -1 | 0;
                }
              }

              args_1 = ofArray(fittedArgs);
            }

            const patternInput_3 = TcExprs(cenv_1, env, $var248[3], tpenv, flexes, patternInput_1[1], args_1);
            return PropagateThenTcDelayed(cenv_1, overallTy, env, patternInput_3[1], $var248[3], MakeApplicableExprNoFlex(cenv_1, patternInput_1[0]($var248[3], patternInput_3[0])), ucaseAppTy, $var248[2], $var248[5]);

          case 1:
            const $var249 = delayed_1.tail != null ? delayed_1.head.tag === 0 ? [0, delayed_1.tail, delayed_1.head.data[2], delayed_1.head.data[0], delayed_1.head.data[1]] : [1] : [1];

            switch ($var249[0]) {
              case 0:
                return error_1(new _Error(SR.tcUnexpectedTypeArguments(), $var249[4]));

              case 1:
                let patternInput_5;

                if (nargtys === 1 ? $var242[1].tag === 2 ? true : false : false) {
                  UnifyTypes(cenv_1, env, mItem, patternInput_1[1].head, cenv_1.g.unit_ty);
                  patternInput_5 = [1, function () {
                    return patternInput_1[0](mItem, ofArray([mkUnit(cenv_1.g, mItem)]));
                  }];
                } else if (nargtys === 0) {
                  patternInput_5 = [0, function () {
                    return patternInput_1[0](mItem, new List());
                  }];
                } else {
                  patternInput_5 = [nargtys, function () {
                    const patternInput_4 = unzip(mapIndexed(function (i, ty) {
                      return mkCompGenLocal(mItem, "arg" + i.toString(), ty);
                    }, patternInput_1[1]));
                    const constrApp = patternInput_1[0](mItem, patternInput_4[1]);
                    const lam = mkMultiLambda(mItem, patternInput_4[0], constrApp, tyOfExpr(cenv_1.g, constrApp));
                    return lam;
                  }];
                }

                UnionCaseOrExnCheck(env, nargtys, patternInput_5[0], mItem);
                const expr = patternInput_5[1]();
                const exprTy = tyOfExpr(cenv_1.g, expr);
                return PropagateThenTcDelayed(cenv_1, overallTy, env, tpenv, mItem, MakeApplicableExprNoFlex(cenv_1, expr), exprTy, 0, delayed_1);
            }

        }

      case 1:
        const $var250 = delayed_1.tail != null ? delayed_1.head.tag === 0 ? delayed_1.tail.tail != null ? delayed_1.tail.head.tag === 2 ? [0, delayed_1.head.data[1], delayed_1.tail.head.data[0], delayed_1.head.data[2], delayed_1.tail.head.data[1], delayed_1.tail.tail, delayed_1.head.data[0]] : [1, delayed_1.tail, delayed_1.head.data[1], delayed_1.head.data[2], delayed_1.head.data[0]] : [1, delayed_1.tail, delayed_1.head.data[1], delayed_1.head.data[2], delayed_1.head.data[0]] : [2] : [2];

        switch ($var250[0]) {
          case 0:
            const patternInput_6 = TcNestedTypeApplication(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, $var250[3], $var242[2], $var250[6]);
            const item_1 = new Item(14, [$var242[1], ofArray([patternInput_6[0]])]);
            CallNameResolutionSink(cenv_1.tcSink, $var250[3], env.NameEnv, item_1, item_1, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, env.eAccessRights);
            const tupledArg = ResolveExprDotLongIdentAndComputeRange(cenv_1.tcSink, cenv_1.nameResolver, unionRanges($var250[3], $var250[4]), env.eAccessRights, env.eNameResEnv, patternInput_6[0], $var250[2], new FindMemberFlag(0), true);
            cenv_1 = cenv_1;
            overallTy = overallTy;
            env = env;
            tpenv = patternInput_6[1];
            item = tupledArg[0];
            mItem = tupledArg[1];
            rest = tupledArg[2];
            afterResolution = tupledArg[3];
            delayed = $var250[5];
            continue TcItemThen;

          case 1:
            const patternInput_7 = TcNestedTypeApplication(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, $var250[3], $var242[2], $var250[4]);
            const item_2 = new Item(14, [$var242[1], ofArray([patternInput_7[0]])]);
            CallNameResolutionSink(cenv_1.tcSink, $var250[3], env.NameEnv, item_2, item_2, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, env.eAccessRights);
            return error_1(new _Error(SR.tcInvalidUseOfTypeName(), mItem));

          case 2:
            return error_1(new _Error(SR.tcInvalidUseOfTypeName(), mItem));
        }

      case 2:
        const meths = map_1(function (minfo) {
          return [minfo, null];
        }, $var242[2]);
        const $var251 = delayed_1.tail != null ? delayed_1.head.tag === 1 ? [0, delayed_1.head.data[1], delayed_1.head.data[0], delayed_1.head.data[2], delayed_1.tail] : delayed_1.head.tag === 0 ? [1, delayed_1.head.data[2], delayed_1.head.data[1], delayed_1.tail, delayed_1.head.data[0]] : [2] : [2];

        switch ($var251[0]) {
          case 0:
            return TcMethodApplicationThen(cenv_1, env, overallTy, null, tpenv, null, new List(), $var251[3], mItem, $var242[1], env.eAccessRights, new Mutates(2), false, meths, afterResolution, new ValUseFlag(1), ofArray([$var251[1]]), $var251[2], $var251[4]);

          case 1:
            const patternInput_8 = TcTypesOrMeasures(null, cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, $var251[4], $var251[2]);
            CallNameResolutionSink(cenv_1.tcSink, $var251[1], env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, env.eAccessRights);
            const $var252 = $var251[3].tail != null ? $var251[3].head.tag === 1 ? [0, $var251[3].head.data[1], $var251[3].head.data[0], $var251[3].head.data[2], $var251[3].tail] : [1] : [1];

            switch ($var252[0]) {
              case 0:
                return TcMethodApplicationThen(cenv_1, env, overallTy, null, patternInput_8[1], patternInput_8[0], new List(), $var252[3], mItem, $var242[1], env.eAccessRights, new Mutates(2), false, meths, afterResolution, new ValUseFlag(1), ofArray([$var252[1]]), $var252[2], $var252[4]);

              case 1:
                return TcMethodApplicationThen(cenv_1, env, overallTy, null, patternInput_8[1], patternInput_8[0], new List(), $var251[1], mItem, $var242[1], env.eAccessRights, new Mutates(2), false, meths, afterResolution, new ValUseFlag(1), new List(), 0, $var251[3]);
            }

          case 2:
            return TcMethodApplicationThen(cenv_1, env, overallTy, null, tpenv, null, new List(), mItem, mItem, $var242[1], env.eAccessRights, new Mutates(2), false, meths, afterResolution, new ValUseFlag(1), new List(), 0, delayed_1);
        }

      case 3:
        const objTy = $var242[1].tail == null ? error_1(new _Error(SR.tcTypeHasNoAccessibleConstructor(), mItem)) : $var242[1].head.ApparentEnclosingType;
        const $var253 = delayed_1.tail != null ? delayed_1.head.tag === 1 ? [0, delayed_1.head.data[1], delayed_1.head.data[2], delayed_1.tail] : delayed_1.head.tag === 0 ? delayed_1.tail.tail != null ? delayed_1.tail.head.tag === 1 ? [1, delayed_1.head.data[1], delayed_1.tail.head.data[1], delayed_1.tail.head.data[2], delayed_1.head.data[2], delayed_1.tail.tail, delayed_1.head.data[0]] : [2, delayed_1.head.data[1], delayed_1.head.data[2], delayed_1.tail, delayed_1.head.data[0]] : [2, delayed_1.head.data[1], delayed_1.head.data[2], delayed_1.tail, delayed_1.head.data[0]] : [3] : [3];

        switch ($var253[0]) {
          case 0:
            CallExprHasTypeSink(cenv_1.tcSink, $var253[2], env.NameEnv, objTy, env.DisplayEnv, env.eAccessRights);
            return TcCtorCall(true, cenv_1, env, tpenv, overallTy, objTy, mItem, item, false, ofArray([$var253[1]]), $var253[2], $var253[3], afterResolution);

          case 1:
            const patternInput_9 = TcNestedTypeApplication(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, $var253[4], objTy, $var253[6]);
            CallExprHasTypeSink(cenv_1.tcSink, $var253[3], env.NameEnv, patternInput_9[0], env.DisplayEnv, env.eAccessRights);
            const patternInput_10 = [item, $var242[1]];
            iterate(function (minfo_1) {
              UnifyTypes(cenv_1, env, $var253[4], minfo_1.ApparentEnclosingType, patternInput_9[0]);
            }, patternInput_10[1]);
            return TcCtorCall(true, cenv_1, env, patternInput_9[1], overallTy, patternInput_9[0], $var253[4], patternInput_10[0], false, ofArray([$var253[2]]), $var253[3], $var253[5], afterResolution);

          case 2:
            const patternInput_11 = TcNestedTypeApplication(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, $var253[2], objTy, $var253[4]);
            const resolvedItem = new Item(14, [$var242[2], ofArray([patternInput_11[0]])]);
            CallNameResolutionSink(cenv_1.tcSink, $var253[2], env.NameEnv, resolvedItem, resolvedItem, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, env.eAccessRights);
            iterate(function (minfo_2) {
              UnifyTypes(cenv_1, env, $var253[2], minfo_2.ApparentEnclosingType, patternInput_11[0]);
            }, $var242[1]);
            return TcCtorCall(true, cenv_1, env, patternInput_11[1], overallTy, patternInput_11[0], $var253[2], item, false, new List(), $var253[2], $var253[3], afterResolution);

          case 3:
            return TcCtorCall(true, cenv_1, env, tpenv, overallTy, objTy, mItem, item, false, new List(), mItem, delayed_1, afterResolution);
        }

      case 4:
        return error_1(new _Error(SR.tcInvalidUseOfInterfaceType(), mItem));

      case 5:
        const isPrefix = IsPrefixOperator($var242[1].idText);
        const isTernary = IsTernaryOperator($var242[1].idText);
        const argData = isPrefix ? ofArray([new SynTypar(0, [mkSynId(mItem, cenv_1.synArgNameGenerator.New()), new TyparStaticReq(1), true])]) : isTernary ? ofArray([new SynTypar(0, [mkSynId(mItem, cenv_1.synArgNameGenerator.New()), new TyparStaticReq(1), true]), new SynTypar(0, [mkSynId(mItem, cenv_1.synArgNameGenerator.New()), new TyparStaticReq(1), true]), new SynTypar(0, [mkSynId(mItem, cenv_1.synArgNameGenerator.New()), new TyparStaticReq(1), true])]) : ofArray([new SynTypar(0, [mkSynId(mItem, cenv_1.synArgNameGenerator.New()), new TyparStaticReq(1), true]), new SynTypar(0, [mkSynId(mItem, cenv_1.synArgNameGenerator.New()), new TyparStaticReq(1), true])]);
        const retTyData = new SynTypar(0, [mkSynId(mItem, cenv_1.synArgNameGenerator.New()), new TyparStaticReq(1), true]);
        const argTypars = map_1(function (d) {
          return NewTypar(new TyparKind(0), new TyparRigidity(3), d, false, new TyparDynamicReq(1), new List(), false, false);
        }, argData);
        const retTypar = NewTypar(new TyparKind(0), new TyparRigidity(3), retTyData, false, new TyparDynamicReq(1), new List(), false, false);

        const argTys = function (list) {
          return map_1(function (tp) {
            return mkTyparTy(tp);
          }, list);
        }(argTypars);

        const retTy = mkTyparTy(retTypar);
        const patternInput_12 = unzip(mapIndexed(function (i_1, ty_1) {
          return mkCompGenLocal(mItem, "arg" + i_1.toString(), ty_1);
        }, argTys));
        const memberFlags = StaticMemberFlags(new MemberKind_2(2));
        const logicalCompiledName = ComputeLogicalName($var242[1], memberFlags);
        const traitInfo = new TraitConstraintInfo(0, [argTys, logicalCompiledName, memberFlags, argTys, retTy, $var242[2]]);
        const expr_1 = new Expr(11, [new TOp(29, traitInfo), new List(), patternInput_12[1], mItem]);
        const expr_2 = mkLambdas(mItem, new List(), patternInput_12[0], expr_1, retTy);

        const isSimpleArgument = function (e) {
          isSimpleArgument: while (true) {
            const $var254 = e.tag === 0 ? [0, e.data[0]] : e.tag === 3 ? [0, e.data[0]] : e.tag === 21 ? [0, e.data[0]] : e.tag === 37 ? [0, e.data[0]] : e.tag === 38 ? [0, e.data[0]] : e.tag === 31 ? [0, e.data[0]] : e.tag === 39 ? [0, e.data[0]] : e.tag === 40 ? [0, e.data[0]] : e.tag === 41 ? [0, e.data[0]] : e.tag === 43 ? [0, e.data[1]] : e.tag === 1 ? [0, e.data[2]] : e.tag === 42 ? [1] : e.tag === 28 ? [1] : e.tag === 2 ? [1] : e.tag === 29 ? [1] : e.tag === 4 ? [2, e.data[0]] : e.tag === 5 ? [2, e.data[0]] : e.tag === 6 ? [2, e.data[1]] : e.tag === 7 ? [3] : e.tag === 20 ? [4] : e.tag === 27 ? [5] : e.tag === 33 ? [6] : e.tag === 9 ? [7] : e.tag === 10 ? [7] : e.tag === 11 ? [7] : e.tag === 12 ? [7] : e.tag === 13 ? [7] : e.tag === 14 ? [7] : e.tag === 15 ? [7] : e.tag === 16 ? [7] : e.tag === 17 ? [7] : e.tag === 18 ? [7] : e.tag === 19 ? [7] : e.tag === 58 ? [7] : e.tag === 23 ? [7] : e.tag === 24 ? [7] : e.tag === 25 ? [7] : e.tag === 26 ? [7] : e.tag === 22 ? [7] : e.tag === 32 ? [7] : e.tag === 34 ? [7] : e.tag === 30 ? [7] : e.tag === 45 ? [7] : e.tag === 35 ? [7] : e.tag === 36 ? [7] : e.tag === 51 ? [7] : e.tag === 52 ? [7] : e.tag === 53 ? [7] : e.tag === 54 ? [7] : e.tag === 55 ? [7] : e.tag === 56 ? [7] : e.tag === 57 ? [7] : e.tag === 46 ? [7] : e.tag === 47 ? [7] : e.tag === 48 ? [7] : e.tag === 49 ? [7] : e.tag === 50 ? [7] : e.tag === 44 ? [7] : [0, e.data[2]];

            switch ($var254[0]) {
              case 0:
                e = $var254[1];
                continue isSimpleArgument;

              case 1:
                return true;

              case 2:
                return function (list_1) {
                  return forAll(isSimpleArgument, list_1);
                }($var254[1]);

              case 3:
                if (forAll($var255 => isSimpleArgument(function (tuple) {
                  return tuple[0];
                }($var255)), defaultArg(e.data[1], [], $var256 => [$var256]))) {
                  return forAll($var258 => function (option) {
                    return forAll(isSimpleArgument, defaultArg(option, [], $var257 => [$var257]));
                  }(function (tupledArg_1) {
                    return p23(tupledArg_1[0], tupledArg_1[1], tupledArg_1[2]);
                  }($var258)), e.data[2]);
                } else {
                  return false;
                }

              case 4:
                if (isSimpleArgument(e.data[2])) {
                  e = e.data[3];
                  continue isSimpleArgument;
                } else {
                  return false;
                }

              case 5:
                if (isSimpleArgument(e.data[0]) ? isSimpleArgument(e.data[1]) : false) {
                  return forAll(isSimpleArgument, defaultArg(e.data[2], [], $var259 => [$var259]));
                } else {
                  return false;
                }

              case 6:
                e = e.data[0];
                continue isSimpleArgument;

              case 7:
                return false;
            }
          }
        };

        Propagate(cenv_1, overallTy, env, tpenv, MakeApplicableExprNoFlex(cenv_1, expr_2), tyOfExpr(cenv_1.g, expr_2), delayed_1);
        let patternInput_13;

        const pred = function (_arg22) {
          if (_arg22.tag === 1) {
            return isSimpleArgument(_arg22.data[1]);
          } else {
            return false;
          }
        };

        patternInput_13 = [toList(takeWhile(pred, delayed_1)), toList(skipWhile(pred, delayed_1))];
        const intermediateTy = patternInput_13[1].tail == null ? overallTy : NewInferenceType();
        const patternInput_14 = TcDelayed(cenv_1, intermediateTy, env, tpenv, mItem, MakeApplicableExprNoFlex(cenv_1, expr_2), tyOfExpr(cenv_1.g, expr_2), 1, patternInput_13[0]);
        AddCxMethodConstraint(env.DisplayEnv, cenv_1.css, mItem, new OptionalTrace(0), traitInfo);
        const patternInput_15 = TcDelayed(cenv_1, overallTy, env, patternInput_14[1], mItem, MakeApplicableExprNoFlex(cenv_1, patternInput_14[0]), intermediateTy, 1, patternInput_13[1]);
        return [patternInput_15[0], patternInput_15[1]];

      case 6:
        const $var260 = delayed_1.tail != null ? delayed_1.head.tag === 1 ? [0, delayed_1.head.data[1], delayed_1.head.data[0], delayed_1.head.data[2], delayed_1.tail] : delayed_1.head.tag === 0 ? delayed_1.tail.tail != null ? delayed_1.tail.head.tag === 1 ? [1, delayed_1.head.data[1], delayed_1.tail.head.data[1], delayed_1.tail.head.data[0], delayed_1.tail.head.data[2], delayed_1.head.data[2], delayed_1.tail.tail, delayed_1.head.data[0]] : [2] : [2] : [2] : [2];

        switch ($var260[0]) {
          case 0:
            return TcNewDelegateThen(cenv_1, overallTy, env, tpenv, mItem, $var260[3], $var242[1], $var260[1], $var260[2], $var260[4]);

          case 1:
            const patternInput_16 = TcNestedTypeApplication(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, $var260[5], $var242[1], $var260[7]);
            const item_3 = new Item(13, patternInput_16[0]);
            CallNameResolutionSink(cenv_1.tcSink, $var260[5], env.NameEnv, item_3, item_3, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, env.eAccessRights);
            return TcNewDelegateThen(cenv_1, overallTy, env, patternInput_16[1], mItem, $var260[4], patternInput_16[0], $var260[2], $var260[3], $var260[6]);

          case 2:
            return error_1(new _Error(SR.tcInvalidUseOfDelegate(), mItem));
        }

      case 7:
        const $var261 = delayed_1.tail != null ? delayed_1.head.tag === 4 ? [0, delayed_1.head.data[0], delayed_1.head.data[1], delayed_1.tail] : delayed_1.head.tag === 0 ? [1, delayed_1.head.data[1], delayed_1.head.data[2], delayed_1.tail, delayed_1.head.data[0]] : [2] : [2];

        switch ($var261[0]) {
          case 0:
            if (!($var261[3].tail == null)) {
              error_1(new _Error(SR.tcInvalidAssignment(), $var261[2]));
            }

            UnifyTypes(cenv_1, env, $var261[2], overallTy, cenv_1.g.unit_ty);
            $var242[1].Deref.SetHasBeenReferenced();
            CheckValAccessible(mItem, env.eAccessRights, $var242[1]);
            CommitOperationResult(CheckValAttributes(cenv_1.g, $var242[1], mItem));
            const vty = $var242[1].Type;
            let vty2;

            if (isByrefTy(cenv_1.g, vty)) {
              vty2 = destByrefTy(cenv_1.g, vty);
            } else {
              if (!$var242[1].IsMutable) {
                error_1(new ValNotMutable(env.DisplayEnv, $var242[1], $var261[2]));
              }

              vty2 = vty;
            }

            const patternInput_17 = TcExprFlex(cenv_1, true, vty2, env, tpenv, $var261[1]);
            const vexp = isByrefTy(cenv_1.g, vty) ? mkAddrSet($var261[2], $var242[1], patternInput_17[0]) : mkValSet($var261[2], $var242[1], patternInput_17[0]);
            return PropagateThenTcDelayed(cenv_1, overallTy, env, patternInput_17[1], $var261[2], MakeApplicableExprNoFlex(cenv_1, vexp), tyOfExpr(cenv_1.g, vexp), 1, $var261[3]);

          case 1:
            const checkTys = function (tpenv_1, kinds) {
              return TcTypesOrMeasures(kinds, cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv_1, $var261[4], mItem);
            };

            const patternInput_18 = TcVal(true, cenv_1, env, tpenv, $var242[1], [new ValUseFlag(1), checkTys], afterResolution, mItem);
            const vexpFlex = patternInput_18[2] ? MakeApplicableExprNoFlex(cenv_1, patternInput_18[1]) : MakeApplicableExprWithFlex(cenv_1, env, patternInput_18[1]);
            return PropagateThenTcDelayed(cenv_1, overallTy, env, patternInput_18[5], $var261[2], vexpFlex, vexpFlex.Type, 0, $var261[3]);

          case 2:
            const patternInput_19 = TcVal(true, cenv_1, env, tpenv, $var242[1], null, afterResolution, mItem);
            const vexpFlex_1 = patternInput_19[2] ? MakeApplicableExprNoFlex(cenv_1, patternInput_19[1]) : MakeApplicableExprWithFlex(cenv_1, env, patternInput_19[1]);
            return PropagateThenTcDelayed(cenv_1, overallTy, env, patternInput_19[5], mItem, vexpFlex_1, vexpFlex_1.Type, 0, delayed_1);
        }

      case 8:
        if ($var242[2].tail == null) {
          error_1(new InternalError("Unexpected error: empty property list", mItem));
        }

        const pinfo = $var242[2].head;
        const patternInput_20 = pinfo.IsIndexer ? GetMemberApplicationArgs(delayed_1, cenv_1, env, tpenv) : [0, null, ofArray([mkSynUnit(mItem)]), delayed_1, tpenv];

        if (!pinfo.IsStatic) {
          error_1(new _Error(SR.tcPropertyIsNotStatic($var242[1]), mItem));
        }

        const $var262 = patternInput_20[3].tail != null ? patternInput_20[3].head.tag === 4 ? [0, patternInput_20[3].head.data[0], patternInput_20[3].head.data[1], patternInput_20[3].tail] : [1] : [1];

        switch ($var262[0]) {
          case 0:
            const args_2 = pinfo.IsIndexer ? patternInput_20[2] : new List();

            if (!($var262[3].tail == null)) {
              error_1(new _Error(SR.tcInvalidAssignment(), $var262[2]));
            }

            UnifyTypes(cenv_1, env, $var262[2], overallTy, cenv_1.g.unit_ty);
            const meths_1 = SettersOfPropInfos($var242[2]);

            if (meths_1.tail == null) {
              error_1(new _Error(SR.tcPropertyCannotBeSet1($var242[1]), mItem));
            }

            return TcMethodApplicationThen(cenv_1, env, overallTy, null, patternInput_20[4], patternInput_20[1], new List(), $var262[2], mItem, $var242[1], env.eAccessRights, new Mutates(2), true, meths_1, afterResolution, new ValUseFlag(1), append(args_2, ofArray([$var262[1]])), 1, $var262[3]);

          case 1:
            const meths_2 = GettersOfPropInfos($var242[2]);

            if (meths_2.tail == null) {
              error_1(new _Error(SR.tcPropertyIsNotReadable($var242[1]), mItem));
            }

            return TcMethodApplicationThen(cenv_1, env, overallTy, null, patternInput_20[4], patternInput_20[1], new List(), mItem, mItem, $var242[1], env.eAccessRights, new Mutates(2), true, meths_2, afterResolution, new ValUseFlag(1), patternInput_20[2], 0, patternInput_20[3]);
        }

      case 9:
        CheckILFieldInfoAccessible(cenv_1.g, cenv_1.amap, mItem, env.eAccessRights, $var242[1]);

        if (!$var242[1].IsStatic) {
          error_1(new _Error(SR.tcFieldIsNotStatic($var242[1].FieldName), mItem));
        }

        CheckILFieldAttributes(cenv_1.g, $var242[1], mItem);
        const fref = $var242[1].ILFieldRef;
        const exprty = $var242[1].FieldType(cenv_1.amap, mItem);
        const $var263 = delayed_1.tail != null ? delayed_1.head.tag === 4 ? [0, delayed_1.tail, delayed_1.head.data[0], delayed_1.head.data[1]] : [1] : [1];

        switch ($var263[0]) {
          case 0:
            UnifyTypes(cenv_1, env, $var263[3], overallTy, cenv_1.g.unit_ty);
            const patternInput_21 = TcExprFlex(cenv_1, true, exprty, env, tpenv, $var263[2]);
            const expr_3 = BuildILStaticFieldSet($var263[3], $var242[1], patternInput_21[0]);
            return [expr_3, patternInput_21[1]];

          case 1:
            let expr_4;
            const matchValue_3 = $var242[1].LiteralValue;

            if (matchValue_3 == null) {
              const isValueType = $var242[1].IsValueType;
              const valu = isValueType ? new ILBoxity(1) : new ILBoxity(0);
              const fspec = mkILFieldSpec(fref, mkILNamedTy(valu, fref.DeclaringTypeRef, new List()));
              expr_4 = mkAsmExpr(append(ofArray([mkNormalLdsfld(fspec)]), $var242[1].IsInitOnly ? ofArray([new ILInstr(33)]) : new List()), $var242[1].TypeInst, new List(), ofArray([exprty]), mItem);
            } else {
              expr_4 = new Expr(0, [TcFieldInit(mItem, getValue(matchValue_3)), mItem, exprty]);
            }

            return PropagateThenTcDelayed(cenv_1, overallTy, env, tpenv, mItem, MakeApplicableExprWithFlex(cenv_1, env, expr_4), exprty, 0, delayed_1);
        }

      case 10:
        CheckRecdFieldInfoAccessible(cenv_1.amap, mItem, env.eAccessRights, $var242[1]);

        if (!$var242[1].IsStatic) {
          error_1(new _Error(SR.tcFieldIsNotStatic($var242[1].Name), mItem));
        }

        CommitOperationResult(CheckRecdFieldInfoAttributes(cenv_1.g, $var242[1], mItem));
        const fref_1 = $var242[1].RecdFieldRef;
        const fieldTy = $var242[1].FieldType;
        const $var264 = delayed_1.tail != null ? delayed_1.head.tag === 4 ? [0, delayed_1.head.data[0], delayed_1.head.data[1], delayed_1.tail] : [1] : [1];

        switch ($var264[0]) {
          case 0:
            if (!($var264[3].tail == null)) {
              error_1(new _Error(SR.tcInvalidAssignment(), $var264[2]));
            }

            CheckRecdFieldMutation(mItem, env.DisplayEnv, $var242[1]);
            UnifyTypes(cenv_1, env, $var264[2], overallTy, cenv_1.g.unit_ty);
            const fieldTy_1 = $var242[1].FieldType;
            const patternInput_22 = TcExprFlex(cenv_1, true, fieldTy_1, env, tpenv, $var264[1]);
            const expr_5 = mkStaticRecdFieldSet($var242[1].RecdFieldRef, $var242[1].TypeInst, patternInput_22[0], $var264[2]);
            return [expr_5, patternInput_22[1]];

          case 1:
            let expr_6;
            const matchValue_4 = $var242[1].LiteralValue;

            if (matchValue_4 == null) {
              expr_6 = mkStaticRecdFieldGet(fref_1, $var242[1].TypeInst, mItem);
            } else {
              expr_6 = new Expr(0, [getValue(matchValue_4), mItem, fieldTy]);
            }

            return PropagateThenTcDelayed(cenv_1, overallTy, env, tpenv, mItem, MakeApplicableExprWithFlex(cenv_1, env, expr_6), fieldTy, 0, delayed_1);
        }

      case 11:
        return TcEventValueThen(cenv_1, overallTy, env, tpenv, mItem, mItem, null, $var242[1], delayed_1);

      case 12:
        RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects_Delayed(cenv_1, env, tpenv, delayed_1);
        const matchValue_5 = $var242[2]();

        if (matchValue_5 != null) {
          return error_1(new _Error(SR.tcCustomOperationNotUsedCorrectly2($var242[1], getValue(matchValue_5)), mItem));
        } else {
          return error_1(new _Error(SR.tcCustomOperationNotUsedCorrectly($var242[1]), mItem));
        }

      case 13:
        return error_1(new _Error(SR.tcLookupMayNotBeUsedHere(), mItem));
    }
  }
}
export function GetSynMemberApplicationArgs(delayed, tpenv) {
  const $var265 = delayed.tail != null ? delayed.head.tag === 1 ? [0, delayed.head.data[1], delayed.head.data[0], delayed.tail] : delayed.head.tag === 0 ? delayed.tail.tail != null ? delayed.tail.head.tag === 1 ? [1, delayed.tail.head.data[2], delayed.tail.head.data[1], delayed.tail.head.data[0], delayed.head.data[1], delayed.tail.tail, delayed.head.data[0]] : [2, delayed.head.data[1], delayed.tail, delayed.head.data[0]] : [2, delayed.head.data[1], delayed.tail, delayed.head.data[0]] : [3, delayed] : [3, delayed];

  switch ($var265[0]) {
    case 0:
      return [$var265[2], null, ofArray([$var265[1]]), $var265[3], tpenv];

    case 1:
      return [$var265[3], [$var265[6], $var265[4]], ofArray([$var265[2]]), $var265[5], tpenv];

    case 2:
      return [0, [$var265[3], $var265[1]], new List(), $var265[2], tpenv];

    case 3:
      return [1, null, new List(), $var265[1], tpenv];
  }
}
export function TcMemberTyArgsOpt(cenv_1, env, tpenv, tyargsOpt) {
  if (tyargsOpt != null) {
    const tyargs = getValue(tyargsOpt)[0];
    const mTypeArgs = getValue(tyargsOpt)[1];
    const patternInput = TcTypesOrMeasures(null, cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, tyargs, mTypeArgs);
    return [patternInput[0], patternInput[1]];
  } else {
    return [null, tpenv];
  }
}
export function GetMemberApplicationArgs(delayed, cenv_1, env, tpenv) {
  const patternInput = GetSynMemberApplicationArgs(delayed, tpenv);
  const patternInput_1 = TcMemberTyArgsOpt(cenv_1, env, patternInput[4], patternInput[1]);
  return [patternInput[0], patternInput_1[0], patternInput[2], patternInput[3], patternInput_1[1]];
}
export function TcLookupThen(cenv_1, overallTy, env, tpenv, mObjExpr, objExpr, objExprTy, longId, delayed, mExprAndLongId) {
  const objArgs = ofArray([objExpr]);
  let findFlag;
  const baseCall = IsBaseCall(objArgs);

  if (baseCall) {
    findFlag = new FindMemberFlag(1);
  } else {
    findFlag = new FindMemberFlag(0);
  }

  if (isTyparTy(cenv_1.g, objExprTy)) {
    GeneralizationHelpers.CanonicalizePartialInferenceProblem(cenv_1, env.DisplayEnv, mExprAndLongId, freeInTypeLeftToRight(cenv_1.g, false, objExprTy));
  }

  const patternInput = ResolveExprDotLongIdentAndComputeRange(cenv_1.tcSink, cenv_1.nameResolver, mExprAndLongId, env.eAccessRights, env.eNameResEnv, objExprTy, longId, findFlag, false);
  const mExprAndItem = unionRanges(mObjExpr, patternInput[1]);
  const delayed_1 = delayRest(patternInput[2], mExprAndItem, delayed);

  switch (patternInput[0].tag) {
    case 10:
      const patternInput_1 = GetSynMemberApplicationArgs(delayed_1, tpenv);
      const mutates = (patternInput[0].data[0] === "MoveNext" ? true : patternInput[0].data[0] === "GetNextArg") ? new Mutates(0) : new Mutates(1);
      const patternInput_2 = TcMemberTyArgsOpt(cenv_1, env, patternInput_1[4], patternInput_1[1]);
      const meths = map_1(function (minfo) {
        return [minfo, null];
      }, patternInput[0].data[1]);
      return TcMethodApplicationThen(cenv_1, env, overallTy, null, patternInput_2[1], patternInput_2[0], objArgs, mExprAndItem, patternInput[1], patternInput[0].data[0], env.eAccessRights, mutates, false, meths, patternInput[3], new ValUseFlag(1), patternInput_1[2], patternInput_1[0], patternInput_1[3]);

    case 9:
      if (patternInput[0].data[1].tail == null) {
        error_1(new InternalError("Unexpected error: empty property list", patternInput[1]));
      }

      const pinfo = patternInput[0].data[1].head;
      const patternInput_3 = pinfo.IsIndexer ? GetMemberApplicationArgs(delayed_1, cenv_1, env, tpenv) : [0, null, ofArray([mkSynUnit(patternInput[1])]), delayed_1, tpenv];

      if (pinfo.IsStatic) {
        error_1(new _Error(SR.tcPropertyIsStatic(patternInput[0].data[0]), patternInput[1]));
      }

      const $var266 = patternInput_3[3].tail != null ? patternInput_3[3].head.tag === 4 ? [0, patternInput_3[3].head.data[0], patternInput_3[3].head.data[1], patternInput_3[3].tail] : [1] : [1];

      switch ($var266[0]) {
        case 0:
          const args = pinfo.IsIndexer ? patternInput_3[2] : new List();

          if (!($var266[3].tail == null)) {
            error_1(new _Error(SR.tcInvalidAssignment(), $var266[2]));
          }

          UnifyTypes(cenv_1, env, $var266[2], overallTy, cenv_1.g.unit_ty);
          const meths_1 = SettersOfPropInfos(patternInput[0].data[1]);

          if (meths_1.tail == null) {
            error_1(new _Error(SR.tcPropertyCannotBeSet1(patternInput[0].data[0]), patternInput[1]));
          }

          const mut = isStructTy(cenv_1.g, tyOfExpr(cenv_1.g, objExpr)) ? new Mutates(0) : new Mutates(1);
          return TcMethodApplicationThen(cenv_1, env, overallTy, null, patternInput_3[4], patternInput_3[1], objArgs, $var266[2], patternInput[1], patternInput[0].data[0], env.eAccessRights, mut, true, meths_1, patternInput[3], new ValUseFlag(1), append(args, ofArray([$var266[1]])), patternInput_3[0], new List());

        case 1:
          const meths_2 = GettersOfPropInfos(patternInput[0].data[1]);

          if (meths_2.tail == null) {
            error_1(new _Error(SR.tcPropertyIsNotReadable(patternInput[0].data[0]), patternInput[1]));
          }

          return TcMethodApplicationThen(cenv_1, env, overallTy, null, patternInput_3[4], patternInput_3[1], objArgs, mExprAndItem, patternInput[1], patternInput[0].data[0], env.eAccessRights, new Mutates(1), true, meths_2, patternInput[3], new ValUseFlag(1), patternInput_3[2], patternInput_3[0], patternInput_3[3]);
      }

    case 5:
      RecdFieldInstanceChecks(cenv_1.g, cenv_1.amap, env.eAccessRights, patternInput[1], patternInput[0].data);
      const tgty = patternInput[0].data.DeclaringType;
      const valu = isStructTy(cenv_1.g, tgty);
      AddCxTypeMustSubsumeType(new ContextInfo(0), env.DisplayEnv, cenv_1.css, patternInput[1], new OptionalTrace(0), tgty, objExprTy);
      const objExpr_1 = valu ? objExpr : mkCoerceExpr(objExpr, tgty, mExprAndItem, objExprTy);
      const fieldTy = patternInput[0].data.FieldType;
      const $var267 = delayed_1.tail != null ? delayed_1.head.tag === 4 ? [0, delayed_1.head.data[0], delayed_1.head.data[1], delayed_1.tail] : [1] : [1];

      switch ($var267[0]) {
        case 0:
          if (!($var267[3].tail == null)) {
            error_1(new _Error(SR.tcInvalidAssignment(), patternInput[1]));
          }

          CheckRecdFieldMutation(patternInput[1], env.DisplayEnv, patternInput[0].data);
          UnifyTypes(cenv_1, env, $var267[2], overallTy, cenv_1.g.unit_ty);
          const patternInput_4 = TcExprFlex(cenv_1, true, fieldTy, env, tpenv, $var267[1]);
          return [BuildRecdFieldSet(cenv_1.g, $var267[2], objExpr_1, patternInput[0].data, patternInput_4[0]), patternInput_4[1]];

        case 1:
          const objExpr_ = mkRecdFieldGet(cenv_1.g, objExpr_1, patternInput[0].data.RecdFieldRef, patternInput[0].data.TypeInst, mExprAndItem);
          return PropagateThenTcDelayed(cenv_1, overallTy, env, tpenv, mExprAndItem, MakeApplicableExprWithFlex(cenv_1, env, objExpr_), fieldTy, 0, delayed_1);
      }

    case 7:
      ILFieldInstanceChecks(cenv_1.g, cenv_1.amap, env.eAccessRights, patternInput[1], patternInput[0].data);
      const exprty = patternInput[0].data.FieldType(cenv_1.amap, patternInput[1]);
      const $var268 = delayed_1.tail != null ? delayed_1.head.tag === 4 ? [0, delayed_1.tail, delayed_1.head.data[0], delayed_1.head.data[1]] : [1] : [1];

      switch ($var268[0]) {
        case 0:
          UnifyTypes(cenv_1, env, $var268[3], overallTy, cenv_1.g.unit_ty);
          const patternInput_5 = TcExprFlex(cenv_1, true, exprty, env, tpenv, $var268[2]);
          const expr = BuildILFieldSet(cenv_1.g, $var268[3], objExpr, patternInput[0].data, patternInput_5[0]);
          return [expr, patternInput_5[1]];

        case 1:
          const expr_1 = BuildILFieldGet(cenv_1.g, cenv_1.amap, mExprAndItem, objExpr, patternInput[0].data);
          return PropagateThenTcDelayed(cenv_1, overallTy, env, tpenv, mExprAndItem, MakeApplicableExprWithFlex(cenv_1, env, expr_1), exprty, 0, delayed_1);
      }

    case 8:
      return TcEventValueThen(cenv_1, overallTy, env, tpenv, patternInput[1], mExprAndItem, [objExpr, objExprTy], patternInput[0].data, delayed_1);

    case 12:
    case 13:
      return error_1(new _Error(SR.tcConstructorsCannotBeFirstClassValues(), patternInput[1]));

    default:
      return error_1(new _Error(SR.tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields(), patternInput[1]));
  }
}
export function TcEventValueThen(cenv_1, overallTy, env, tpenv, mItem, mExprAndItem, objDetails, einfo, delayed) {
  const nm = einfo.EventName;
  const matchValue = [objDetails, einfo.IsStatic];
  const $var269 = matchValue[0] == null ? matchValue[1] ? [2] : [1] : matchValue[1] ? [0] : [2];

  switch ($var269[0]) {
    case 0:
      error_1(new _Error(SR.tcEventIsStatic(nm), mItem));
      break;

    case 1:
      error_1(new _Error(SR.tcEventIsNotStatic(nm), mItem));
      break;

    case 2:
      break;
  }

  const delegateType = einfo.GetDelegateType(cenv_1.amap, mItem);
  const patternInput = GetSigOfFunctionForDelegate(cenv_1.infoReader, delegateType, mItem, env.eAccessRights);
  const objArgs = toList(defaultArg(defaultArg(objDetails, null, function (tuple) {
    return tuple[0];
  }), [], $var270 => [$var270]));
  MethInfoChecks(cenv_1.g, cenv_1.amap, true, null, objArgs, env.eAccessRights, mItem, patternInput.data[0]);
  const argsTy = ArgsTypOfEventInfo(cenv_1.infoReader, mItem, env.eAccessRights, einfo);

  if (!slotSigHasVoidReturnTy(patternInput.data[0].GetSlotSig(cenv_1.amap, mItem))) {
    errorR(nonStandardEventError(einfo.EventName, mItem));
  }

  const delEventTy = mkIEventType(cenv_1.g, delegateType, argsTy);

  const bindObjArgs = function (f) {
    if (objDetails != null) {
      const objExprTy = getValue(objDetails)[1];
      const objExpr = getValue(objDetails)[0];
      return mkCompGenLetIn(mItem, "eventTarget", objExprTy, objExpr, function (tupledArg) {
        return f(ofArray([tupledArg[1]]));
      });
    } else {
      return f(new List());
    }
  };

  const expr = bindObjArgs(function (objVars) {
    var patternInput_1;
    var patternInput_2;
    var patternInput_3;
    var patternInput_4;
    var fvty;
    var patternInput_5;
    var createExpr;
    return mkCallCreateEvent(cenv_1.g, mItem, delegateType, argsTy, (patternInput_1 = mkCompGenLocal(mItem, "eventDelegate", delegateType), patternInput_2 = BuildPossiblyConditionalMethodCall(cenv_1, env, new Mutates(1), mItem, false, einfo.AddMethod, new ValUseFlag(1), new List(), objVars, ofArray([patternInput_1[1]])), mkLambda_1(mItem, patternInput_1[0], patternInput_2[0], cenv_1.g.unit_ty)), (patternInput_3 = mkCompGenLocal(mItem, "eventDelegate", delegateType), patternInput_4 = BuildPossiblyConditionalMethodCall(cenv_1, env, new Mutates(1), mItem, false, einfo.RemoveMethod, new ValUseFlag(1), new List(), objVars, ofArray([patternInput_3[1]])), mkLambda_1(mItem, patternInput_3[0], patternInput_4[0], cenv_1.g.unit_ty)), (fvty = op_MinusMinusGreater(cenv_1.g.obj_ty, op_MinusMinusGreater(argsTy, cenv_1.g.unit_ty)), patternInput_5 = mkCompGenLocal(mItem, "callback", fvty), createExpr = BuildNewDelegateExpr(einfo, cenv_1.g, cenv_1.amap, delegateType, patternInput.data[0], patternInput.data[1], patternInput_5[1], fvty, mItem), mkLambda_1(mItem, patternInput_5[0], createExpr, delegateType)));
  });
  return PropagateThenTcDelayed(cenv_1, overallTy, env, tpenv, mExprAndItem, MakeApplicableExprNoFlex(cenv_1, expr), delEventTy, 0, delayed);
}
export function TcMethodApplicationThen(cenv_1, env, overallTy, objTyOpt, tpenv, callerTyArgs, objArgs, m, mItem, methodName, ad, mut, isProp, meths, afterResolution, isSuperInit, args, atomicFlag, delayed) {
  const mWholeExpr = fold(function (m_1, arg) {
    return unionRanges(m_1, arg.Range);
  }, m, args);
  const exprTy = delayed.tail == null ? overallTy : NewInferenceType();
  const patternInput = TcMethodApplication(false, cenv_1, env, tpenv, callerTyArgs, objArgs, mWholeExpr, mItem, methodName, objTyOpt, ad, mut, isProp, meths, afterResolution, isSuperInit, args, exprTy, delayed);
  const expr = patternInput[0][0];
  const delayed_1 = patternInput[0][2];
  const attributeAssignedNamedItems = patternInput[0][1];

  if (!(attributeAssignedNamedItems.tail == null)) {
    const patternInput_1 = attributeAssignedNamedItems.head;
    errorR(new _Error(SR.tcNamedArgumentDidNotMatch(patternInput_1.data[0].idText), patternInput_1.data[0].idRange));
  }

  const exprty = tyOfExpr(cenv_1.g, expr);
  return PropagateThenTcDelayed(cenv_1, overallTy, env, patternInput[1], mWholeExpr, MakeApplicableExprNoFlex(cenv_1, expr), exprty, atomicFlag, delayed_1);
}
export function GetNewInferenceTypeForMethodArg(cenv_1, env, tpenv, x) {
  GetNewInferenceTypeForMethodArg: while (true) {
    const activePatternResult42266 = _SynExprParen___(x);

    if (activePatternResult42266 != null) {
      cenv_1 = cenv_1;
      env = env;
      tpenv = tpenv;
      x = getValue(activePatternResult42266)[0];
      continue GetNewInferenceTypeForMethodArg;
    } else {
      const $var271 = x.tag === 43 ? x.data[0] ? [0, x.data[1]] : [3] : x.tag === 15 ? [1, x.data[3]] : x.tag === 1 ? [2, x.data[2], x.data[1]] : [3];

      switch ($var271[0]) {
        case 0:
          return mkByrefTy(cenv_1.g, GetNewInferenceTypeForMethodArg(cenv_1, env, tpenv, $var271[1]));

        case 1:
          return mkFunTy(NewInferenceType(), GetNewInferenceTypeForMethodArg(cenv_1, env, tpenv, $var271[1]));

        case 2:
          if ($var271[2]) {
            return mkRawQuotedExprTy(cenv_1.g);
          } else {
            return mkQuotedExprTy(cenv_1.g, GetNewInferenceTypeForMethodArg(cenv_1, env, tpenv, $var271[1]));
          }

        case 3:
          return NewInferenceType();
      }
    }
  }
}
export function TcMethodApplication(isCheckingAttributeCall, cenv_1, env, tpenv, tyargsOpt, objArgs, mMethExpr, mItem, methodName, objTyOpt, ad, mut, isProp, calledMethsAndProps, afterResolution, isSuperInit, curriedCallerArgs, exprTy, delayed) {
  var curriedCalledArgs_1;
  var curriedCalledArgs;
  var unrefinedItem;
  var result;
  var callSink;
  const denv = env.DisplayEnv;

  const isSimpleFormalArg = function (tupledArg) {
    if ((!tupledArg[0] ? !tupledArg[1] : false) ? !tupledArg[2].IsOptional : false) {
      return tupledArg[3].Equals(new CallerInfoInfo(0));
    } else {
      return false;
    }
  };

  const callerObjArgTys = map_1(function (arg10_) {
    return tyOfExpr(cenv_1.g, arg10_);
  }, objArgs);
  const calledMeths = map_1(function (tuple) {
    return tuple[0];
  }, calledMethsAndProps);
  let patternInput;
  const $var272 = calledMeths.tail != null ? calledMeths.tail.tail == null ? (!isProp ? calledMeths.head.NumArgs.length > 1 : false) ? [0, calledMeths.head] : [1] : [1] : [1];

  switch ($var272[0]) {
    case 0:
      patternInput = [new List(), NewInferenceType(), append(toList(delay(function () {
        return map_2(function (x) {
          return new DelayedItem(1, [1, x, x.Range]);
        }, curriedCallerArgs);
      })), delayed)];
      break;

    case 1:
      if (!isProp ? exists_1(function (calledMeth) {
        return calledMeth.NumArgs.length > 1;
      }, calledMeths) : false) {
        patternInput = error_1(new _Error(SR.tcOverloadsCannotHaveCurriedArguments(), mMethExpr));
      } else {
        patternInput = [curriedCallerArgs, exprTy, delayed];
      }

      break;
  }

  let candidateMethsAndProps;
  const matchValue = filter(function (tupledArg_1) {
    return IsMethInfoAccessible(cenv_1.amap, mItem, ad, tupledArg_1[0]);
  }, calledMethsAndProps);

  if (matchValue.tail == null) {
    candidateMethsAndProps = calledMethsAndProps;
  } else {
    candidateMethsAndProps = matchValue;
  }

  const candidates = map_1(function (tuple_1) {
    return tuple_1[0];
  }, candidateMethsAndProps);
  let patternInput_3;

  if (patternInput[0].tail == null) {
    patternInput_3 = [null, null, patternInput[1]];
  } else {
    const patternInput_1 = unzip(function (list) {
      return map_1(function (arg) {
        return GetMethodArgs(arg);
      }, list);
    }(patternInput[0]));
    const patternInput_2 = isProp ? [ofArray([concat(patternInput_1[0])]), ofArray([concat(patternInput_1[1])])] : [patternInput_1[0], patternInput_1[1]];

    const MakeUnnamedCallerArgInfo = function (x_1) {
      return [x_1, GetNewInferenceTypeForMethodArg(cenv_1, env, tpenv, x_1), x_1.Range];
    };

    const $var273 = candidates.tail != null ? candidates.tail.tail == null ? (forAll(function (l_1) {
      return l_1.tail == null;
    }, patternInput_2[1]) ? (curriedCalledArgs_1 = candidates.head.GetParamAttribs(cenv_1.amap, mItem), (curriedCalledArgs_1.length === 1 ? curriedCalledArgs_1.head.length === 1 : false) ? isSimpleFormalArg(curriedCalledArgs_1.head.head) : false) : false) ? [0, candidates.head] : [1] : [1] : [1];

    switch ($var273[0]) {
      case 0:
        const unnamedCurriedCallerArgs = map_1($var274 => function (value) {
          return singleton_1(value);
        }(MakeUnnamedCallerArgInfo($var274)), patternInput[0]);
        const namedCurriedCallerArgs = map_1(function (_arg62) {
          return new List();
        }, patternInput_2[1]);
        patternInput_3 = [[unnamedCurriedCallerArgs, namedCurriedCallerArgs], null, patternInput[1]];
        break;

      case 1:
        const $var275 = candidates.tail != null ? candidates.tail.tail == null ? (((forAll(function (l) {
          return l.tail == null;
        }, patternInput_2[1]) ? patternInput_2[0].length === 1 : false) ? patternInput_2[0].head.length === 1 : false) ? (curriedCalledArgs = candidates.head.GetParamAttribs(cenv_1.amap, mItem), (curriedCalledArgs.length === 1 ? curriedCalledArgs.head.length > 1 : false) ? function (list_1) {
          return forAll(isSimpleFormalArg, list_1);
        }(curriedCalledArgs.head) : false) : false) ? [0, candidates.head] : [1] : [1] : [1];

        switch ($var275[0]) {
          case 0:
            const exprTy_1 = mkFunTy(NewInferenceType(), patternInput[1]);
            patternInput_3 = [null, patternInput_2[0].head.head, exprTy_1];
            break;

          case 1:
            const unnamedCurriedCallerArgs_1 = function (xss) {
              return List_1.mapSquared(MakeUnnamedCallerArgInfo, xss);
            }(patternInput_2[0]);

            const namedCurriedCallerArgs_1 = List_1.mapSquared(function (tupledArg_2) {
              const ty = GetNewInferenceTypeForMethodArg(cenv_1, env, tpenv, tupledArg_2[2]);
              const ty_1 = tupledArg_2[0] ? mkOptionTy(denv.g, ty) : ty;
              return [tupledArg_2[1], tupledArg_2[0], tupledArg_2[2], ty_1, tupledArg_2[2].Range];
            }, patternInput_2[1]);
            patternInput_3 = [[unnamedCurriedCallerArgs_1, namedCurriedCallerArgs_1], null, patternInput[1]];
            break;
        }

        break;
    }
  }

  const CalledMethHasSingleArgumentGroupOfThisLength = function (n, calledMeth_1) {
    const curriedMethodArgAttribs = calledMeth_1.GetParamAttribs(cenv_1.amap, mItem);

    if (curriedMethodArgAttribs.length === 1) {
      return curriedMethodArgAttribs.head.length === n;
    } else {
      return false;
    }
  };

  const GenerateMatchingSimpleArgumentTypes = function (calledMeth_2) {
    const curriedMethodArgAttribs_1 = calledMeth_2.GetParamAttribs(cenv_1.amap, mItem);
    return map_1($var276 => function (arg00_) {
      return NewInferenceTypes(arg00_);
    }(function (list_2) {
      return filter(isSimpleFormalArg, list_2);
    }($var276)), curriedMethodArgAttribs_1);
  };

  const UnifyMatchingSimpleArgumentTypes = function (exprTy_2, calledMeth_3) {
    const curriedArgTys = GenerateMatchingSimpleArgumentTypes(calledMeth_3);
    const returnTy = fold(function (exprTy_3, argTys) {
      const patternInput_4 = UnifyFunctionType(null, cenv_1, denv, mMethExpr, exprTy_3);
      UnifyTypes(cenv_1, env, mMethExpr, patternInput_4[0], mkRefTupledTy(cenv_1.g, argTys));
      return patternInput_4[1];
    }, exprTy_2, curriedArgTys);
    return [curriedArgTys, returnTy];
  };

  if (isProp ? patternInput_3[0] == null : false) {
    error_1(new _Error(SR.parsIndexerPropertyRequiresAtLeastOneArgument(), mItem));
  }

  let patternInput_8;
  const dummyExpr = mkSynUnit(mItem);
  let patternInput_7;
  const matchValue_1 = [patternInput_3[0], candidates];
  const $var277 = matchValue_1[0] != null ? [2, getValue(matchValue_1[0])[1], getValue(matchValue_1[0])[0]] : matchValue_1[1].tail != null ? matchValue_1[1].tail.tail == null ? [0, matchValue_1[1].head] : [1] : [1];

  switch ($var277[0]) {
    case 0:
      const patternInput_5 = UnifyMatchingSimpleArgumentTypes(patternInput_3[2], $var277[1]);
      const unnamedCurriedCallerArgs_2 = List_1.mapSquared(function (ty_2) {
        return new CallerArg_1(0, [ty_2, mMethExpr, false, dummyExpr]);
      }, patternInput_5[0]);
      const namedCurriedCallerArgs_2 = map_1(function (_arg63) {
        return new List();
      }, unnamedCurriedCallerArgs_2);
      patternInput_7 = [unnamedCurriedCallerArgs_2, namedCurriedCallerArgs_2, patternInput_5[1]];
      break;

    case 1:
      const patternInput_6 = UnifyFunctionType(null, cenv_1, denv, mMethExpr, patternInput_3[2]);
      const argTys_1 = isUnitTy(cenv_1.g, patternInput_6[0]) ? new List() : tryDestRefTupleTy(cenv_1.g, patternInput_6[0]);
      const argTys_2 = exists_1(CurriedLambda(CalledMethHasSingleArgumentGroupOfThisLength)(argTys_1.length), candidates) ? argTys_1 : ofArray([patternInput_6[0]]);
      const unnamedCurriedCallerArgs_3 = ofArray([map_1(function (ty_3) {
        return new CallerArg_1(0, [ty_3, mMethExpr, false, dummyExpr]);
      }, argTys_2)]);
      const namedCurriedCallerArgs_3 = map_1(function (_arg64) {
        return new List();
      }, unnamedCurriedCallerArgs_3);
      patternInput_7 = [unnamedCurriedCallerArgs_3, namedCurriedCallerArgs_3, patternInput_6[1]];
      break;

    case 2:
      const unnamedCurriedCallerArgs_4 = List_1.mapSquared(function (tupledArg_3) {
        return new CallerArg_1(0, [tupledArg_3[1], tupledArg_3[2], false, tupledArg_3[0]]);
      }, $var277[2]);
      const namedCurriedCallerArgs_4 = List_1.mapSquared(function (tupledArg_4) {
        return new CallerNamedArg(0, [tupledArg_4[0], new CallerArg_1(0, [tupledArg_4[3], tupledArg_4[4], tupledArg_4[1], tupledArg_4[2]])]);
      }, $var277[1]);
      patternInput_7 = [unnamedCurriedCallerArgs_4, namedCurriedCallerArgs_4, patternInput_3[2]];
      break;
  }

  const callerArgCounts = [sumBy(function (list_3) {
    return list_3.length;
  }, patternInput_7[0]), sumBy(function (list_4) {
    return list_4.length;
  }, patternInput_7[1])];
  const callerArgs = toList(zip(patternInput_7[0], patternInput_7[1]));

  const makeOneCalledMeth = function (tupledArg_5) {
    const minst = FreshenMethInfo(mItem, tupledArg_5[0]);
    const callerTyArgs = tyargsOpt == null ? minst : tupledArg_5[0].AdjustUserTypeInstForFSharpStyleIndexedExtensionMembers(getValue(tyargsOpt));
    return new CalledMeth(cenv_1.infoReader, env.NameEnv, isCheckingAttributeCall, function (arg00__1, arg10__1) {
      return FreshenMethInfo(arg00__1, arg10__1);
    }, mMethExpr, ad, tupledArg_5[0], minst, callerTyArgs, tupledArg_5[1], callerObjArgTys, callerArgs, tupledArg_5[2], true, objTyOpt);
  };

  const preArgumentTypeCheckingCalledMethGroup = toList(delay(function () {
    return collect_1(function (matchValue_2) {
      const meth = makeOneCalledMeth([matchValue_2[0], matchValue_2[1], true]);
      return append_1(singleton(meth), delay(function () {
        return meth.UsesParamArrayConversion ? singleton(makeOneCalledMeth([matchValue_2[0], matchValue_2[1], false])) : empty();
      }));
    }, candidateMethsAndProps);
  }));
  let uniquelyResolved;
  const csenv = MakeConstraintSolverEnv(new ContextInfo(0), cenv_1.css, mMethExpr, denv);
  uniquelyResolved = UnifyUniqueOverloading(csenv, callerArgCounts[0], callerArgCounts[1], methodName, ad, preArgumentTypeCheckingCalledMethGroup, patternInput_7[2]);
  patternInput_8 = [uniquelyResolved, preArgumentTypeCheckingCalledMethGroup];
  let patternInput_13;

  if (patternInput_3[0] != null) {
    const unnamedCurriedCallerArgs_5 = getValue(patternInput_3[0])[0];
    const namedCurriedCallerArgs_5 = getValue(patternInput_3[0])[1];
    const unnamedCurriedCallerArgs_6 = List_1.mapSquared(function (tupledArg_6) {
      return new CallerArg_1(0, [tupledArg_6[1], tupledArg_6[2], false, tupledArg_6[0]]);
    }, unnamedCurriedCallerArgs_5);
    const namedCurriedCallerArgs_6 = List_1.mapSquared(function (tupledArg_7) {
      return new CallerNamedArg(0, [tupledArg_7[0], new CallerArg_1(0, [tupledArg_7[3], tupledArg_7[4], tupledArg_7[1], tupledArg_7[2]])]);
    }, namedCurriedCallerArgs_5);
    const lambdaPropagationInfo = patternInput_8[1].length > 1 ? Array.from(delay(function () {
      return collect_1(function (meth_1) {
        const matchValue_3 = ExamineMethodForLambdaPropagation(meth_1);

        if (matchValue_3 == null) {
          return empty();
        } else {
          const unnamedInfo = getValue(matchValue_3)[0];
          const namedInfo = getValue(matchValue_3)[1];
          const calledObjArgTys = meth_1.CalledObjArgTys(mMethExpr);

          if (forAll2(function (calledTy, callerTy) {
            return AddCxTypeMustSubsumeTypeMatchingOnlyUndoIfFailed(denv, cenv_1.css, mMethExpr, calledTy, callerTy);
          }, calledObjArgTys, callerObjArgTys)) {
            return singleton([List_1.toArraySquared(unnamedInfo), List_1.toArraySquared(namedInfo)]);
          } else {
            return empty();
          }
        }
      }, patternInput_8[1]);
    })) : [];
    const patternInput_9 = TcUnnamedMethodArgs(cenv_1, env, lambdaPropagationInfo, tpenv, unnamedCurriedCallerArgs_6);
    const tpenv_1 = patternInput_9[1][1];
    const lambdaPropagationInfo_1 = patternInput_9[1][0];
    const patternInput_10 = TcMethodNamedArgs(cenv_1, env, lambdaPropagationInfo_1, tpenv_1, namedCurriedCallerArgs_6);
    const tpenv_2 = patternInput_10[1][1];
    patternInput_13 = [patternInput_9[0], patternInput_10[0], null, patternInput_3[2], tpenv_2];
  } else {
    let patternInput_12;
    const $var278 = candidates.tail != null ? candidates.tail.tail == null ? [0, candidates.head] : [1] : [1];

    switch ($var278[0]) {
      case 0:
        patternInput_12 = UnifyMatchingSimpleArgumentTypes(patternInput_3[2], $var278[1]);
        break;

      case 1:
        const patternInput_11 = UnifyFunctionType(null, cenv_1, denv, mMethExpr, patternInput_3[2]);
        const argTys_3 = isUnitTy(cenv_1.g, patternInput_11[0]) ? new List() : tryDestRefTupleTy(cenv_1.g, patternInput_11[0]);
        const argTys_4 = exists_1(CurriedLambda(CalledMethHasSingleArgumentGroupOfThisLength)(argTys_3.length), candidates) ? argTys_3 : ofArray([patternInput_11[0]]);
        patternInput_12 = [ofArray([argTys_4]), patternInput_11[1]];
        break;
    }

    const lambdaVarsAndExprs = List_1.mapiSquared(function (i, j, ty_4) {
      return mkCompGenLocal(mMethExpr, "arg" + i.toString() + j.toString(), ty_4);
    }, patternInput_12[0]);
    const unnamedCurriedCallerArgs_7 = List_1.mapSquared(function (tupledArg_8) {
      return new CallerArg_1(0, [tyOfExpr(cenv_1.g, tupledArg_8[1]), Expr_get_Range.bind(tupledArg_8[1])(), false, tupledArg_8[1]]);
    }, lambdaVarsAndExprs);
    const namedCurriedCallerArgs_7 = map_1(function (_arg66) {
      return new List();
    }, lambdaVarsAndExprs);
    const lambdaVars = List_1.mapSquared(function (tuple_2) {
      return tuple_2[0];
    }, lambdaVarsAndExprs);
    patternInput_13 = [unnamedCurriedCallerArgs_7, namedCurriedCallerArgs_7, lambdaVars, patternInput_12[1], tpenv];
  }

  const preArgumentTypeCheckingCalledMethGroup_1 = map_1(function (cmeth) {
    return [cmeth.Method, cmeth.CalledTyArgs, cmeth.AssociatedPropertyInfo, cmeth.UsesParamArrayConversion];
  }, patternInput_8[1]);
  let uniquelyResolved_1;

  if (patternInput_8[0].tag === 1) {
    if (afterResolution.tag === 1) {
      afterResolution.data[3]();
    }
  }

  uniquelyResolved_1 = CommitOperationResult(patternInput_8[0]);
  let finalCalledMeth;
  const callerArgs_1 = toList(zip(patternInput_13[0], patternInput_13[1]));
  const postArgumentTypeCheckingCalledMethGroup = map_1(function (tupledArg_9) {
    const callerTyArgs_1 = tyargsOpt == null ? tupledArg_9[1] : tupledArg_9[0].AdjustUserTypeInstForFSharpStyleIndexedExtensionMembers(getValue(tyargsOpt));
    return new CalledMeth(cenv_1.infoReader, env.NameEnv, isCheckingAttributeCall, function (arg00__2, arg10__2) {
      return FreshenMethInfo(arg00__2, arg10__2);
    }, mMethExpr, ad, tupledArg_9[0], tupledArg_9[1], callerTyArgs_1, tupledArg_9[2], callerObjArgTys, callerArgs_1, tupledArg_9[3], true, objTyOpt);
  }, preArgumentTypeCheckingCalledMethGroup_1);
  const callerArgCounts_1 = [patternInput_13[0].length, patternInput_13[1].length];
  const csenv_1 = MakeConstraintSolverEnv(new ContextInfo(0), cenv_1.css, mMethExpr, denv);

  if (!uniquelyResolved_1) {
    GeneralizationHelpers.CanonicalizePartialInferenceProblem(cenv_1, denv, mItem, List_1.collectSquared(function (callerArg) {
      return freeInTypeLeftToRight(cenv_1.g, false, callerArg.Type);
    }, patternInput_13[0]));
  }

  let patternInput_14;
  const arg10__3 = new OptionalTrace(0);
  const arg40_ = null;
  const arg90_ = patternInput_13[3];
  patternInput_14 = ResolveOverloading(csenv_1, arg10__3, methodName, 0, arg40_, callerArgCounts_1[0], callerArgCounts_1[1], ad, postArgumentTypeCheckingCalledMethGroup, true, arg90_);
  const matchValue_4 = [afterResolution, patternInput_14[0]];
  const $var279 = matchValue_4[0].tag === 1 ? matchValue_4[0].data[0] != null ? matchValue_4[1] != null ? (unrefinedItem = getValue(matchValue_4[0].data[0]), result = getValue(matchValue_4[1]), callSink = matchValue_4[0].data[2], result.Method.IsVirtual) ? [1, matchValue_4[0].data[2], getValue(matchValue_4[1]), getValue(matchValue_4[0].data[0])] : [2] : [2] : [2] : [0];

  switch ($var279[0]) {
    case 0:
      break;

    case 1:
      const overriding = $var279[3].tag === 10 ? map_1(function (minfo) {
        return [minfo, null];
      }, $var279[3].data[1]) : $var279[3].tag === 9 ? $var279[2].Method.LogicalName.indexOf("set_") === 0 ? SettersOfPropInfos($var279[3].data[1]) : GettersOfPropInfos($var279[3].data[1]) : new List();
      const overridingInfo = tryFind(function (tupledArg_10) {
        return tupledArg_10[0].IsVirtual ? MethInfosEquivByNameAndSig(new Erasure(2), true, cenv_1.g, cenv_1.amap, range0, $var279[2].Method, tupledArg_10[0]) : false;
      }, overriding);

      if (overridingInfo == null) {
        $var279[1]([$var279[2].Method, $var279[2].AssociatedPropertyInfo, $var279[2].CalledTyparInst]);
      } else {
        const pinfoOpt = getValue(overridingInfo)[1];
        const minfo_1 = getValue(overridingInfo)[0];
        const tps = minfo_1.FormalMethodTypars;
        const tyargs = $var279[2].CalledTyArgs;
        const tpinst = tps.length === tyargs.length ? mkTyparInst(tps, tyargs) : new List();
        $var279[1]([minfo_1, pinfoOpt, tpinst]);
      }

      break;

    case 2:
      if (matchValue_4[0].tag === 1) {
        if (matchValue_4[1] == null) {
          matchValue_4[0].data[3]();
        } else {
          matchValue_4[0].data[2]([getValue(matchValue_4[1]).Method, getValue(matchValue_4[1]).AssociatedPropertyInfo, getValue(matchValue_4[1]).CalledTyparInst]);
        }
      } else {
        throw new Error("C:/projects/fcs/src/fsharp/TypeChecker.fs", 9594, 14);
      }

      break;
  }

  RaiseOperationResult(patternInput_14[1]);

  if (patternInput_14[0] != null) {
    finalCalledMeth = getValue(patternInput_14[0]);
  } else {
    finalCalledMeth = error_1(new InternalError("at least one error should be returned by failed method overloading", mItem));
  }

  const finalCalledMethInfo = finalCalledMeth.Method;
  const finalCalledMethInst = finalCalledMeth.CalledTyArgs;
  const finalArgSets = finalCalledMeth.ArgSets;
  const finalAssignedItemSetters = finalCalledMeth.AssignedItemSetters;
  const finalCalledPropInfoOpt = finalCalledMeth.AssociatedPropertyInfo;
  const finalAttributeAssignedNamedItems = finalCalledMeth.AttributeAssignedNamedArgs;
  const finalUnnamedCalledOptArgs = finalCalledMeth.UnnamedCalledOptArgs;
  const finalUnnamedCalledOutArgs = finalCalledMeth.UnnamedCalledOutArgs;
  const finalAssignedNamedArgs = collect(function (argSet) {
    return argSet.AssignedNamedArgs;
  }, finalArgSets);
  const finalParamArrayCallerArgs = collect(function (argSet_1) {
    return argSet_1.ParamArrayCallerArgs;
  }, finalArgSets);
  const finalUnnamedCalledArgs = collect(function (argSet_2) {
    return argSet_2.UnnamedCalledArgs;
  }, finalArgSets);
  const finalUnnamedCallerArgs = collect(function (argSet_3) {
    return argSet_3.UnnamedCallerArgs;
  }, finalArgSets);
  iterate(function (pinfo) {
    CommitOperationResult(CheckPropInfoAttributes(pinfo, mItem));
  }, defaultArg(finalCalledPropInfoOpt, [], $var280 => [$var280]));
  const isInstance = !(objArgs.tail == null);
  MethInfoChecks(cenv_1.g, cenv_1.amap, isInstance, tyargsOpt, objArgs, ad, mItem, finalCalledMethInfo);

  if (((isInstance ? finalCalledMethInfo.IsInstance : false) ? typeEquiv(cenv_1.g, finalCalledMethInfo.ApparentEnclosingType, cenv_1.g.obj_ty) : false) ? finalCalledMethInfo.LogicalName === "GetHashCode" ? true : finalCalledMethInfo.LogicalName === "Equals" : false) {
    iterate(function (expr) {
      AddCxTypeMustSupportEquality(env.DisplayEnv, cenv_1.css, mMethExpr, new OptionalTrace(0), tyOfExpr(cenv_1.g, expr));
    }, objArgs);
  }

  if ((HasHeadType(cenv_1.g, cenv_1.g.tcref_System_Collections_Generic_Dictionary, finalCalledMethInfo.ApparentEnclosingType) ? finalCalledMethInfo.IsConstructor : false) ? !List_1.existsSquared(function (_arg68) {
    return HasHeadType(cenv_1.g, cenv_1.g.tcref_System_Collections_Generic_IEqualityComparer, _arg68.data[6]);
  }, finalCalledMethInfo.GetParamDatas(cenv_1.amap, mItem, finalCalledMeth.CalledTyArgs)) : false) {
    const matchValue_5 = argsOfAppTy(cenv_1.g, finalCalledMethInfo.ApparentEnclosingType);
    const $var281 = matchValue_5.tail != null ? matchValue_5.tail.tail != null ? matchValue_5.tail.tail.tail == null ? [0, matchValue_5.head] : [1] : [1] : [1];

    switch ($var281[0]) {
      case 0:
        AddCxTypeMustSupportEquality(env.DisplayEnv, cenv_1.css, mMethExpr, new OptionalTrace(0), $var281[1]);
        break;

      case 1:
        break;
    }
  }

  if (List_1.existsi(function (i_1, argSet_4) {
    return List_1.existsi(function (j_1, ca) {
      return !equals(ca.Position, [i_1, j_1]);
    }, argSet_4.UnnamedCalledArgs);
  }, finalArgSets)) {
    errorR(new Deprecated(SR.tcUnnamedArgumentsDoNotFormPrefix(), mMethExpr));
  }

  const emptyPreBinder = function (e) {
    return e;
  };

  let patternInput_16;
  const matchValue_6 = [objArgs, patternInput_13[2]];
  const $var282 = matchValue_6[0].tail != null ? matchValue_6[0].tail.tail == null ? matchValue_6[1] != null ? [0, matchValue_6[0].head] : [1] : [1] : [1];

  switch ($var282[0]) {
    case 0:
      const objArgTy = tyOfExpr(cenv_1.g, $var282[1]);
      const patternInput_15 = mkCompGenLocal(mMethExpr, "objectArg", objArgTy);
      patternInput_16 = [function (body) {
        return mkCompGenLet(mMethExpr, patternInput_15[0], $var282[1], body);
      }, ofArray([patternInput_15[1]])];
      break;

    case 1:
      patternInput_16 = [emptyPreBinder, objArgs];
      break;
  }

  const coerceExpr = function (isOutArg, calledArgTy, reflArgInfo, callerArgTy, m, callerArgExpr) {
    if (isByrefTy(cenv_1.g, calledArgTy) ? isRefCellTy(cenv_1.g, callerArgTy) : false) {
      return new Expr(11, [new TOp(23), ofArray([destRefCellTy(cenv_1.g, callerArgTy)]), ofArray([callerArgExpr]), m]);
    } else if (isDelegateTy(cenv_1.g, calledArgTy) ? isFunTy(cenv_1.g, callerArgTy) : false) {
      return CoerceFromFSharpFuncToDelegate(cenv_1.g, cenv_1.amap, cenv_1.infoReader, ad, callerArgTy, m, callerArgExpr, calledArgTy);
    } else if ((isLinqExpressionTy(cenv_1.g, calledArgTy) ? isDelegateTy(cenv_1.g, destLinqExpressionTy(cenv_1.g, calledArgTy)) : false) ? isFunTy(cenv_1.g, callerArgTy) : false) {
      const delegateTy = destLinqExpressionTy(cenv_1.g, calledArgTy);
      const expr_1 = CoerceFromFSharpFuncToDelegate(cenv_1.g, cenv_1.amap, cenv_1.infoReader, ad, callerArgTy, m, callerArgExpr, delegateTy);
      return mkCallQuoteToLinqLambdaExpression(cenv_1.g, m, delegateTy, new Expr(12, [expr_1, {
        contents: null
      }, false, m, mkQuotedExprTy(cenv_1.g, delegateTy)]));
    } else if ((reflArgInfo.AutoQuote ? isQuotedExprTy(cenv_1.g, calledArgTy) : false) ? !isQuotedExprTy(cenv_1.g, callerArgTy) : false) {
      if (reflArgInfo.tag === 0) {
        throw new Error("unreachable");
      } else if (reflArgInfo.data) {
        return mkCallLiftValueWithDefn(cenv_1.g, m, calledArgTy, callerArgExpr);
      } else {
        return new Expr(12, [callerArgExpr, {
          contents: null
        }, false, m, calledArgTy]);
      }
    } else if (isOutArg) {
      return callerArgExpr;
    } else {
      return mkCoerceIfNeeded(cenv_1.g, calledArgTy, callerArgTy, callerArgExpr);
    }
  };

  let patternInput_24;
  const normalUnnamedArgs = toList(map2(function (called, caller) {
    return new AssignedCalledArg(null, called, caller);
  }, finalUnnamedCalledArgs, finalUnnamedCallerArgs));
  let paramArrayArgs;
  const matchValue_7 = finalCalledMeth.ParamArrayCalledArgOpt;

  if (matchValue_7 != null) {
    const paramArrayCalledArgElementType = destArrayTy(cenv_1.g, getValue(matchValue_7).CalledArgumentType);
    const es = map_1(function (callerArg_1) {
      return coerceExpr(callerArg_1.data[2], paramArrayCalledArgElementType, getValue(matchValue_7).ReflArgInfo, callerArg_1.data[0], callerArg_1.data[1], callerArg_1.data[3]);
    }, finalParamArrayCallerArgs);
    paramArrayArgs = ofArray([new AssignedCalledArg(null, getValue(matchValue_7), new CallerArg_1(0, [getValue(matchValue_7).CalledArgumentType, mMethExpr, false, new Expr(11, [new TOp(3), ofArray([paramArrayCalledArgElementType]), es, mMethExpr])]))]);
  } else {
    paramArrayArgs = new List();
  }

  const patternInput_20 = mapFold(function (wrapper, calledArg) {
    var callerName_1;
    let patternInput_19;

    if (calledArg.OptArgInfo.tag === 2) {
      const build = function (currCalledArgTy, currDfltVal) {
        var callerName;

        build: while (true) {
          switch (currDfltVal.tag) {
            case 1:
              return [emptyPreBinder, mkDefault(mMethExpr, currCalledArgTy)];

            case 0:
              let $var283;

              const activePatternResult42337 = function (arg10__5) {
                return _NullableTy___(cenv_1.g, arg10__5);
              }(currCalledArgTy);

              if (activePatternResult42337 != null) {
                if (!currDfltVal.data.Equals(new ILFieldInit(13))) {
                  $var283 = [0, getValue(activePatternResult42337)];
                } else {
                  $var283 = [1];
                }
              } else {
                $var283 = [1];
              }

              switch ($var283[0]) {
                case 0:
                  const nullableTy = mkILNonGenericBoxedTy(cenv_1.g.FindSysILTypeRef("System.Nullable`1"));
                  const ctor = mkILCtorMethSpecForTy(nullableTy, ofArray([new ILType(7, 0)])).MethodRef;
                  const ctorArgs = ofArray([new Expr(0, [TcFieldInit(mMethExpr, currDfltVal.data), mMethExpr, $var283[1]])]);
                  return [emptyPreBinder, new Expr(11, [new TOp(31, [false, false, true, true, new ValUseFlag(1), false, false, ctor, ofArray([$var283[1]]), new List(), ofArray([currCalledArgTy])]), new List(), ctorArgs, mMethExpr])];

                case 1:
                  const activePatternResult42335 = function (arg10__4) {
                    return _ByrefTy___(cenv_1.g, arg10__4);
                  }(currCalledArgTy);

                  if (activePatternResult42335 != null) {
                    currCalledArgTy = getValue(activePatternResult42335);
                    currDfltVal = new OptionalArgCallerSideValue(5, [getValue(activePatternResult42335), currDfltVal]);
                    continue build;
                  } else {
                    const matchValue_8 = [calledArg.CallerInfoInfo, env.eCallerMemberName];
                    const $var284 = matchValue_8[0].tag === 1 ? typeEquiv(cenv_1.g, currCalledArgTy, cenv_1.g.int_ty) ? [0] : [1] : [1];

                    switch ($var284[0]) {
                      case 0:
                        return [emptyPreBinder, new Expr(0, [new Const(5, mMethExpr.StartLine), mMethExpr, currCalledArgTy])];

                      case 1:
                        const $var285 = matchValue_8[0].tag === 3 ? typeEquiv(cenv_1.g, currCalledArgTy, cenv_1.g.string_ty) ? [0] : [1] : [1];

                        switch ($var285[0]) {
                          case 0:
                            return [emptyPreBinder, new Expr(0, [new Const(14, System.IO.Path.GetFullPath(mMethExpr.FileName)), mMethExpr, currCalledArgTy])];

                          case 1:
                            const $var286 = matchValue_8[0].tag === 2 ? matchValue_8[1] != null ? (callerName = getValue(matchValue_8[1]), typeEquiv(cenv_1.g, currCalledArgTy, cenv_1.g.string_ty)) ? [0, getValue(matchValue_8[1])] : [1] : [1] : [1];

                            switch ($var286[0]) {
                              case 0:
                                return [emptyPreBinder, new Expr(0, [new Const(14, $var286[1]), mMethExpr, currCalledArgTy])];

                              case 1:
                                return [emptyPreBinder, new Expr(0, [TcFieldInit(mMethExpr, currDfltVal.data), mMethExpr, currCalledArgTy])];
                            }

                        }

                    }
                  }

              }

            case 3:
              const matchValue_9 = cenv_1.g.TryFindSysILTypeRef("System.Runtime.InteropServices.DispatchWrapper");

              if (matchValue_9 != null) {
                const ty_5 = mkILNonGenericBoxedTy(getValue(matchValue_9));
                const mref = mkILCtorMethSpecForTy(ty_5, ofArray([cenv_1.g.ilg.typ_Object])).MethodRef;
                const expr_2 = new Expr(11, [new TOp(31, [false, false, false, true, new ValUseFlag(1), false, false, mref, new List(), new List(), ofArray([cenv_1.g.obj_ty])]), new List(), ofArray([mkDefault(mMethExpr, currCalledArgTy)]), mMethExpr]);
                return [emptyPreBinder, expr_2];
              } else {
                return error_1(new _Error(SR.fscSystemRuntimeInteropServicesIsRequired(), mMethExpr));
              }

            case 4:
              const matchValue_10 = cenv_1.g.TryFindSysILTypeRef("System.Runtime.InteropServices.UnknownWrapper");

              if (matchValue_10 != null) {
                const ty_6 = mkILNonGenericBoxedTy(getValue(matchValue_10));
                const mref_1 = mkILCtorMethSpecForTy(ty_6, ofArray([cenv_1.g.ilg.typ_Object])).MethodRef;
                const expr_3 = new Expr(11, [new TOp(31, [false, false, false, true, new ValUseFlag(1), false, false, mref_1, new List(), new List(), ofArray([cenv_1.g.obj_ty])]), new List(), ofArray([mkDefault(mMethExpr, currCalledArgTy)]), mMethExpr]);
                return [emptyPreBinder, expr_3];
              } else {
                return error_1(new _Error(SR.fscSystemRuntimeInteropServicesIsRequired(), mMethExpr));
              }

            case 5:
              const patternInput_17 = mkCompGenLocal(mMethExpr, "defaultByrefArg", currDfltVal.data[0]);
              const patternInput_18 = build(currCalledArgTy, currDfltVal.data[1]);
              return [$var287 => function (arg30_) {
                return mkCompGenLet(mMethExpr, patternInput_17[0], patternInput_18[1], arg30_);
              }(patternInput_18[0]($var287)), mkValAddr(mMethExpr, mkLocalValRef(patternInput_17[0]))];

            default:
              return [emptyPreBinder, mkAsmExpr(ofArray([mkNormalLdsfld(fspec_Missing_Value(cenv_1.g)), new ILInstr(33)]), new List(), new List(), ofArray([currCalledArgTy]), mMethExpr)];
          }
        }
      };

      patternInput_19 = build(calledArg.CalledArgumentType, calledArg.OptArgInfo.data);
    } else if (calledArg.OptArgInfo.tag === 1) {
      const calledNonOptTy = isOptionTy(cenv_1.g, calledArg.CalledArgumentType) ? destOptionTy(cenv_1.g, calledArg.CalledArgumentType) : calledArg.CalledArgumentType;
      const matchValue_11 = [calledArg.CallerInfoInfo, env.eCallerMemberName];
      const $var288 = matchValue_11[0].tag === 1 ? typeEquiv(cenv_1.g, calledNonOptTy, cenv_1.g.int_ty) ? [0] : [1] : [1];

      switch ($var288[0]) {
        case 0:
          const lineExpr = new Expr(0, [new Const(5, mMethExpr.StartLine), mMethExpr, calledNonOptTy]);
          patternInput_19 = [emptyPreBinder, mkUnionCaseExpr(mkSomeCase(cenv_1.g), ofArray([calledNonOptTy]), ofArray([lineExpr]), mMethExpr)];
          break;

        case 1:
          const $var289 = matchValue_11[0].tag === 3 ? typeEquiv(cenv_1.g, calledNonOptTy, cenv_1.g.string_ty) ? [0] : [1] : [1];

          switch ($var289[0]) {
            case 0:
              const filePathExpr = new Expr(0, [new Const(14, System.IO.Path.GetFullPath(mMethExpr.FileName)), mMethExpr, calledNonOptTy]);
              patternInput_19 = [emptyPreBinder, mkUnionCaseExpr(mkSomeCase(cenv_1.g), ofArray([calledNonOptTy]), ofArray([filePathExpr]), mMethExpr)];
              break;

            case 1:
              const $var290 = matchValue_11[0].tag === 2 ? matchValue_11[1] != null ? (callerName_1 = getValue(matchValue_11[1]), typeEquiv(cenv_1.g, calledNonOptTy, cenv_1.g.string_ty)) ? [0, getValue(matchValue_11[1])] : [1] : [1] : [1];

              switch ($var290[0]) {
                case 0:
                  const memberNameExpr = new Expr(0, [new Const(14, $var290[1]), mMethExpr, calledNonOptTy]);
                  patternInput_19 = [emptyPreBinder, mkUnionCaseExpr(mkSomeCase(cenv_1.g), ofArray([calledNonOptTy]), ofArray([memberNameExpr]), mMethExpr)];
                  break;

                case 1:
                  patternInput_19 = [emptyPreBinder, mkUnionCaseExpr(mkNoneCase(cenv_1.g), ofArray([calledNonOptTy]), new List(), mMethExpr)];
                  break;
              }

              break;
          }

          break;
      }
    } else {
      patternInput_19 = error_1(new InternalError("Unexpected NotOptional", mItem));
    }

    const wrapper_1 = $var291 => {
      return patternInput_19[0](wrapper($var291));
    };

    const callerArg_2 = new CallerArg_1(0, [calledArg.CalledArgumentType, mMethExpr, false, patternInput_19[1]]);
    return [new AssignedCalledArg(null, calledArg, callerArg_2), wrapper_1];
  }, emptyPreBinder, finalUnnamedCalledOptArgs, ofArray);

  const wrapOptionalArg = function (assignedArg) {
    const matchValue_12 = assignedArg.CalledArg.OptArgInfo;

    if (matchValue_12.tag === 0) {
      if (assignedArg.CallerArg.data[2]) {
        errorR(new _Error(SR.tcFormalArgumentIsNotOptional(), assignedArg.CallerArg.data[1]));
      }

      return assignedArg;
    } else {
      let expr_4;
      const matchValue_13 = assignedArg.CalledArg.OptArgInfo;

      if (matchValue_13.tag === 2) {
        if (assignedArg.CallerArg.data[2]) {
          expr_4 = mkUnionCaseFieldGetUnprovenViaExprAddr(assignedArg.CallerArg.data[3], mkSomeCase(cenv_1.g), ofArray([destOptionTy(cenv_1.g, assignedArg.CallerArg.data[0])]), 0, assignedArg.CallerArg.data[1]);
        } else {
          expr_4 = assignedArg.CallerArg.data[3];
        }
      } else if (matchValue_13.tag === 1) {
        if (assignedArg.CallerArg.data[2]) {
          expr_4 = assignedArg.CallerArg.data[3];
        } else {
          const calledArgTy_1 = assignedArg.CalledArg.CalledArgumentType;

          if (isOptionTy(cenv_1.g, calledArgTy_1)) {
            const calledNonOptTy_1 = destOptionTy(cenv_1.g, calledArgTy_1);
            expr_4 = mkUnionCaseExpr(mkSomeCase(cenv_1.g), ofArray([calledNonOptTy_1]), ofArray([mkCoerceIfNeeded(cenv_1.g, calledNonOptTy_1, assignedArg.CallerArg.data[0], assignedArg.CallerArg.data[3])]), assignedArg.CallerArg.data[1]);
          } else {
            expr_4 = assignedArg.CallerArg.data[3];
          }
        }
      } else {
        throw new Error("Unreachable");
      }

      const CallerArg = new CallerArg_1(0, [tyOfExpr(cenv_1.g, expr_4), assignedArg.CallerArg.data[1], assignedArg.CallerArg.data[2], expr_4]);
      return new AssignedCalledArg(assignedArg.NamedArgIdOpt, assignedArg.CalledArg, CallerArg);
    }
  };

  const patternInput_22 = unzip(map_1(function (calledArg_1) {
    const outArgTy = destByrefTy(cenv_1.g, calledArg_1.CalledArgumentType);
    const patternInput_21 = mkMutableCompGenLocal(mMethExpr, "outArg", outArgTy);
    const expr_5 = mkDefault(mMethExpr, outArgTy);
    const callerArg_3 = new CallerArg_1(0, [calledArg_1.CalledArgumentType, mMethExpr, false, mkValAddr(mMethExpr, mkLocalValRef(patternInput_21[0]))]);
    const outArg = new AssignedCalledArg(null, calledArg_1, callerArg_3);
    return [[outArg, patternInput_21[1]], mkCompGenBind(patternInput_21[0], expr_5)];
  }, finalUnnamedCalledOutArgs));
  const patternInput_23 = unzip(patternInput_22[0]);
  const allArgs = append(map_1(wrapOptionalArg, normalUnnamedArgs), append(map_1(wrapOptionalArg, finalAssignedNamedArgs), append(paramArrayArgs, append(patternInput_20[0], patternInput_23[0]))));
  const allArgs_1 = toList(sortWith(($var292, $var293) => compare(function (x_2) {
    return x_2.Position;
  }($var292), function (x_2) {
    return x_2.Position;
  }($var293)), allArgs));
  patternInput_24 = [patternInput_20[1], allArgs_1, patternInput_23[1], patternInput_22[1]];

  const coerce = function (assignedArg_1) {
    const isOutArg_1 = assignedArg_1.CalledArg.IsOutArg;
    const reflArgInfo_1 = assignedArg_1.CalledArg.ReflArgInfo;
    const calledArgTy_2 = assignedArg_1.CalledArg.CalledArgumentType;
    return coerceExpr(isOutArg_1, calledArgTy_2, reflArgInfo_1, assignedArg_1.CallerArg.data[0], assignedArg_1.CallerArg.data[1], assignedArg_1.CallerArg.data[3]);
  };

  iterate(function (assignedArg_2) {
    if (assignedArg_2.NamedArgIdOpt != null) {
      const item = new Item(20, [defaultArg(assignedArg_2.CalledArg.NameOpt, getValue(assignedArg_2.NamedArgIdOpt)), assignedArg_2.CalledArg.CalledArgumentType, new ArgumentContainer(0, finalCalledMethInfo)]);
      CallNameResolutionSink(cenv_1.tcSink, getValue(assignedArg_2.NamedArgIdOpt).idRange, env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, ad);
    }
  }, patternInput_24[1]);
  const allArgsCoerced = map_1(coerce, patternInput_24[1]);
  const patternInput_25 = BuildPossiblyConditionalMethodCall(cenv_1, env, mut, mMethExpr, isProp, finalCalledMethInfo, isSuperInit, finalCalledMethInst, patternInput_16[1], allArgsCoerced);
  let patternInput_26;

  if (patternInput_24[3].tail == null) {
    patternInput_26 = [patternInput_25[0], patternInput_25[1]];
  } else {
    const outArgTys = map_1(function (arg10__6) {
      return tyOfExpr(cenv_1.g, arg10__6);
    }, patternInput_24[2]);
    const expr_6 = isUnitTy(cenv_1.g, patternInput_25[1]) ? mkCompGenSequential(mMethExpr, patternInput_25[0], mkRefTupled(cenv_1.g, mMethExpr, patternInput_24[2], outArgTys)) : mkRefTupled(cenv_1.g, mMethExpr, new List(patternInput_25[0], patternInput_24[2]), new List(patternInput_25[1], outArgTys));
    const expr_7 = mkLetsBind(mMethExpr, patternInput_24[3], expr_6);
    patternInput_26 = [expr_7, tyOfExpr(cenv_1.g, expr_7)];
  }

  let expr_9;

  if (isCheckingAttributeCall) {
    expr_9 = patternInput_26[0];
  } else if (finalAssignedItemSetters.tail == null) {
    expr_9 = patternInput_26[0];
  } else {
    const patternInput_27 = mkMutableCompGenLocal(mMethExpr, "returnVal", patternInput_26[1]);
    const propSetExpr = fold(function (acc, _arg69) {
      const m_1 = _arg69.data[2].data[1];
      const isOptCallerArg = _arg69.data[2].data[2];
      const callerArgTy_1 = _arg69.data[2].data[0];
      const argExpr = _arg69.data[2].data[3];

      if (isOptCallerArg) {
        error_1(new _Error(SR.tcInvalidOptionalAssignmentToPropertyOrField(), m_1));
      }

      let patternInput_28;

      if (_arg69.data[1].tag === 1) {
        ILFieldInstanceChecks(cenv_1.g, cenv_1.amap, ad, m_1, _arg69.data[1].data);

        const calledArgTy_3 = _arg69.data[1].data.FieldType(cenv_1.amap, m_1);

        const argExpr_1 = coerceExpr(false, calledArgTy_3, new ReflectedArgInfo(0), callerArgTy_1, m_1, argExpr);
        const action = BuildILFieldSet(cenv_1.g, m_1, patternInput_27[1], _arg69.data[1].data, argExpr_1);
        patternInput_28 = [action, new Item(7, _arg69.data[1].data)];
      } else if (_arg69.data[1].tag === 2) {
        RecdFieldInstanceChecks(cenv_1.g, cenv_1.amap, ad, m_1, _arg69.data[1].data);
        const calledArgTy_4 = _arg69.data[1].data.FieldType;
        CheckRecdFieldMutation(m_1, denv, _arg69.data[1].data);
        const argExpr_2 = coerceExpr(false, calledArgTy_4, new ReflectedArgInfo(0), callerArgTy_1, m_1, argExpr);
        const action_1 = BuildRecdFieldSet(cenv_1.g, m_1, patternInput_27[1], _arg69.data[1].data, argExpr_2);
        patternInput_28 = [action_1, new Item(5, _arg69.data[1].data)];
      } else {
        MethInfoChecks(cenv_1.g, cenv_1.amap, true, null, ofArray([patternInput_27[1]]), ad, m_1, _arg69.data[1].data[1]);

        const calledArgTy_5 = _arg69.data[1].data[1].GetParamTypes(cenv_1.amap, m_1, _arg69.data[1].data[2]).head.head;

        const argExpr_3 = coerceExpr(false, calledArgTy_5, new ReflectedArgInfo(0), callerArgTy_1, m_1, argExpr);
        const mut_1 = isStructTy(cenv_1.g, tyOfExpr(cenv_1.g, patternInput_27[1])) ? new Mutates(0) : new Mutates(1);
        const action_2 = BuildPossiblyConditionalMethodCall(cenv_1, env, mut_1, m_1, true, _arg69.data[1].data[1], new ValUseFlag(1), _arg69.data[1].data[2], ofArray([patternInput_27[1]]), ofArray([argExpr_3]))[0];
        patternInput_28 = [action_2, new Item(9, [_arg69.data[1].data[0].PropertyName, ofArray([_arg69.data[1].data[0]])])];
      }

      const item_1 = new Item(21, [_arg69.data[0], patternInput_28[1]]);
      CallNameResolutionSink(cenv_1.tcSink, _arg69.data[0].idRange, env.NameEnv, item_1, item_1, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, ad);
      return mkCompGenSequential(m_1, acc, patternInput_28[0]);
    }, mkUnit(cenv_1.g, mMethExpr), finalAssignedItemSetters);
    const expr_8 = mkCompGenLet(mMethExpr, patternInput_27[0], patternInput_26[0], mkCompGenSequential(mMethExpr, propSetExpr, patternInput_27[1]));
    expr_9 = expr_8;
  }

  let expr_11;

  if (patternInput_13[2] != null) {
    const mkLambda = function (vs, expr_10) {
      if (vs.tail == null) {
        return mkUnitDelayLambda(cenv_1.g, mMethExpr, expr_10);
      } else {
        return mkMultiLambda(mMethExpr, vs, expr_10, tyOfExpr(cenv_1.g, expr_10));
      }
    };

    expr_11 = foldBack(mkLambda, getValue(patternInput_13[2]), expr_9);
  } else {
    expr_11 = expr_9;
  }

  let patternInput_30;

  if (patternInput_3[1] == null) {
    patternInput_30 = [expr_11, patternInput_13[4]];
  } else {
    const $var294 = patternInput_13[2] != null ? getValue(patternInput_13[2]).tail != null ? getValue(patternInput_13[2]).tail.tail == null ? [0, getValue(patternInput_13[2]).head] : [1] : [1] : [1];

    switch ($var294[0]) {
      case 0:
        const patternInput_29 = TcExpr(cenv_1, mkRefTupledVarsTy(cenv_1.g, $var294[1]), env, patternInput_13[4], getValue(patternInput_3[1]));
        patternInput_30 = [mkApps(cenv_1.g, [expr_11, tyOfExpr(cenv_1.g, expr_11)], new List(), ofArray([patternInput_29[0]]), mMethExpr), patternInput_29[1]];
        break;

      case 1:
        patternInput_30 = error_1(new InternalError("unreachable - expected some lambda vars for a tuple mismatch", mItem));
        break;
    }
  }

  const expr_12 = patternInput_24[0](patternInput_30[0]);
  const expr_13 = patternInput_16[0](expr_12);
  return [[expr_13, finalAttributeAssignedNamedItems, patternInput[2]], patternInput_30[1]];
}
export function TcUnnamedMethodArgs(cenv_1, env, lambdaPropagationInfo, tpenv, args) {
  return List_1.mapiFoldSquared(function (tupledArg, tupledArg_1) {
    return TcUnnamedMethodArg(cenv_1, env, tupledArg[0], tupledArg[1], tupledArg_1[0], tupledArg_1[1], tupledArg_1[2]);
  }, [lambdaPropagationInfo, tpenv], args);
}
export function TcUnnamedMethodArg(cenv_1, env, lambdaPropagationInfo, tpenv, i, j, _arg5) {
  const lambdaPropagationInfoForArg = Array.from(delay(function () {
    return collect_1(function (matchValue) {
      return singleton((i < matchValue[0].length ? j < matchValue[0][i].length : false) ? matchValue[0][i][j] : new ArgumentAnalysis(0));
    }, lambdaPropagationInfo);
  }));
  return TcMethodArg(cenv_1, env, lambdaPropagationInfo, tpenv, lambdaPropagationInfoForArg, new CallerArg_1(0, [_arg5.data[0], _arg5.data[1], _arg5.data[2], _arg5.data[3]]));
}
export function TcMethodNamedArgs(cenv_1, env, lambdaPropagationInfo, tpenv, args) {
  return List_1.mapFoldSquared(function (tupledArg, arg30_) {
    return TcMethodNamedArg(cenv_1, env, tupledArg[0], tupledArg[1], arg30_);
  }, [lambdaPropagationInfo, tpenv], args);
}
export function TcMethodNamedArg(cenv_1, env, lambdaPropagationInfo, tpenv, _arg6) {
  const lambdaPropagationInfoForArg = map_3(function (x) {
    return x != null ? x : new ArgumentAnalysis(0);
  }, Array.from(delay(function () {
    return collect_1(function (matchValue) {
      return singleton(tryPick(function (namedInfoForArgSet) {
        return tryPick(function (tupledArg) {
          return tupledArg[0].idText === _arg6.data[0].idText ? tupledArg[1] : null;
        }, namedInfoForArgSet);
      }, matchValue[1]));
    }, lambdaPropagationInfo);
  })), Array);
  const patternInput = TcMethodArg(cenv_1, env, lambdaPropagationInfo, tpenv, lambdaPropagationInfoForArg, _arg6.data[1]);
  const tpenv_1 = patternInput[1][1];
  const lambdaPropagationInfo_1 = patternInput[1][0];
  return [new CallerNamedArg(0, [_arg6.data[0], patternInput[0]]), [lambdaPropagationInfo_1, tpenv_1]];
}
export function TcMethodArg(cenv_1, env, lambdaPropagationInfo, tpenv, lambdaPropagationInfoForArg, _arg7) {
  if (lambdaPropagationInfoForArg.length > 0) {
    const allOverloadsAreNotCalledArgMatchesForThisArg = lambdaPropagationInfoForArg.every(function (_arg23) {
      const $var295 = _arg23.tag === 2 ? [0] : _arg23.tag === 0 ? [0] : _arg23.tag === 3 ? [1] : [0];

      switch ($var295[0]) {
        case 0:
          return true;

        case 1:
          return false;
      }
    });

    if (allOverloadsAreNotCalledArgMatchesForThisArg) {
      const overloadsWhichAreFuncAtThisPosition = Array.from(choose_2(function (_arg24) {
        return _arg24.tag === 2 ? Array.from(_arg24.data) : null;
      }, lambdaPropagationInfoForArg));

      if (overloadsWhichAreFuncAtThisPosition.length > 0) {
        const minFuncArity = reduce((f => (x, y) => f(x) < f(y) ? x : y)(function (array) {
          return array.length;
        }), overloadsWhichAreFuncAtThisPosition).length | 0;
        const prefixOfLambdaArgsForEachOverload = map_3(function (array_1) {
          return array_1.slice(0, minFuncArity);
        }, overloadsWhichAreFuncAtThisPosition, Array);

        if (prefixOfLambdaArgsForEachOverload.length > 0) {
          const numLambdaVars = prefixOfLambdaArgsForEachOverload[0].length | 0;

          const loop = function (callerLambdaTy, lambdaVarNum) {
            if (lambdaVarNum < numLambdaVars) {
              const col = toList(delay(function () {
                return map_2(function (row) {
                  return row[lambdaVarNum];
                }, prefixOfLambdaArgsForEachOverload);
              }));

              if ((() => {
                const $var296 = ListSet.setify(function (arg10_, arg20_) {
                  return typeEquiv(cenv_1.g, arg10_, arg20_);
                }, col);
                const $var297 = $var296.tail != null ? $var296.tail.tail == null ? [0] : [1] : [1];

                switch ($var297[0]) {
                  case 0:
                    return true;

                  case 1:
                    return false;
                }
              })()) {
                const calledLambdaArgTy = item_6(0, col);
                const matchValue = UnifyFunctionTypeUndoIfFailed(cenv_1, env.DisplayEnv, _arg7.data[1], callerLambdaTy);

                if (matchValue == null) {} else {
                  const callerLambdaRangeTy = getValue(matchValue)[1];
                  const callerLambdaDomainTy = getValue(matchValue)[0];

                  if (AddCxTypeEqualsTypeUndoIfFailed(env.DisplayEnv, cenv_1.css, _arg7.data[1], calledLambdaArgTy, callerLambdaDomainTy)) {
                    loop(callerLambdaRangeTy, lambdaVarNum + 1);
                  }
                }
              }
            }
          };

          loop(_arg7.data[0], 0);
        }
      }
    }
  }

  const patternInput = TcExpr(cenv_1, _arg7.data[0], env, tpenv, _arg7.data[3]);
  const lambdaPropagationInfo_1 = Array.from(delay(function () {
    return collect_1(function (matchValue_1) {
      const $var298 = matchValue_1[1].tag === 0 ? [1] : matchValue_1[1].tag === 2 ? [1] : matchValue_1[1].tag === 3 ? [2] : [0];

      switch ($var298[0]) {
        case 0:
          return empty();

        case 1:
          return singleton(matchValue_1[0]);

        case 2:
          if (AddCxTypeMustSubsumeTypeMatchingOnlyUndoIfFailed(env.DisplayEnv, cenv_1.css, _arg7.data[1], matchValue_1[1].data, _arg7.data[0])) {
            return singleton(matchValue_1[0]);
          } else {
            return empty();
          }

      }
    }, Array.from(zip(lambdaPropagationInfo, lambdaPropagationInfoForArg)));
  }));
  return [new CallerArg_1(0, [_arg7.data[0], _arg7.data[1], _arg7.data[2], patternInput[0]]), [lambdaPropagationInfo_1, patternInput[1]]];
}
export function TcNewDelegateThen(cenv_1, overallTy, env, tpenv, mDelTy, mExprAndArg, delegateTy, arg, atomicFlag, delayed) {
  UnifyTypes(cenv_1, env, mExprAndArg, overallTy, delegateTy);
  const patternInput = GetSigOfFunctionForDelegate(cenv_1.infoReader, delegateTy, mDelTy, env.eAccessRights);
  MethInfoChecks(cenv_1.g, cenv_1.amap, true, null, new List(), env.eAccessRights, mExprAndArg, patternInput.data[0]);
  const args = GetMethodArgs(arg);
  const $var299 = args[0].tail != null ? args[0].tail.tail == null ? args[1].tail == null ? [0, args[0].head] : [1] : [1] : [1];

  switch ($var299[0]) {
    case 0:
      const m = arg.Range;
      const patternInput_1 = TcMethodArg(cenv_1, env, new Array(0), tpenv, new Array(0), new CallerArg_1(0, [patternInput.data[3], m, false, $var299[1]]));
      const tpenv_1 = patternInput_1[1][1];
      const expr = BuildNewDelegateExpr(null, cenv_1.g, cenv_1.amap, delegateTy, patternInput.data[0], patternInput.data[1], patternInput_1[0].Expr, patternInput.data[3], m);
      return PropagateThenTcDelayed(cenv_1, overallTy, env, tpenv_1, m, MakeApplicableExprNoFlex(cenv_1, expr), delegateTy, atomicFlag, delayed);

    case 1:
      return error_1(new _Error(SR.tcDelegateConstructorMustBePassed(), mExprAndArg));
  }
}
export function bindLetRec(binds, m, e) {
  if (binds.tail == null) {
    return e;
  } else {
    return new Expr(6, [binds, e, m, NewFreeVarsCache()]);
  }
}
export function CheckRecursiveBindingIds(binds) {
  const hashOfBinds = new Set();

  for (let forLoopVar of binds) {
    let nm;
    const $var300 = forLoopVar.data[7].tag === 2 ? [0, forLoopVar.data[7].data[1]] : forLoopVar.data[7].tag === 7 ? forLoopVar.data[7].data[0].data[0].tail != null ? forLoopVar.data[7].data[0].data[0].tail.tail == null ? [1, forLoopVar.data[7].data[0].data[0].head] : [2] : [2] : [2];

    switch ($var300[0]) {
      case 0:
        nm = $var300[1].idText;
        break;

      case 1:
        nm = $var300[1].idText;
        break;

      case 2:
        nm = "";
        break;
    }

    if (nm !== "" ? !addInPlace(nm, hashOfBinds) : false) {
      error_1(new Duplicate("value", nm, forLoopVar.data[10]));
    }
  }
}
export function TcLinearExprs($var578, $var579, $var580, $var581, $var582, $var583, $var584, $var585) {
  TcLinearExprs: while (true) {
    const bodyChecker = $var578;
    const cenv_1 = $var579;
    const env = $var580;
    const overallTy = $var581;
    const tpenv = $var582;
    const isCompExpr = $var583;
    const expr = $var584;
    const cont = $var585;
    const $var301 = expr.tag === 26 ? expr.data[1] ? !isCompExpr ? [0, expr.data[2], expr.data[3], expr.data[4], expr.data[0]] : [1] : [1] : [1];

    switch ($var301[0]) {
      case 0:
        const patternInput = TcStmtThatCantBeCtorBody(cenv_1, env, tpenv, $var301[1]);
        const env_1 = ShrinkContext(env, $var301[3], $var301[2].Range);
        $var578 = bodyChecker;
        $var579 = cenv_1;
        $var580 = env_1;
        $var581 = overallTy;
        $var582 = tpenv;
        $var583 = isCompExpr;
        $var584 = $var301[2];

        $var585 = function (tupledArg) {
          return cont([new Expr(2, [patternInput[0], tupledArg[0], new SequentialOpKind(0), $var301[4], $var301[3]]), tupledArg[1]]);
        };

        continue TcLinearExprs;

      case 1:
        const $var302 = expr.tag === 22 ? !(expr.data[1] ? isCompExpr : false) ? [0, expr.data[2], expr.data[3], expr.data[0], expr.data[1], expr.data[4]] : [1] : [1];

        switch ($var302[0]) {
          case 0:
            if ($var302[3]) {
              CheckRecursiveBindingIds($var302[1]);
              const binds = map_1(function (x) {
                return new RecDefnBindingInfo(0, [ExprContainerInfo, new NewSlotsOK(1), new DeclKind(5), x]);
              }, $var302[1]);

              if ($var302[4]) {
                errorR(new _Error(SR.tcBindingCannotBeUseAndRec(), $var302[5]));
              }

              const patternInput_1 = TcLetrec(new OverridesOK(2), cenv_1, env, tpenv, binds, $var302[5], $var302[5]);
              const patternInput_2 = bodyChecker(overallTy, patternInput_1[1], patternInput_1[2], $var302[2]);
              const bodyExpr = bindLetRec(patternInput_1[0], $var302[5], patternInput_2[0]);
              return cont([bodyExpr, patternInput_2[1]]);
            } else {
              const patternInput_3 = TcLetBinding(cenv_1, $var302[4], env, ExprContainerInfo, new DeclKind(5), tpenv, $var302[1], $var302[5], $var302[2].Range);
              const envinner = ShrinkContext(patternInput_3[1], $var302[5], $var302[2].Range);
              $var578 = bodyChecker;
              $var579 = cenv_1;
              $var580 = envinner;
              $var581 = overallTy;
              $var582 = patternInput_3[2];
              $var583 = isCompExpr;
              $var584 = $var302[2];

              $var585 = function (tupledArg_1) {
                return cont([patternInput_3[0]([tupledArg_1[0], overallTy])[0], tupledArg_1[1]]);
              };

              continue TcLinearExprs;
            }

          case 1:
            return cont(bodyChecker(overallTy, env, tpenv, expr));
        }

    }
  }
}
export function TcAndPatternCompileMatchClauses(mExpr, matchm, actionOnFailure, cenv_1, inputTy, resultTy, env, tpenv, clauses) {
  const patternInput = TcMatchClauses(cenv_1, inputTy, resultTy, env, tpenv, clauses);
  const patternInput_1 = CompilePatternForMatchClauses(cenv_1, env, mExpr, matchm, true, actionOnFailure, inputTy, resultTy, patternInput[0]);
  return [patternInput_1[0], patternInput_1[1], patternInput[1]];
}
export function TcMatchPattern(cenv_1, inputTy, env, tpenv, pat, optWhenExpr) {
  const m = pat.Range;
  const patternInput = TcPat(new WarnOnUpperFlag(0), cenv_1, env, null, new ValInline(2), permitInferTypars, noArgOrRetAttribs, false, null, false, tpenv, create(null, new Comparer(comparePrimitives)), create_1(null, new Comparer(comparePrimitives)), inputTy, pat);
  const tpenv_1 = patternInput[1][0];
  const names = patternInput[1][1];
  const patternInput_1 = MakeAndPublishSimpleVals(cenv_1, env, m, names, false);
  let patternInput_3;

  if (optWhenExpr == null) {
    patternInput_3 = [null, tpenv_1];
  } else {
    let guardEnv;
    const eContextInfo = new ContextInfo(12, getValue(optWhenExpr).Range);
    guardEnv = new TcEnv(patternInput_1[0].eNameResEnv, patternInput_1[0].eUngeneralizableItems, patternInput_1[0].ePath, patternInput_1[0].eCompPath, patternInput_1[0].eAccessPath, patternInput_1[0].eAccessRights, patternInput_1[0].eInternalsVisibleCompPaths, patternInput_1[0].eModuleOrNamespaceTypeAccumulator, eContextInfo, patternInput_1[0].eFamilyType, patternInput_1[0].eCtorInfo, patternInput_1[0].eCallerMemberName);
    const patternInput_2 = TcExpr(cenv_1, cenv_1.g.bool_ty, guardEnv, tpenv_1, getValue(optWhenExpr));
    patternInput_3 = [patternInput_2[0], patternInput_2[1]];
  }

  return [patternInput[0](new TcPatPhase2Input(0, [patternInput_1[1], true])), patternInput_3[0], NameMapModule.range(patternInput_1[2]), patternInput_1[0], patternInput_3[1]];
}
export function TcMatchClauses(cenv_1, inputTy, resultTy, env, tpenv, clauses) {
  const first = {
    contents: true
  };

  const isFirst = function () {
    if (first.contents) {
      first.contents = false;
      return true;
    } else {
      return false;
    }
  };

  return mapFold(CurriedLambda(function (clause) {
    const isFirst_1 = isFirst();
    return function (arg60_) {
      return TcMatchClause(cenv_1, inputTy, resultTy, env, isFirst_1, clause, arg60_);
    };
  }), tpenv, clauses, ofArray);
}
export function TcMatchClause(cenv_1, inputTy, resultTy, env, isFirst, tpenv, _arg8) {
  const patternInput = TcMatchPattern(cenv_1, inputTy, env, tpenv, _arg8.data[0], _arg8.data[1]);
  let resultEnv;

  if (isFirst) {
    resultEnv = patternInput[3];
  } else {
    const eContextInfo = new ContextInfo(11, _arg8.data[2].Range);
    resultEnv = new TcEnv(patternInput[3].eNameResEnv, patternInput[3].eUngeneralizableItems, patternInput[3].ePath, patternInput[3].eCompPath, patternInput[3].eAccessPath, patternInput[3].eAccessRights, patternInput[3].eInternalsVisibleCompPaths, patternInput[3].eModuleOrNamespaceTypeAccumulator, eContextInfo, patternInput[3].eFamilyType, patternInput[3].eCtorInfo, patternInput[3].eCallerMemberName);
  }

  const patternInput_1 = TcExprThatCanBeCtorBody(cenv_1, resultTy, resultEnv, patternInput[4], _arg8.data[2]);
  return [new TypedMatchClause(0, [patternInput[0], patternInput[1], new DecisionTreeTarget(0, [patternInput[2], patternInput_1[0], _arg8.data[4]]), _arg8.data[3]]), patternInput_1[1]];
}
export function TcStaticOptimizationConstraint(cenv_1, env, tpenv, c) {
  if (c.tag === 1) {
    if (!cenv_1.g.compilingFslib) {
      errorR(new _Error(SR.tcStaticOptimizationConditionalsOnlyForFSharpLibrary(), c.data[1]));
    }

    const patternInput = TcTypar(cenv_1, env, new ImplictlyBoundTyparsAllowed(1), tpenv, c.data[0]);
    return [new StaticOptimization(1, mkTyparTy(patternInput[0])), patternInput[1]];
  } else {
    if (!cenv_1.g.compilingFslib) {
      errorR(new _Error(SR.tcStaticOptimizationConditionalsOnlyForFSharpLibrary(), c.data[2]));
    }

    const patternInput_1 = TcType(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, c.data[1]);
    const patternInput_2 = TcTypar(cenv_1, env, new ImplictlyBoundTyparsAllowed(1), patternInput_1[1], c.data[0]);
    return [new StaticOptimization(0, [mkTyparTy(patternInput_2[0]), patternInput_1[0]]), patternInput_2[1]];
  }
}
export function mkConvToNativeInt(g, e, m) {
  return new Expr(11, [new TOp(22, [ofArray([new ILInstr(11, new ILBasicType(11))]), ofArray([g.nativeint_ty])]), new List(), ofArray([e]), m]);
}
export function TcAndBuildFixedExpr(cenv_1, env, overallPatTy, fixedExpr, overallExprTy, mBinding) {
  warning(new PossibleUnverifiableCode(mBinding));

  if (isByrefTy(cenv_1.g, overallExprTy)) {
    let okByRef;
    const matchValue = stripExpr(fixedExpr);

    if (matchValue.tag === 11) {
      const matchValue_1 = [matchValue.data[0], matchValue.data[1], matchValue.data[2]];
      const $var303 = matchValue_1[0].tag === 13 ? matchValue_1[2].tail != null ? matchValue_1[2].tail.tail == null ? [0, matchValue_1[0].data] : [4] : [4] : matchValue_1[0].tag === 22 ? matchValue_1[0].data[0].tail != null ? matchValue_1[0].data[0].head.tag === 62 ? matchValue_1[0].data[0].tail.tail == null ? [1, matchValue_1[0].data[0].head.data] : [4] : matchValue_1[0].data[0].head.tag === 80 ? matchValue_1[0].data[0].tail.tail == null ? [2] : [4] : [4] : [4] : matchValue_1[0].tag === 23 ? [3] : [4];

      switch ($var303[0]) {
        case 0:
          okByRef = !$var303[1].Tycon.IsStructOrEnumTycon;
          break;

        case 1:
          okByRef = $var303[1].DeclaringType.Boxity.Equals(new ILBoxity(0));
          break;

        case 2:
          okByRef = true;
          break;

        case 3:
          okByRef = true;
          break;

        case 4:
          okByRef = false;
          break;
      }
    } else {
      okByRef = false;
    }

    if (!okByRef) {
      error_1(new _Error(SR.tcFixedNotAllowed(), mBinding));
    }

    const elemTy = destByrefTy(cenv_1.g, overallExprTy);
    UnifyTypes(cenv_1, env, mBinding, mkNativePtrTy(cenv_1.g, elemTy), overallPatTy);
    return mkCompGenLetIn(mBinding, "pinnedByref", overallExprTy, fixedExpr, function (tupledArg) {
      tupledArg[0].SetIsFixed();
      return mkConvToNativeInt(cenv_1.g, tupledArg[1], mBinding);
    });
  } else if (isStringTy(cenv_1.g, overallExprTy)) {
    const charPtrTy = mkNativePtrTy(cenv_1.g, cenv_1.g.char_ty);
    UnifyTypes(cenv_1, env, mBinding, charPtrTy, overallPatTy);
    return mkCompGenLetIn(mBinding, "pinnedString", cenv_1.g.string_ty, fixedExpr, function (tupledArg_1) {
      tupledArg_1[0].SetIsFixed();
      const addrOffset = BuildOffsetToStringData(cenv_1, env, mBinding);
      const stringAsNativeInt = mkConvToNativeInt(cenv_1.g, tupledArg_1[1], mBinding);
      const plusOffset = new Expr(11, [new TOp(22, [ofArray([new ILInstr(0)]), ofArray([cenv_1.g.nativeint_ty])]), new List(), ofArray([stringAsNativeInt, addrOffset]), mBinding]);
      return mkNullTest(cenv_1.g, mBinding, tupledArg_1[1], plusOffset, tupledArg_1[1]);
    });
  } else if (isArray1DTy(cenv_1.g, overallExprTy)) {
    const elemTy_1 = destArrayTy(cenv_1.g, overallExprTy);
    const elemPtrTy = mkNativePtrTy(cenv_1.g, elemTy_1);
    UnifyTypes(cenv_1, env, mBinding, elemPtrTy, overallPatTy);
    return mkCompGenLetIn(mBinding, "tmpArray", overallExprTy, fixedExpr, function (tupledArg_2) {
      const elemZeroAddress = mkArrayElemAddress(cenv_1.g, new ILReadonly(1), false, ILArrayShape.SingleDimensional, elemTy_1, tupledArg_2[1], mkInt32(cenv_1.g, mBinding, 0), mBinding);
      const zero = mkConvToNativeInt(cenv_1.g, mkInt32(cenv_1.g, mBinding, 0), mBinding);
      const arrayLengthExpr = mkCallArrayLength(cenv_1.g, mBinding, elemTy_1, tupledArg_2[1]);
      return mkNullTest(cenv_1.g, mBinding, tupledArg_2[1], mkNullTest(cenv_1.g, mBinding, arrayLengthExpr, mkCompGenLetIn(mBinding, "pinnedByref", mkByrefTy(cenv_1.g, elemTy_1), elemZeroAddress, function (tupledArg_3) {
        tupledArg_3[0].SetIsFixed();
        return mkConvToNativeInt(cenv_1.g, tupledArg_3[1], mBinding);
      }), zero), zero);
    });
  } else {
    return error_1(new _Error(SR.tcFixedNotAllowed(), mBinding));
  }
}
export function TcNormalizedBinding(declKind, cenv_1, env, tpenv, overallTy, safeThisValOpt, safeInitInfo, enclosingDeclaredTypars, _arg9, bind) {
  const envinner = AddDeclaredTypars(new CheckForDuplicateTyparFlag(1), append(enclosingDeclaredTypars, _arg9.data[1]), env);
  const spatsL = bind.data[9].data[0];
  const rtyOpt = bind.data[9].data[1];
  const rhsExpr = bind.data[9].data[2];
  let callerName;
  const matchValue = [declKind, bind.data[1], bind.data[8]];
  const $var304 = matchValue[0].tag === 5 ? [0] : matchValue[0].tag === 3 ? matchValue[2].tag === 2 ? [1, matchValue[2].data[1]] : matchValue[0].data ? matchValue[1].tag === 2 ? [3] : [5] : matchValue[1].tag === 2 ? [2] : [5] : matchValue[0].tag === 0 ? matchValue[2].tag === 2 ? [1, matchValue[2].data[1]] : matchValue[1].tag === 0 ? [4] : [5] : matchValue[2].tag === 2 ? [1, matchValue[2].data[1]] : [5];

  switch ($var304[0]) {
    case 0:
      callerName = envinner.eCallerMemberName;
      break;

    case 1:
      if (bind.data[7].data[0] != null) {
        switch (getValue(bind.data[7].data[0]).MemberKind.tag) {
          case 3:
          case 4:
          case 5:
            callerName = $var304[1].idText.substr(4);
            break;

          case 0:
            callerName = ".ctor";
            break;

          case 1:
            callerName = ".ctor";
            break;

          default:
            callerName = $var304[1].idText;
        }
      } else {
        callerName = $var304[1].idText;
      }

      break;

    case 2:
      callerName = ".ctor";
      break;

    case 3:
      callerName = ".cctor";
      break;

    case 4:
      callerName = ".cctor";
      break;

    case 5:
      callerName = envinner.eCallerMemberName;
      break;
  }

  const envinner_1 = new TcEnv(envinner.eNameResEnv, envinner.eUngeneralizableItems, envinner.ePath, envinner.eCompPath, envinner.eAccessPath, envinner.eAccessRights, envinner.eInternalsVisibleCompPaths, envinner.eModuleOrNamespaceTypeAccumulator, envinner.eContextInfo, envinner.eFamilyType, envinner.eCtorInfo, callerName);

  const attrTgt = function (arg00, arg10) {
    return DeclKind.AllowedAttribTargets(arg00, arg10);
  }(bind.data[7].data[0], declKind) | 0;

  const patternInput = rhsExpr.tag === 58 ? [true, rhsExpr.data[0], NewInferenceType(), overallTy] : [false, rhsExpr, overallTy, overallTy];

  const TcAttrs = function (tgt, attrs) {
    const attrs_1 = TcAttributes(cenv_1, envinner_1, tgt, attrs);

    if (attrTgt === 0 ? !(attrs_1.tail == null) : false) {
      errorR(new _Error(SR.tcAttributesAreNotPermittedOnLetBindings(), bind.data[10]));
    }

    return attrs_1;
  };

  const valAttribs = TcAttrs(attrTgt, bind.data[4]);
  const isVolatile = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_VolatileFieldAttribute, valAttribs);
  const inlineFlag = ComputeInlineFlag(bind.data[7].data[0], bind.data[2], bind.data[3], bind.data[10]);
  const argAttribs = map_1($var305 => map_1($var306 => CurriedLambda(TcAttrs)(2048)(function (arg00_) {
    return SynInfo.AttribsOfArgData(arg00_);
  }($var306)), SynInfo.InferSynArgInfoFromSimplePats($var305)), spatsL);
  let retAttribs;

  if (rtyOpt == null) {
    retAttribs = new List();
  } else {
    const retAttrs = getValue(rtyOpt).data[2];
    retAttribs = TcAttrs(8192, retAttrs);
  }

  const argAndRetAttribs = new ArgAndRetAttribs(0, [argAttribs, retAttribs]);

  if (HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_DefaultValueAttribute, valAttribs)) {
    errorR(new _Error(SR.tcDefaultValueAttributeRequiresVal(), bind.data[10]));
  }

  const isThreadStatic = isThreadOrContextStatic(cenv_1.g, valAttribs);

  if (isThreadStatic) {
    errorR(new DeprecatedThreadStaticBindingWarning(bind.data[10]));
  }

  if (isVolatile) {
    if (declKind.tag === 3) {} else {
      errorR(new _Error(SR.tcVolatileOnlyOnClassLetBindings(), bind.data[10]));
    }

    if (!bind.data[3] ? true : isThreadStatic) {
      errorR(new _Error(SR.tcVolatileFieldsMustBeMutable(), bind.data[10]));
    }
  }

  if (patternInput[0] ? (!declKind.Equals(new DeclKind(5)) ? true : bind.data[2]) ? true : bind.data[3] : false) {
    errorR(new _Error(SR.tcFixedNotAllowed(), bind.data[10]));
  }

  if ((!declKind.CanBeDllImport ? true : bind.data[7].data[0] != null ? getValue(bind.data[7].data[0]).IsInstance : false) ? HasFSharpAttributeOpt(cenv_1.g, cenv_1.g.attrib_DllImportAttribute, valAttribs) : false) {
    errorR(new _Error(SR.tcDllImportNotAllowed(), bind.data[10]));
  }

  if (bind.data[7].data[0] == null ? HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_ConditionalAttribute, valAttribs) : false) {
    errorR(new _Error(SR.tcConditionalAttributeRequiresMembers(), bind.data[10]));
  }

  if (HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_EntryPointAttribute, valAttribs)) {
    if (bind.data[7].data[0] != null) {
      errorR(new _Error(SR.tcEntryPointAttributeRequiresFunctionInModule(), bind.data[10]));
    } else {
      UnifyTypes(cenv_1, env, bind.data[10], patternInput[2], op_MinusMinusGreater(mkArrayType(cenv_1.g, cenv_1.g.string_ty), cenv_1.g.int_ty));
    }
  }

  if (bind.data[3] ? bind.data[2] : false) {
    errorR(new _Error(SR.tcMutableValuesCannotBeInline(), bind.data[10]));
  }

  if (bind.data[3] ? !(_arg9.data[1].tail == null) : false) {
    errorR(new _Error(SR.tcMutableValuesMayNotHaveGenericParameters(), bind.data[10]));
  }

  const flex = bind.data[3] ? dontInferTypars : _arg9;

  if (bind.data[3] ? !(spatsL.tail == null) : false) {
    errorR(new _Error(SR.tcMutableValuesSyntax(), bind.data[10]));
  }

  let isInline;

  if ((bind.data[2] ? spatsL.tail == null : false) ? _arg9.data[1].tail == null : false) {
    errorR(new _Error(SR.tcOnlyFunctionsCanBeInline(), bind.data[10]));
    isInline = false;
  } else {
    isInline = bind.data[2];
  }

  const partialValReprInfo = TranslateTopValSynInfo(bind.data[10], function (attrTgt_1, synAttribs) {
    return TcAttributes(cenv_1, env, attrTgt_1, synAttribs);
  }, bind.data[7].data[1]);
  const patternInput_1 = TcPat(new WarnOnUpperFlag(1), cenv_1, envinner_1, partialValReprInfo, inlineFlag, flex, argAndRetAttribs, bind.data[3], bind.data[0], false, tpenv, NameMapModule.empty(), create_1(null, new Comparer(comparePrimitives)), patternInput[2], bind.data[8]);
  const tpenv_1 = patternInput_1[1][0];
  const nameToPrelimValSchemeMap = patternInput_1[1][1];
  let apinfoOpt;
  const matchValue_1 = NameMapModule.range(nameToPrelimValSchemeMap);
  const $var307 = matchValue_1.tail != null ? matchValue_1.tail.tail == null ? [0, matchValue_1.head.data[0], matchValue_1.head.data[2]] : [1] : [1];

  switch ($var307[0]) {
    case 0:
      const matchValue_2 = ActivePatternInfoOfValName($var307[1].idText, $var307[1].idRange);

      if (matchValue_2 == null) {
        apinfoOpt = null;
      } else {
        apinfoOpt = [getValue(matchValue_2), $var307[2], $var307[1].idRange];
      }

      break;

    case 1:
      apinfoOpt = null;
      break;
  }

  let envinner_2;

  if (apinfoOpt == null) {
    envinner_2 = envinner_1;
  } else {
    const ty = getValue(apinfoOpt)[1];
    const m = getValue(apinfoOpt)[2];
    const apinfo = getValue(apinfoOpt)[0];

    if (bind.data[7].data[0] != null ? true : !apinfo.IsTotal ? apinfo.ActiveTags.length > 1 : false) {
      error_1(new _Error(SR.tcInvalidActivePatternName(), bind.data[10]));
    }

    iterateIndexed(function (i, tupledArg) {
      const item = new Item(2, [apinfo, cenv_1.g.unit_ty, i, tupledArg[1]]);
      CallNameResolutionSink(cenv_1.tcSink, tupledArg[1], env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(0), env.DisplayEnv, env.eAccessRights);
    }, apinfo.ActiveTagsWithRanges);
    envinner_2 = new TcEnv(AddActivePatternResultTagsToNameEnv(apinfo, envinner_1.eNameResEnv, ty, m), envinner_1.eUngeneralizableItems, envinner_1.ePath, envinner_1.eCompPath, envinner_1.eAccessPath, envinner_1.eAccessRights, envinner_1.eInternalsVisibleCompPaths, envinner_1.eModuleOrNamespaceTypeAccumulator, envinner_1.eContextInfo, envinner_1.eFamilyType, envinner_1.eCtorInfo, envinner_1.eCallerMemberName);
  }

  const isCtor = bind.data[7].data[0] != null ? getValue(bind.data[7].data[0]).MemberKind.Equals(new MemberKind_2(1)) : false;
  let patternInput_2;
  const atTopNonLambdaDefn = (DeclKind.IsModuleOrMemberOrExtensionBinding(declKind) ? patternInput[1].tag === 15 ? false : true : false) ? synExprContainsError(patternInput[1]) : false;
  patternInput_2 = conditionallySuppressErrorReporting(atTopNonLambdaDefn, function () {
    return isCtor ? TcExprThatIsCtorBody(safeThisValOpt, safeInitInfo, cenv_1, patternInput[3], envinner_2, tpenv_1, patternInput[1]) : TcExprThatCantBeCtorBody(cenv_1, patternInput[3], envinner_2, tpenv_1, patternInput[1]);
  });

  if (bind.data[1].Equals(new SynBindingKind(0)) ? !cenv_1.isScript : false) {
    UnifyUnitType(cenv_1, env, bind.data[10], patternInput[2], patternInput_2[0]);
  }

  const rhsExprChecked = patternInput[0] ? TcAndBuildFixedExpr(cenv_1, env, patternInput[2], patternInput_2[0], patternInput[3], bind.data[10]) : patternInput_2[0];

  if (apinfoOpt == null) {} else {
    const ty_1 = getValue(apinfoOpt)[1];
    const apinfo_1 = getValue(apinfoOpt)[0];
    const activePatResTys = NewInferenceTypes(apinfo_1.ActiveTags);
    const patternInput_3 = stripFunTy(cenv_1.g, ty_1);
    UnifyTypes(cenv_1, env, bind.data[10], function (arg00_1, arg10_1, arg20) {
      return ActivePatternInfo_ResultType.bind(apinfo_1)(arg00_1, arg10_1, arg20);
    }(cenv_1.g, patternInput[1].Range, activePatResTys), patternInput_3[1]);
  }

  const patternInput_4 = TcLiteral(cenv_1, patternInput[3], env, patternInput_2[1], valAttribs, patternInput[1]);

  if (patternInput_4[0]) {
    if (isThreadStatic) {
      errorR(new _Error(SR.tcIllegalAttributesForLiteral(), bind.data[10]));
    }

    if (bind.data[3]) {
      errorR(new _Error(SR.tcLiteralCannotBeMutable(), bind.data[10]));
    }

    if (isInline) {
      errorR(new _Error(SR.tcLiteralCannotBeInline(), bind.data[10]));
    }

    if (!(_arg9.data[1].tail == null)) {
      errorR(new _Error(SR.tcLiteralCannotHaveGenericParameters(), bind.data[10]));
    }
  }

  return [new CheckedBindingInfo(0, [inlineFlag, valAttribs, bind.data[5], patternInput_1[0], flex, nameToPrelimValSchemeMap, rhsExprChecked, argAndRetAttribs, patternInput[2], bind.data[10], bind.data[11], false, patternInput_4[1], patternInput[0]]), patternInput_2[1]];
}
export function TcLiteral(cenv_1, overallTy, env, tpenv, attrs, synLiteralValExpr) {
  const hasLiteralAttr = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_LiteralAttribute, attrs);

  if (hasLiteralAttr) {
    const patternInput = TcExpr(cenv_1, overallTy, env, tpenv, synLiteralValExpr);
    const matchValue = EvalLiteralExprOrAttribArg(cenv_1.g, patternInput[0]);

    if (matchValue.tag === 0) {
      if (matchValue.data[0].Equals(new Const(17)) ? isStructTy(cenv_1.g, matchValue.data[2]) : false) {
        warning(new _Error(SR.tcIllegalStructTypeForConstantExpression(), synLiteralValExpr.Range));
        return [false, null];
      } else {
        return [true, matchValue.data[0]];
      }
    } else {
      errorR(new _Error(SR.tcInvalidConstantExpression(), synLiteralValExpr.Range));
      return [true, new Const(16)];
    }
  } else {
    return [hasLiteralAttr, null];
  }
}
export function TcBindingTyparDecls(alwaysRigid, cenv_1, env, tpenv, _arg10) {
  const declaredTypars = TcTyparDecls(cenv_1, env, _arg10.data[0]);
  const envinner = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), declaredTypars, env);
  const tpenv_1 = TcTyparConstraints(cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(0), new ItemOccurence(2), envinner, tpenv, _arg10.data[2]);
  let rigidCopyOfDeclaredTypars_1;

  if (alwaysRigid) {
    iterate(function (tp) {
      SetTyparRigid(cenv_1.g, env.DisplayEnv, tp.Range, tp);
    }, declaredTypars);
    rigidCopyOfDeclaredTypars_1 = declaredTypars;
  } else {
    const rigidCopyOfDeclaredTypars = copyTypars(declaredTypars);
    iterate(function (tp_1) {
      SetTyparRigid(cenv_1.g, env.DisplayEnv, tp_1.Range, tp_1);
    }, rigidCopyOfDeclaredTypars);
    iterate(function (tp_2) {
      tp_2.SetRigidity(new TyparRigidity(1));
    }, declaredTypars);
    rigidCopyOfDeclaredTypars_1 = rigidCopyOfDeclaredTypars;
  }

  return [new ExplicitTyparInfo(0, [rigidCopyOfDeclaredTypars_1, declaredTypars, _arg10.data[1]]), tpenv_1];
}
export function TcNonrecBindingTyparDecls(cenv_1, env, tpenv, bind) {
  return TcBindingTyparDecls(true, cenv_1, env, tpenv, bind.data[6]);
}
export function TcNonRecursiveBinding(declKind, cenv_1, env, tpenv, ty, b) {
  const b_1 = BindingNormalization.NormalizeBinding(new IsObjExprBinding(1), cenv_1, env, b);
  const patternInput = TcNonrecBindingTyparDecls(cenv_1, env, tpenv, b_1);
  return TcNormalizedBinding(declKind, cenv_1, env, patternInput[1], ty, null, new SafeInitData(1), new List(), patternInput[0], b_1);
}
export function TcAttribute(canFail, cenv_1, env, attrTgt, synAttr) {
  const patternInput = List_1.frontAndBack(synAttr.TypeName.data[0]);
  const tpenv = emptyUnscopedTyparEnv;
  const attrTgt_1 = (synAttr.AppliesToGetterAndSetter ? attrTgt ^ 128 | 64 : attrTgt) | 0;
  let patternInput_1;

  const try1 = function (n) {
    const tyid = mkSynId(patternInput[1].idRange, n);
    const tycon = append(patternInput[0], ofArray([tyid]));
    const matchValue = ResolveTypeLongIdent(cenv_1.tcSink, cenv_1.nameResolver, new ItemOccurence(3), new FullyQualifiedFlag(1), env.eNameResEnv, env.eAccessRights, tycon, TypeNameResolutionStaticArgsInfo.DefiniteEmpty, new PermitDirectReferenceToGeneratedType(1));

    if (matchValue.tag === 1) {
      return ResultOrExceptionModule.raze(matchValue.data);
    } else {
      return ResultOrExceptionModule.success(TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(0), new ItemOccurence(3), env, tpenv, new SynType(1, [new SynType(0, new LongIdentWithDots(0, [tycon, new List()])), null, new List(), new List(), null, false, synAttr.Range])));
    }
  };

  patternInput_1 = ResultOrExceptionModule.ForceRaise(ResultOrExceptionModule.otherwise(function () {
    return try1(patternInput[1].idText);
  }, try1(patternInput[1].idText + "Attribute")));

  if (!IsTypeAccessible(cenv_1.g, cenv_1.amap, synAttr.Range, env.eAccessRights, patternInput_1[0])) {
    errorR(new _Error(SR.tcTypeIsInaccessible(), synAttr.Range));
  }

  const tcref = tcrefOfAppTy(cenv_1.g, patternInput_1[0]);
  const conditionalCallDefineOpt = TryFindTyconRefStringAttribute(cenv_1.g, synAttr.Range, cenv_1.g.attrib_ConditionalAttribute, tcref);
  const $var308 = conditionalCallDefineOpt != null ? !exists_1($var327 => equals(getValue(conditionalCallDefineOpt), $var327), cenv_1.conditionalDefines) ? [0, getValue(conditionalCallDefineOpt)] : [1] : [1];

  switch ($var308[0]) {
    case 0:
      return [new List(), false];

    case 1:
      let patternInput_2;

      if (tcref.IsILTycon) {
        const tdef = tcref.ILTyconRawMetadata;
        const tref = cenv_1.g.attrib_AttributeUsageAttribute.TypeRef;
        const matchValue_1 = TryDecodeILAttribute(cenv_1.g, tref, tdef.CustomAttrs);
        const $var309 = matchValue_1 != null ? getValue(matchValue_1)[0].tail != null ? getValue(matchValue_1)[0].head.tag === 5 ? getValue(matchValue_1)[0].tail.tail != null ? getValue(matchValue_1)[0].tail.head.tag === 1 ? getValue(matchValue_1)[0].tail.tail.tail != null ? getValue(matchValue_1)[0].tail.tail.head.tag === 1 ? getValue(matchValue_1)[0].tail.tail.tail.tail == null ? [1, getValue(matchValue_1)[0].tail.head.data, getValue(matchValue_1)[0].tail.tail.head.data, getValue(matchValue_1)[0].head.data] : [2] : [2] : [2] : [2] : [0, getValue(matchValue_1)[1], getValue(matchValue_1)[0].head.data] : [2] : [2] : [2];

        switch ($var309[0]) {
          case 0:
            let inherited;
            const matchValue_2 = tryPick(function (_arg25) {
              const $var310 = _arg25[0] === "Inherited" ? _arg25[3].tag === 1 ? [0] : [1] : [1];

              switch ($var310[0]) {
                case 0:
                  const res = _arg25[3].data;
                  return res;

                case 1:
                  return null;
              }
            }, $var309[1]);

            if (matchValue_2 != null) {
              inherited = getValue(matchValue_2);
            } else {
              inherited = true;
            }

            patternInput_2 = [$var309[2], inherited];
            break;

          case 1:
            patternInput_2 = [$var309[3], $var309[2]];
            break;

          case 2:
            patternInput_2 = [32767, true];
            break;
        }
      } else {
        const matchValue_3 = TryFindFSharpAttribute(cenv_1.g, cenv_1.g.attrib_AttributeUsageAttribute, tcref.Attribs);
        let $var311;

        if (matchValue_3 != null) {
          if (getValue(matchValue_3).data[2].tail != null) {
            const activePatternResult42527 = _AttribInt32Arg___(getValue(matchValue_3).data[2].head);

            if (activePatternResult42527 != null) {
              if (getValue(matchValue_3).data[2].tail.tail == null) {
                $var311 = [0, getValue(activePatternResult42527)];
              } else {
                $var311 = [1];
              }
            } else {
              $var311 = [1];
            }
          } else {
            $var311 = [1];
          }
        } else {
          $var311 = [1];
        }

        switch ($var311[0]) {
          case 0:
            patternInput_2 = [$var311[1], true];
            break;

          case 1:
            let $var312;

            if (matchValue_3 != null) {
              if (getValue(matchValue_3).data[2].tail != null) {
                const activePatternResult42524 = _AttribInt32Arg___(getValue(matchValue_3).data[2].head);

                if (activePatternResult42524 != null) {
                  if (getValue(matchValue_3).data[2].tail.tail != null) {
                    const activePatternResult42525 = _AttribBoolArg___(getValue(matchValue_3).data[2].tail.head);

                    if (activePatternResult42525 != null) {
                      if (getValue(matchValue_3).data[2].tail.tail.tail != null) {
                        const activePatternResult42526 = _AttribBoolArg___(getValue(matchValue_3).data[2].tail.tail.head);

                        if (activePatternResult42526 != null) {
                          if (getValue(matchValue_3).data[2].tail.tail.tail.tail == null) {
                            $var312 = [0, getValue(activePatternResult42525), getValue(activePatternResult42526), getValue(activePatternResult42524)];
                          } else {
                            $var312 = [1];
                          }
                        } else {
                          $var312 = [1];
                        }
                      } else {
                        $var312 = [1];
                      }
                    } else {
                      $var312 = [1];
                    }
                  } else {
                    $var312 = [1];
                  }
                } else {
                  $var312 = [1];
                }
              } else {
                $var312 = [1];
              }
            } else {
              $var312 = [1];
            }

            switch ($var312[0]) {
              case 0:
                patternInput_2 = [$var312[3], $var312[2]];
                break;

              case 1:
                if (matchValue_3 != null) {
                  warning(new _Error(SR.tcUnexpectedConditionInImportedAssembly(), synAttr.Range));
                  patternInput_2 = [32767, true];
                } else {
                  patternInput_2 = [32767, true];
                }

                break;
            }

            break;
        }
      }

      const possibleTgts = patternInput_2[0] & attrTgt_1 | 0;
      let directedTgts;
      const $var313 = synAttr.Target != null ? getValue(synAttr.Target).idText === "assembly" ? [0, getValue(synAttr.Target)] : [1] : [1];

      switch ($var313[0]) {
        case 0:
          directedTgts = 1;
          break;

        case 1:
          const $var314 = synAttr.Target != null ? getValue(synAttr.Target).idText === "module" ? [0, getValue(synAttr.Target)] : [1] : [1];

          switch ($var314[0]) {
            case 0:
              directedTgts = 2;
              break;

            case 1:
              const $var315 = synAttr.Target != null ? getValue(synAttr.Target).idText === "return" ? [0, getValue(synAttr.Target)] : [1] : [1];

              switch ($var315[0]) {
                case 0:
                  directedTgts = 8192;
                  break;

                case 1:
                  const $var316 = synAttr.Target != null ? getValue(synAttr.Target).idText === "field" ? [0, getValue(synAttr.Target)] : [1] : [1];

                  switch ($var316[0]) {
                    case 0:
                      directedTgts = 256;
                      break;

                    case 1:
                      const $var317 = synAttr.Target != null ? getValue(synAttr.Target).idText === "property" ? [0, getValue(synAttr.Target)] : [1] : [1];

                      switch ($var317[0]) {
                        case 0:
                          directedTgts = 128;
                          break;

                        case 1:
                          const $var318 = synAttr.Target != null ? getValue(synAttr.Target).idText === "method" ? [0, getValue(synAttr.Target)] : [1] : [1];

                          switch ($var318[0]) {
                            case 0:
                              directedTgts = 64;
                              break;

                            case 1:
                              const $var319 = synAttr.Target != null ? getValue(synAttr.Target).idText === "param" ? [0, getValue(synAttr.Target)] : [1] : [1];

                              switch ($var319[0]) {
                                case 0:
                                  directedTgts = 2048;
                                  break;

                                case 1:
                                  const $var320 = synAttr.Target != null ? getValue(synAttr.Target).idText === "type" ? [0, getValue(synAttr.Target)] : [1] : [1];

                                  switch ($var320[0]) {
                                    case 0:
                                      directedTgts = AttributeTargets.TyconDecl | 0;
                                      break;

                                    case 1:
                                      const $var321 = synAttr.Target != null ? getValue(synAttr.Target).idText === "constructor" ? [0, getValue(synAttr.Target)] : [1] : [1];

                                      switch ($var321[0]) {
                                        case 0:
                                          directedTgts = 32;
                                          break;

                                        case 1:
                                          const $var322 = synAttr.Target != null ? getValue(synAttr.Target).idText === "event" ? [0, getValue(synAttr.Target)] : [1] : [1];

                                          switch ($var322[0]) {
                                            case 0:
                                              directedTgts = 512;
                                              break;

                                            case 1:
                                              if (synAttr.Target != null) {
                                                errorR(new _Error(SR.tcUnrecognizedAttributeTarget(), getValue(synAttr.Target).idRange));
                                                directedTgts = possibleTgts | 0;
                                              } else {
                                                directedTgts = possibleTgts | 0;
                                              }

                                              break;
                                          }

                                          break;
                                      }

                                      break;
                                  }

                                  break;
                              }

                              break;
                          }

                          break;
                      }

                      break;
                  }

                  break;
              }

              break;
          }

          break;
      }

      const constrainedTgts = possibleTgts & directedTgts | 0;

      if (constrainedTgts === 0) {
        if (directedTgts === 1 ? true : directedTgts === 2) {
          error_1(new _Error(SR.tcAttributeIsNotValidForLanguageElementUseDo(), synAttr.Range));
        } else {
          error_1(new _Error(SR.tcAttributeIsNotValidForLanguageElement(), synAttr.Range));
        }
      }

      const matchValue_4 = ResolveObjectConstructor(cenv_1.nameResolver, env.DisplayEnv, synAttr.Range, env.eAccessRights, patternInput_1[0]);
      const $var323 = matchValue_4.tag === 1 ? canFail ? [0] : [1] : [1];

      switch ($var323[0]) {
        case 0:
          return [new List(), true];

        case 1:
          const item = ResultOrExceptionModule.ForceRaise(matchValue_4);
          let attrib;

          if (item.tag === 11) {
            const meths = map_1(function (minfo) {
              return [minfo, null];
            }, item.data[1]);
            const afterResolution = ForNewConstructors(cenv_1.tcSink, env, patternInput[1].idRange, item.data[0], item.data[1]);
            const patternInput_3 = TcMethodApplication(true, cenv_1, env, patternInput_1[1], null, new List(), synAttr.Range, synAttr.Range, item.data[0], null, env.eAccessRights, new Mutates(1), false, meths, afterResolution, new ValUseFlag(1), ofArray([synAttr.ArgExpr]), NewInferenceType(), new List());
            const expr = patternInput_3[0][0];
            const attributeAssignedNamedItems = patternInput_3[0][1];
            UnifyTypes(cenv_1, env, synAttr.Range, patternInput_1[0], tyOfExpr(cenv_1.g, expr));

            const mkAttribExpr = function (e) {
              return new AttribExpr(0, [e, EvalLiteralExprOrAttribArg(cenv_1.g, e)]);
            };

            const namedAttribArgMap = map_1(function (_arg71) {
              const m = _arg71.data[1].data[1];
              const isOpt = _arg71.data[1].data[2];
              const callerArgExpr = _arg71.data[1].data[3];
              const argtyv = _arg71.data[1].data[0];

              if (isOpt) {
                error_1(new _Error(SR.tcOptionalArgumentsCannotBeUsedInCustomAttribute(), m));
              }

              const m_1 = Expr_get_Range.bind(callerArgExpr)();
              const patternInput_4 = ResolveLongIdentInType(cenv_1.tcSink, cenv_1.nameResolver, env.NameEnv, new LookupKind(2), m_1, env.eAccessRights, _arg71.data[0], new FindMemberFlag(0), TypeNameResolutionInfo.Default, patternInput_1[0]);
              let patternInput_5;
              const $var324 = patternInput_4[0].tag === 9 ? patternInput_4[0].data[1].tail != null ? patternInput_4[0].data[1].tail.tail == null ? [0, patternInput_4[0].data[1].head] : [3] : [3] : patternInput_4[0].tag === 7 ? [1, patternInput_4[0].data] : patternInput_4[0].tag === 5 ? !patternInput_4[0].data.IsStatic ? [2, patternInput_4[0].data] : [3] : [3];

              switch ($var324[0]) {
                case 0:
                  if (!$var324[1].HasSetter) {
                    errorR(new _Error(SR.tcPropertyCannotBeSet0(), m_1));
                  }

                  patternInput_5 = [_arg71.data[0].idText, true, $var324[1].GetPropertyType(cenv_1.amap, m_1)];
                  break;

                case 1:
                  CheckILFieldInfoAccessible(cenv_1.g, cenv_1.amap, m_1, env.eAccessRights, $var324[1]);
                  CheckILFieldAttributes(cenv_1.g, $var324[1], m_1);
                  patternInput_5 = [_arg71.data[0].idText, false, $var324[1].FieldType(cenv_1.amap, m_1)];
                  break;

                case 2:
                  CommitOperationResult(CheckRecdFieldInfoAttributes(cenv_1.g, $var324[1], m_1));
                  CheckRecdFieldInfoAccessible(cenv_1.amap, m_1, env.eAccessRights, $var324[1]);
                  const nm = ComputeFieldName($var324[1].Tycon, $var324[1].RecdField);
                  patternInput_5 = [nm, false, $var324[1].FieldType];
                  break;

                case 3:
                  errorR(new _Error(SR.tcPropertyOrFieldNotFoundInAttribute(), m_1));
                  patternInput_5 = [_arg71.data[0].idText, false, cenv_1.g.unit_ty];
                  break;
              }

              const propNameItem = new Item(21, [_arg71.data[0], patternInput_4[0]]);
              CallNameResolutionSink(cenv_1.tcSink, _arg71.data[0].idRange, env.NameEnv, propNameItem, propNameItem, emptyTyparInst, new ItemOccurence(1), env.DisplayEnv, env.eAccessRights);
              AddCxTypeMustSubsumeType(new ContextInfo(0), env.DisplayEnv, cenv_1.css, m_1, new OptionalTrace(0), patternInput_5[2], argtyv);
              return new AttribNamedArg(0, [patternInput_5[0], patternInput_5[2], patternInput_5[1], mkAttribExpr(callerArgExpr)]);
            }, attributeAssignedNamedItems);
            let $var325;

            if (expr.tag === 11) {
              if (expr.data[0].tag === 31) {
                if (expr.data[0].data[8].tail == null) {
                  if (expr.data[0].data[9].tail == null) {
                    if (expr.data[1].tail == null) {
                      $var325 = [0, expr.data[0].data[10], expr.data[2], expr.data[0].data[7], expr.data[3], expr.data[0].data[2]];
                    } else {
                      $var325 = [2];
                    }
                  } else {
                    $var325 = [2];
                  }
                } else {
                  $var325 = [2];
                }
              } else {
                $var325 = [2];
              }
            } else if (expr.tag === 5) {
              const activePatternResult42533 = _InnerExprPat_(expr.data[0]);

              const activePatternResult42534 = _ExprValWithPossibleTypeInst___(activePatternResult42533);

              if (activePatternResult42534 != null) {
                $var325 = [1, expr.data[3], getValue(activePatternResult42534)[0]];
              } else {
                $var325 = [2];
              }
            } else {
              $var325 = [2];
            }

            switch ($var325[0]) {
              case 0:
                if ($var325[5]) {
                  error_1(new _Error(SR.tcCustomAttributeMustBeReferenceType(), $var325[4]));
                }

                if ($var325[2].length !== $var325[3].ArgTypes.length) {
                  error_1(new _Error(SR.tcCustomAttributeArgumentMismatch(), $var325[4]));
                }

                const args = function (list) {
                  return map_1(mkAttribExpr, list);
                }($var325[2]);

                attrib = new Attrib(0, [tcref, new AttribKind(0, $var325[3]), args, namedAttribArgMap, synAttr.AppliesToGetterAndSetter, constrainedTgts, $var325[4]]);
                break;

              case 1:
                const args_1 = function (list_1) {
                  return map_1(mkAttribExpr, list_1);
                }(collect(function (_arg26) {
                  const $var326 = _arg26.tag === 0 ? _arg26.data[0].tag === 16 ? [0] : [1, _arg26] : [1, _arg26];

                  switch ($var326[0]) {
                    case 0:
                      return new List();

                    case 1:
                      return tryDestRefTupleExpr($var326[1]);
                  }
                }, $var325[1]));

                attrib = new Attrib(0, [tcref, new AttribKind(1, $var325[2]), args_1, namedAttribArgMap, synAttr.AppliesToGetterAndSetter, constrainedTgts, synAttr.Range]);
                break;

              case 2:
                attrib = error_1(new _Error(SR.tcCustomAttributeMustInvokeConstructor(), synAttr.Range));
                break;
            }
          } else {
            attrib = error_1(new _Error(SR.tcAttributeExpressionsMustBeConstructorCalls(), synAttr.Range));
          }

          return [ofArray([[constrainedTgts, attrib]]), false];
      }

  }
}
export function TcAttributesWithPossibleTargets(canFail, cenv_1, env, attrTgt, synAttribs) {
  return List_1.collectFold(function (didFail, synAttrib) {
    try {
      const patternInput = TcAttribute(canFail, cenv_1, env, attrTgt, synAttrib);
      const attribs = map_1(function (tuple) {
        return tuple[1];
      }, patternInput[0]);

      if ((HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_TypeForwardedToAttribute, attribs) ? true : HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_CompilationArgumentCountsAttribute, attribs)) ? true : HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_CompilationMappingAttribute, attribs)) {
        errorR(new _Error(SR.tcUnsupportedAttribute(), synAttrib.Range));
      }

      return [patternInput[0], didFail ? true : patternInput[1]];
    } catch (e) {
      errorRecovery(e, synAttrib.Range);
      return [new List(), false];
    }
  }, false, synAttribs);
}
export function TcAttributesMaybeFail(canFail, cenv_1, env, attrTgt, synAttribs) {
  const patternInput = TcAttributesWithPossibleTargets(canFail, cenv_1, env, attrTgt, synAttribs);
  return [map_1(function (tuple) {
    return tuple[1];
  }, patternInput[0]), patternInput[1]];
}
export function TcAttributesCanFail(cenv_1, env, attrTgt, synAttribs) {
  const patternInput = TcAttributesMaybeFail(true, cenv_1, env, attrTgt, synAttribs);
  return [patternInput[0], function () {
    return patternInput[1] ? TcAttributes(cenv_1, env, attrTgt, synAttribs) : patternInput[0];
  }];
}
export function TcAttributes(cenv_1, env, attrTgt, synAttribs) {
  return TcAttributesMaybeFail(false, cenv_1, env, attrTgt, synAttribs)[0];
}
export function TcLetBinding(cenv_1, isUse, env, containerInfo, declKind, tpenv, binds, bindsm, scopem) {
  const patternInput = mapFold(function (tpenv_1, b) {
    return TcNonRecursiveBinding(declKind, cenv_1, env, tpenv_1, NewInferenceType(), b);
  }, tpenv, binds, ofArray);
  const denv = env.DisplayEnv;
  GeneralizationHelpers.CanonicalizePartialInferenceProblem(cenv_1, denv, bindsm, collect(function (tbinfo) {
    const maxInferredTypars = freeInTypeLeftToRight(cenv_1.g, false, tbinfo.data[8]);
    return append(tbinfo.data[4].data[1], maxInferredTypars);
  }, patternInput[0]));
  const lazyFreeInEnv = new Lazy(function () {
    return GeneralizationHelpers.ComputeUngeneralizableTypars(env);
  });
  return fold(function (tupledArg, tbinfo_1) {
    var v;
    var generalizedTypars_;
    const enclosingDeclaredTypars = new List();
    const allDeclaredTypars = append(enclosingDeclaredTypars, tbinfo_1.data[4].data[1]);
    let patternInput_1;
    const canInferTypars = GeneralizationHelpers.ComputeCanInferExtraGeneralizableTypars(containerInfo.ParentRef, tbinfo_1.data[4].data[2], null);
    const maxInferredTypars_1 = freeInTypeLeftToRight(cenv_1.g, false, tbinfo_1.data[8]);
    let generalizedTypars;

    if (maxInferredTypars_1.tail == null ? allDeclaredTypars.tail == null : false) {
      generalizedTypars = new List();
    } else {
      const freeInEnv = lazyFreeInEnv.value;
      generalizedTypars = GeneralizationHelpers.ComputeAndGeneralizeGenericTypars(cenv_1, denv, tbinfo_1.data[9], freeInEnv, canInferTypars, GeneralizationHelpers.CanGeneralizeConstrainedTyparsForDecl(declKind), tbinfo_1.data[0], tbinfo_1.data[6], allDeclaredTypars, maxInferredTypars_1, tbinfo_1.data[8], false);
    }

    const prelimValSchemes2 = GeneralizeVals(cenv_1, denv, enclosingDeclaredTypars, generalizedTypars, tbinfo_1.data[5]);
    patternInput_1 = [generalizedTypars, prelimValSchemes2];
    const tpenv_2 = HideUnscopedTypars(patternInput_1[0], tupledArg[2]);
    const valSchemes = NameMapModule.map(function (prelimScheme) {
      return UseCombinedArity(cenv_1.g, declKind, tbinfo_1.data[6], prelimScheme);
    }, patternInput_1[1]);
    const values = MakeAndPublishVals(cenv_1, tupledArg[1], containerInfo.data[0], false, declKind, new ValRecursiveScopeInfo(1), valSchemes, tbinfo_1.data[1], tbinfo_1.data[2], tbinfo_1.data[12]);
    const pat_ = tbinfo_1.data[3](new TcPatPhase2Input(0, [values, true]));
    const prelimRecValues = NameMapModule.map(function (tuple) {
      return tuple[0];
    }, values);
    const rhsExpr = mkTypeLambda(tbinfo_1.data[9], patternInput_1[0], tbinfo_1.data[6], tbinfo_1.data[8]);
    const $var328 = pat_.tag === 1 ? ((!isUse ? !tbinfo_1.data[13] : false) ? patternInput_1[0].tail == null : false) ? [0] : [1] : pat_.tag === 0 ? pat_.data[0].tag === 16 ? ((!isUse ? !tbinfo_1.data[13] : false) ? patternInput_1[0].tail == null : false) ? [0] : [1] : [1] : [1];

    switch ($var328[0]) {
      case 0:
        const mk_seq_bind = function (tupledArg_1) {
          return [mkSequential(new SequencePointInfoForSeq(0), tbinfo_1.data[9], rhsExpr, tupledArg_1[0]), tupledArg_1[1]];
        };

        return [$var329 => mk_seq_bind(tupledArg[0]($var329)), tupledArg[1], tpenv_2];

      case 1:
        let patternInput_3;
        const $var330 = pat_.tag === 2 ? (v = pat_.data[1].data[0], generalizedTypars_ = pat_.data[1].data[1].data[0], List_1.lengthsEqAndForall2(function (tp1, tp2) {
          return typarRefEq(tp1, tp2);
        }, patternInput_1[0], generalizedTypars_)) ? [0, pat_.data[1].data[1].data[0], pat_.data[0], pat_.data[1].data[0]] : [1] : [1];

        switch ($var330[0]) {
          case 0:
            patternInput_3 = [$var330[3], $var330[2]];
            break;

          case 1:
            if (tbinfo_1.data[0].MustInline) {
              patternInput_3 = error_1(new _Error(SR.tcInvalidInlineSpecification(), tbinfo_1.data[9]));
            } else {
              const patternInput_2 = mkCompGenLocal(tbinfo_1.data[9], "patternInput", op_PlusMinusGreater(patternInput_1[0], tbinfo_1.data[8]));

              if (isUse ? true : tbinfo_1.data[13]) {
                errorR(new _Error(SR.tcInvalidUseBinding(), tbinfo_1.data[9]));
              }

              if (DeclKind.MustHaveArity(declKind)) {
                AdjustValToTopVal(patternInput_2[0], containerInfo.data[0], InferArityOfExprBinding(cenv_1.g, new AllowTypeDirectedDetupling(0), patternInput_2[0], rhsExpr));
              }

              patternInput_3 = [patternInput_2[0], pat_];
            }

            break;
        }

        const mkRhsBind = function (tupledArg_2) {
          const letExpr = mkLet(tbinfo_1.data[10], tbinfo_1.data[9], patternInput_3[0], rhsExpr, tupledArg_2[0]);
          return [letExpr, tupledArg_2[1]];
        };

        const allValsDefinedByPattern = NameMapModule.range(prelimRecValues);

        const mkPatBind = function (tupledArg_3) {
          const valsDefinedByMatching = ListSet.remove(function (lv1, lv2) {
            return valEq(lv1, lv2);
          }, patternInput_3[0], allValsDefinedByPattern);
          const matchx = CompilePatternForMatch(cenv_1, tupledArg[1], tbinfo_1.data[9], tbinfo_1.data[9], true, new ActionOnFailure(0), patternInput_3[0], patternInput_1[0], ofArray([new TypedMatchClause(0, [patternInput_3[1], null, new DecisionTreeTarget(0, [valsDefinedByMatching, tupledArg_3[0], new SequencePointInfoForTarget(1)]), tbinfo_1.data[9]])]), tbinfo_1.data[8], tupledArg_3[1]);
          const matchx_1 = DeclKind.ConvertToLinearBindings(declKind) ? LinearizeTopMatch(cenv_1.g, containerInfo.data[0], matchx) : matchx;
          return [matchx_1, tupledArg_3[1]];
        };

        const mkCleanup = function (tupledArg_4) {
          if (isUse ? !tbinfo_1.data[13] : false) {
            return foldBack(function (v_1, tupledArg_5) {
              AddCxTypeMustSubsumeType(new ContextInfo(0), denv, cenv_1.css, v_1.Range, new OptionalTrace(0), cenv_1.g.system_IDisposable_typ, v_1.Type);
              const cleanupE = BuildDisposableCleanup(cenv_1, tupledArg[1], tbinfo_1.data[9], v_1);
              return [mkTryFinally(cenv_1.g, tupledArg_5[0], cleanupE, tbinfo_1.data[9], tupledArg_5[1], new SequencePointInfoForTry(1), new SequencePointInfoForFinally(1)), tupledArg_5[1]];
            }, allValsDefinedByPattern, [tupledArg_4[0], tupledArg_4[1]]);
          } else {
            return [tupledArg_4[0], tupledArg_4[1]];
          }
        };

        return [$var333 => mkRhsBind(($var332 => mkPatBind(($var331 => mkCleanup(tupledArg[0]($var331)))($var332)))($var333)), AddLocalValMap(cenv_1.tcSink, scopem, prelimRecValues, tupledArg[1]), tpenv_2];
    }
  }, [function (x) {
    return x;
  }, env, patternInput[1]], patternInput[0]);
}
export function TcLetBindings(cenv_1, env, containerInfo, declKind, tpenv, binds, bindsm, scopem) {
  const patternInput = TcLetBinding(cenv_1, false, env, containerInfo, declKind, tpenv, binds, bindsm, scopem);
  const unite = mkUnit(cenv_1.g, bindsm);
  const patternInput_1 = patternInput[0]([unite, cenv_1.g.unit_ty]);

  const stripLets = function (acc, _arg27) {
    stripLets: while (true) {
      const $var334 = _arg27.tag === 7 ? [0, _arg27.data[0], _arg27.data[1], _arg27.data[2]] : _arg27.tag === 2 ? _arg27.data[2].tag === 0 ? [1, _arg27.data[0], _arg27.data[1], _arg27.data[4]] : [3] : _arg27.tag === 0 ? _arg27.data[0].tag === 16 ? [2] : [3] : [3];

      switch ($var334[0]) {
        case 0:
          acc = new List(new ModuleOrNamespaceExpr(2, [$var334[1], $var334[3]]), acc);
          _arg27 = $var334[2];
          continue stripLets;

        case 1:
          acc = new List(new ModuleOrNamespaceExpr(3, [$var334[1], $var334[3]]), acc);
          _arg27 = $var334[2];
          continue stripLets;

        case 2:
          return reverse(acc);

        case 3:
          throw new Error("TcLetBindings: let sequence is non linear. Maybe a LHS pattern was not linearised?");
      }
    }
  };

  const binds_1 = stripLets(new List(), patternInput_1[0]);
  return [binds_1, patternInput[1], patternInput[2]];
}
export function CheckMemberFlags(optIntfSlotTy, newslotsOK, overridesOK, memberFlags, m) {
  if (newslotsOK.Equals(new NewSlotsOK(1)) ? memberFlags.IsDispatchSlot : false) {
    errorR(new _Error(SR.tcAbstractMembersIllegalInAugmentation(), m));
  }

  if (overridesOK.Equals(new OverridesOK(2)) ? memberFlags.MemberKind.Equals(new MemberKind_2(1)) : false) {
    errorR(new _Error(SR.tcConstructorsIllegalInAugmentation(), m));
  }

  if ((overridesOK.Equals(new OverridesOK(1)) ? memberFlags.IsOverrideOrExplicitImpl : false) ? optIntfSlotTy == null : false) {
    warning(new OverrideInIntrinsicAugmentation(m));
  }

  if (overridesOK.Equals(new OverridesOK(2)) ? memberFlags.IsOverrideOrExplicitImpl : false) {
    error_1(new _Error(SR.tcMethodOverridesIllegalHere(), m));
  }
}
export function ApplyTypesFromArgumentPatterns(cenv_1, env, optArgsOK, ty, m, tpenv, _arg11, memberFlagsOpt) {
  if (_arg11.data[0].tail != null) {
    const patternInput = UnifyFunctionType(null, cenv_1, env.DisplayEnv, m, ty);
    TcSimplePats(cenv_1, optArgsOK, new CheckConstraints(0), patternInput[0], env, tpenv, create(null, new Comparer(comparePrimitives)), create_1(null, new Comparer(comparePrimitives)), _arg11.data[0].head);
    ApplyTypesFromArgumentPatterns(cenv_1, env, optArgsOK, patternInput[1], m, tpenv, new NormalizedBindingRhs(0, [_arg11.data[0].tail, _arg11.data[1], _arg11.data[2]]), memberFlagsOpt);
  } else {
    if (_arg11.data[1] != null) {
      const retInfoTy = getValue(_arg11.data[1]).data[0];
      const m_1 = getValue(_arg11.data[1]).data[1];
      const patternInput_1 = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, retInfoTy);
      UnifyTypes(cenv_1, env, m_1, ty, patternInput_1[0]);
    }

    const $var335 = memberFlagsOpt != null ? getValue(memberFlagsOpt).MemberKind.Equals(new MemberKind_2(4)) ? [0, getValue(memberFlagsOpt)] : [1] : [1];

    switch ($var335[0]) {
      case 0:
        UnifyTypes(cenv_1, env, m, ty, cenv_1.g.unit_ty);
        break;

      case 1:
        break;
    }
  }
}
export function ComputeIsComplete(enclosingDeclaredTypars, declaredTypars, ty) {
  return ZsetModule.isEmpty(fold(function (acc, v) {
    return ZsetModule.remove(v, acc);
  }, freeInType_1(CollectAllNoCaching, ty).FreeTypars, append(enclosingDeclaredTypars, declaredTypars)));
}
export function ApplyAbstractSlotInference(cenv_1, envinner, bindingTy, m, synTyparDecls, declaredTypars, memberId, tcrefObjTy, renaming, _objTy, optIntfSlotTy, valSynData, memberFlags, attribs) {
  var denv;
  let typToSearchForAbstractMembers;

  if (optIntfSlotTy == null) {
    typToSearchForAbstractMembers = [tcrefObjTy, null];
  } else {
    const ty = getValue(optIntfSlotTy)[0];
    const abstractSlots = getValue(optIntfSlotTy)[1];
    typToSearchForAbstractMembers = [ty, abstractSlots];
  }

  if (memberFlags.IsOverrideOrExplicitImpl) {
    const makeUniqueBySig = function (meths) {
      var erasureFlag;
      return ListSet.setify((erasureFlag = new Erasure(2), function (minfo, minfo2) {
        return MethInfosEquivByNameAndSig(erasureFlag, false, cenv_1.g, cenv_1.amap, m, minfo, minfo2);
      }), meths);
    };

    const $var336 = memberFlags.MemberKind.tag === 2 ? [0] : memberFlags.MemberKind.tag === 3 ? [1, memberFlags.MemberKind] : memberFlags.MemberKind.tag === 4 ? [1, memberFlags.MemberKind] : [2];

    switch ($var336[0]) {
      case 0:
        const patternInput = GetAbstractMethInfosForSynMethodDecl(cenv_1.infoReader, envinner.eAccessRights, memberId, m, typToSearchForAbstractMembers, valSynData);
        let uniqueAbstractMethSigs;

        if (patternInput[0].tail == null) {
          errorR(new _Error(SR.tcNoMemberFoundForOverride(), memberId.idRange));
          uniqueAbstractMethSigs = new List();
        } else if ((() => {
          const $var337 = makeUniqueBySig(patternInput[1]);
          const $var338 = $var337.tail != null ? $var337.tail.tail == null ? [0] : [1] : [1];

          switch ($var338[0]) {
            case 0:
              return true;

            case 1:
              return false;
          }
        })()) {
          uniqueAbstractMethSigs = patternInput[1];
        } else if (patternInput[1].tail == null) {
          const details = join("", map_2(CurriedLambda(toText(printf("%s   %s")))("\n"), map_1((denv = envinner.DisplayEnv, function (d) {
            return stringOfMethInfo(cenv_1.amap, m, denv, d);
          }), patternInput[0])));
          errorR(new _Error(SR.tcOverrideArityMismatch(details), memberId.idRange));
          uniqueAbstractMethSigs = new List();
        } else {
          uniqueAbstractMethSigs = new List();
        }

        let declaredTypars_2;

        if (uniqueAbstractMethSigs.tail != null) {
          const uniqueAbstractMeth = uniqueAbstractMethSigs.head.Instantiate(cenv_1.amap, m, renaming);
          const patternInput_1 = FreshenAbstractSlot(cenv_1.g, cenv_1.amap, m, synTyparDecls, uniqueAbstractMeth);
          const declaredTypars_1 = patternInput_1[0] ? patternInput_1[1] : declaredTypars;
          const absSlotTy = mkMethodTy(cenv_1.g, patternInput_1[2], patternInput_1[3]);
          UnifyTypes(cenv_1, envinner, m, bindingTy, absSlotTy);
          declaredTypars_2 = declaredTypars_1;
        } else {
          declaredTypars_2 = declaredTypars;
        }

        let optInferredImplSlotTys;

        if (optIntfSlotTy == null) {
          optInferredImplSlotTys = map_1(function (x) {
            return x.ApparentEnclosingType;
          }, uniqueAbstractMethSigs);
        } else {
          const x_1 = getValue(optIntfSlotTy)[0];
          optInferredImplSlotTys = ofArray([x_1]);
        }

        return [optInferredImplSlotTys, declaredTypars_2];

      case 1:
        const dispatchSlots = GetAbstractPropInfosForSynPropertyDecl(cenv_1.infoReader, envinner.eAccessRights, memberId, m, typToSearchForAbstractMembers, $var336[1], valSynData);
        const dispatchSlots_1 = filter(function (pinfo) {
          return (pinfo.HasGetter ? $var336[1].Equals(new MemberKind_2(3)) : false) ? true : pinfo.HasSetter ? $var336[1].Equals(new MemberKind_2(4)) : false;
        }, dispatchSlots);
        let uniqueAbstractPropSigs;
        const $var339 = dispatchSlots_1.tail == null ? !CompileAsEvent(cenv_1.g, attribs) ? [0] : [1] : [1];

        switch ($var339[0]) {
          case 0:
            errorR(new _Error(SR.tcNoPropertyFoundForOverride(), memberId.idRange));
            uniqueAbstractPropSigs = new List();
            break;

          case 1:
            const $var340 = dispatchSlots_1.tail != null ? dispatchSlots_1.tail.tail == null ? [0, dispatchSlots_1.head] : [1] : [1];

            switch ($var340[0]) {
              case 0:
                uniqueAbstractPropSigs = ofArray([$var340[1]]);
                break;

              case 1:
                uniqueAbstractPropSigs = new List();
                break;
            }

            break;
        }

        iterate(function (uniqueAbstractProp) {
          const kIsGet = $var336[1].Equals(new MemberKind_2(3));

          if (!(kIsGet ? uniqueAbstractProp.HasGetter : uniqueAbstractProp.HasSetter)) {
            error_1(new _Error(SR.tcAbstractPropertyMissingGetOrSet(kIsGet ? "getter" : "setter"), memberId.idRange));
          }

          const uniqueAbstractMeth_1 = kIsGet ? uniqueAbstractProp.GetterMethod : uniqueAbstractProp.SetterMethod;
          const uniqueAbstractMeth_2 = uniqueAbstractMeth_1.Instantiate(cenv_1.amap, m, renaming);
          const patternInput_2 = FreshenAbstractSlot(cenv_1.g, cenv_1.amap, m, synTyparDecls, uniqueAbstractMeth_2);

          if (!(patternInput_2[1].tail == null)) {
            errorR(new InternalError("Unexpected generic property", memberId.idRange));
          }

          let absSlotTy_1;

          if (memberFlags.MemberKind.Equals(new MemberKind_2(3))) {
            absSlotTy_1 = mkMethodTy(cenv_1.g, patternInput_2[2], patternInput_2[3]);
          } else {
            const $var341 = patternInput_2[2].tail != null ? patternInput_2[2].tail.tail == null ? [0, patternInput_2[2].head] : [1] : [1];

            switch ($var341[0]) {
              case 0:
                absSlotTy_1 = op_MinusMinusGreater(mkRefTupledTy(cenv_1.g, $var341[1]), cenv_1.g.unit_ty);
                break;

              case 1:
                error_1(new _Error(SR.tcInvalidSignatureForSet(), memberId.idRange));
                absSlotTy_1 = op_MinusMinusGreater(patternInput_2[3], cenv_1.g.unit_ty);
                break;
            }
          }

          UnifyTypes(cenv_1, envinner, m, bindingTy, absSlotTy_1);
        }, uniqueAbstractPropSigs);
        let optInferredImplSlotTys_1;

        if (optIntfSlotTy == null) {
          optInferredImplSlotTys_1 = map_1(function (pinfo_1) {
            return pinfo_1.ApparentEnclosingType;
          }, uniqueAbstractPropSigs);
        } else {
          const x_2 = getValue(optIntfSlotTy)[0];
          optInferredImplSlotTys_1 = ofArray([x_2]);
        }

        return [optInferredImplSlotTys_1, declaredTypars];

      case 2:
        if (optIntfSlotTy == null) {
          return [new List(), declaredTypars];
        } else {
          const x_3 = getValue(optIntfSlotTy)[0];
          return [ofArray([x_3]), declaredTypars];
        }

    }
  } else {
    return [new List(), declaredTypars];
  }
}
export function CheckForNonAbstractInterface(declKind, tcref, memberFlags, m) {
  if (isInterfaceTyconRef(tcref)) {
    if (memberFlags.MemberKind.Equals(new MemberKind_2(0))) {
      error_1(new _Error(SR.tcStaticInitializersIllegalInInterface(), m));
    } else if (memberFlags.MemberKind.Equals(new MemberKind_2(1))) {
      error_1(new _Error(SR.tcObjectConstructorsIllegalInInterface(), m));
    } else if (memberFlags.IsOverrideOrExplicitImpl) {
      error_1(new _Error(SR.tcMemberOverridesIllegalInInterface(), m));
    } else if (!(declKind.Equals(new DeclKind(2)) ? true : memberFlags.IsDispatchSlot)) {
      error_1(new _Error(SR.tcConcreteMembersIllegalInInterface(), m));
    }
  }
}
export function AnalyzeRecursiveStaticMemberOrValDecl(cenv_1, envinner, tpenv, declKind, newslotsOK, overridesOK, tcrefContainerInfo, vis1, id, vis2, declaredTypars, memberFlagsOpt, thisIdOpt, bindingAttribs, valSynInfo, ty, bindingRhs, mBinding, flex) {
  const vis = CombineVisibilityAttribs(vis1, vis2, mBinding);
  const matchValue = [tcrefContainerInfo, memberFlagsOpt];
  const $var342 = matchValue[0] != null ? matchValue[1] != null ? [0, getValue(matchValue[0]).data[3], getValue(matchValue[0]).data[2], getValue(matchValue[0]).data[4], getValue(matchValue[1]), getValue(matchValue[0]).data[1], getValue(matchValue[0]).data[0]] : [1] : [1];

  switch ($var342[0]) {
    case 0:
      CheckMemberFlags(null, newslotsOK, overridesOK, $var342[4], id.idRange);
      CheckForNonAbstractInterface(declKind, $var342[6], $var342[4], id.idRange);

      if ($var342[4].MemberKind.Equals(new MemberKind_2(1)) ? $var342[6].Deref.IsExceptionDecl : false) {
        error_1(new _Error(SR.tcConstructorsDisallowedInExceptionAugmentation(), id.idRange));
      }

      const isExtrinsic = declKind.Equals(new DeclKind(2));
      const patternInput = FreshenObjectArgType(cenv_1, mBinding, new TyparRigidity(1), $var342[6], isExtrinsic, $var342[3]);
      const envinner_1 = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), patternInput[1], envinner);
      const envinner_2 = MakeInnerEnvForTyconRef(cenv_1, envinner_1, $var342[6], isExtrinsic);
      let patternInput_1;

      if ($var342[4].MemberKind.tag === 1) {
        if ($var342[6].IsStructOrEnumTycon ? (() => {
          const $var343 = valSynInfo.data[0].tail != null ? valSynInfo.data[0].head.tail == null ? valSynInfo.data[0].tail.tail == null ? [0] : [1] : [1] : [1];

          switch ($var343[0]) {
            case 0:
              return true;

            case 1:
              return false;
          }
        })() : false) {
          errorR(new _Error(SR.tcStructsCannotHaveConstructorWithNoArguments(), mBinding));
        }

        if (!$var342[6].IsFSharpObjectModelTycon) {
          errorR(new _Error(SR.tcConstructorsIllegalForThisType(), id.idRange));
        }

        const safeThisValOpt = MakeAndPublishSafeThisVal(cenv_1, envinner_2, thisIdOpt, patternInput[4]);
        let baseValOpt;
        const matchValue_1 = GetSuperTypeOfType(cenv_1.g, cenv_1.amap, mBinding, patternInput[3]);

        if (matchValue_1 == null) {
          baseValOpt = null;
        } else {
          baseValOpt = MakeAndPublishBaseVal(cenv_1, envinner_2, $var342[2] != null ? getValue($var342[2]).Id : null, getValue(matchValue_1));
        }

        const domainTy = NewInferenceType();
        UnifyTypes(cenv_1, envinner_2, mBinding, ty, op_MinusMinusGreater(domainTy, patternInput[3]));
        patternInput_1 = [safeThisValOpt, baseValOpt];
      } else {
        patternInput_1 = [null, null];
      }

      let memberInfo;
      const isExtrinsic_1 = declKind.Equals(new DeclKind(2));
      memberInfo = MakeMemberDataAndMangledNameForMemberVal(cenv_1.g, $var342[6], isExtrinsic_1, bindingAttribs, new List(), $var342[4], valSynInfo, id, false);
      return [envinner_2, tpenv, id, null, memberInfo, vis, vis2, patternInput_1[0], patternInput[1], patternInput_1[1], flex, bindingRhs, declaredTypars];

    case 1:
      return [envinner, tpenv, id, null, null, vis, vis2, null, new List(), null, flex, bindingRhs, declaredTypars];
  }
}
export function AnalyzeRecursiveInstanceMemberDecl(cenv_1, envinner, tpenv, declKind, synTyparDecls, valSynInfo, flex, newslotsOK, overridesOK, vis1, thisId, memberId, toolId, bindingAttribs, vis2, tcrefContainerInfo, memberFlagsOpt, ty, bindingRhs, mBinding) {
  const vis = CombineVisibilityAttribs(vis1, vis2, mBinding);
  const matchValue = [tcrefContainerInfo, memberFlagsOpt];
  const $var344 = matchValue[0] != null ? matchValue[1] != null ? [0, getValue(matchValue[0]).data[3], getValue(matchValue[0]).data[2], getValue(matchValue[0]).data[4], getValue(matchValue[1]), getValue(matchValue[0]).data[1], getValue(matchValue[0]).data[0]] : [1] : [1];

  switch ($var344[0]) {
    case 0:
      CheckMemberFlags($var344[5], newslotsOK, overridesOK, $var344[4], mBinding);

      if (vis != null ? $var344[4].IsOverrideOrExplicitImpl : false) {
        errorR(new _Error(SR.tcOverridesCannotHaveVisibilityDeclarations(), memberId.idRange));
      }

      const bindingRhs_1 = PushOnePatternToRhs(cenv_1, true, mkSynThisPatVar(thisId), bindingRhs);
      const isExtrinsic = declKind.Equals(new DeclKind(2));
      const patternInput = FreshenObjectArgType(cenv_1, mBinding, new TyparRigidity(1), $var344[6], isExtrinsic, $var344[3]);
      const envinner_1 = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), patternInput[1], envinner);
      const envinner_2 = MakeInnerEnvForTyconRef(cenv_1, envinner_1, $var344[6], isExtrinsic);
      const baseValOpt = $var344[6].IsFSharpObjectModelTycon ? $var344[2] : null;
      const bindingTy = NewInferenceType();
      UnifyTypes(cenv_1, envinner_2, mBinding, ty, op_MinusMinusGreater(patternInput[4], bindingTy));
      CheckForNonAbstractInterface(declKind, $var344[6], $var344[4], memberId.idRange);
      const patternInput_1 = ApplyAbstractSlotInference(cenv_1, envinner_2, bindingTy, mBinding, synTyparDecls, flex.data[1], memberId, patternInput[0], patternInput[2], patternInput[3], $var344[5], valSynInfo, $var344[4], bindingAttribs);
      const flex_1 = new ExplicitTyparInfo(0, [patternInput_1[1], patternInput_1[1], flex.data[2]]);
      let baseValOpt_1;
      const matchValue_1 = GetSuperTypeOfType(cenv_1.g, cenv_1.amap, mBinding, patternInput[3]);

      if (matchValue_1 == null) {
        baseValOpt_1 = null;
      } else {
        baseValOpt_1 = MakeAndPublishBaseVal(cenv_1, envinner_2, baseValOpt != null ? getValue(baseValOpt).Id : null, getValue(matchValue_1));
      }

      const memberInfo = MakeMemberDataAndMangledNameForMemberVal(cenv_1.g, $var344[6], isExtrinsic, bindingAttribs, patternInput_1[0], $var344[4], valSynInfo, memberId, false);
      return [envinner_2, tpenv, memberId, toolId, memberInfo, vis, vis2, null, patternInput[1], baseValOpt_1, flex_1, bindingRhs_1, patternInput_1[1]];

    case 1:
      return error_1(new _Error(SR.tcRecursiveBindingsWithMembersMustBeDirectAugmentation(), mBinding));
  }
}
export function AnalyzeRecursiveDecl(cenv_1, envinner, tpenv, declKind, synTyparDecls, declaredTypars, thisIdOpt, valSynInfo, flex, newslotsOK, overridesOK, vis1, declPattern, bindingAttribs, tcrefContainerInfo, memberFlagsOpt, ty, bindingRhs, mBinding) {
  const analyzeRecursiveDeclPat = function (tpenv_1, p) {
    analyzeRecursiveDeclPat: while (true) {
      const $var345 = p.tag === 19 ? [0, p.data[0]] : p.tag === 3 ? [1, p.data[1], p.data[0]] : p.tag === 4 ? [2, p.data[1], p.data[0], p.data[2]] : p.tag === 0 ? p.data[0].tag === 0 ? [3, p.data[1]] : [6] : p.tag === 1 ? [3, p.data] : p.tag === 2 ? p.data[0].tag === 1 ? [4, p.data[1], p.data[3]] : [6] : p.tag === 18 ? [5, p.data[1], p.data[0], p.data[2], p.data[3]] : [6];

      switch ($var345[0]) {
        case 0:
          tpenv_1 = tpenv_1;
          p = $var345[1];
          continue analyzeRecursiveDeclPat;

        case 1:
          const patternInput = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(1), new CheckConstraints(0), new ItemOccurence(2), envinner, tpenv_1, $var345[1]);
          UnifyTypes(cenv_1, envinner, mBinding, ty, patternInput[0]);
          tpenv_1 = patternInput[1];
          p = $var345[2];
          continue analyzeRecursiveDeclPat;

        case 2:
          return error_1(new _Error(SR.tcAttributesInvalidInPatterns(), $var345[3]));

        case 3:
          const id = ident(cenv_1.niceNameGen.FreshCompilerGeneratedName("doval", $var345[1]), $var345[1]);
          tpenv_1 = tpenv_1;
          p = new SynPat(2, [new SynPat(1, $var345[1]), id, false, null, $var345[1]]);
          continue analyzeRecursiveDeclPat;

        case 4:
          return AnalyzeRecursiveStaticMemberOrValDecl(cenv_1, envinner, tpenv_1, declKind, newslotsOK, overridesOK, tcrefContainerInfo, vis1, $var345[1], $var345[2], declaredTypars, memberFlagsOpt, thisIdOpt, bindingAttribs, valSynInfo, ty, bindingRhs, mBinding, flex);

        case 5:
          return AnalyzeRecursiveInstanceMemberDecl(cenv_1, envinner, tpenv_1, declKind, synTyparDecls, valSynInfo, flex, newslotsOK, overridesOK, vis1, $var345[2], $var345[1], $var345[3], bindingAttribs, $var345[4], tcrefContainerInfo, memberFlagsOpt, ty, bindingRhs, mBinding);

        case 6:
          return error_1(new _Error(SR.tcOnlySimplePatternsInLetRec(), mBinding));
      }
    }
  };

  return analyzeRecursiveDeclPat(tpenv, declPattern);
}
export function AnalyzeAndMakeAndPublishRecursiveValue(overridesOK, isGeneratedEventVal, cenv_1, env, tpenv, recBindIdx, _arg12) {
  var copyOfStruct;

  const attrTgt = function (arg00, arg10) {
    return DeclKind.AllowedAttribTargets(arg00, arg10);
  }(_arg12.data[3].data[7].data[0], _arg12.data[2]) | 0;

  const bindingAttribs = TcAttributes(cenv_1, env, attrTgt, _arg12.data[3].data[4]);
  const ty = NewInferenceType();
  const inlineFlag = ComputeInlineFlag(_arg12.data[3].data[7].data[0], _arg12.data[3].data[2], _arg12.data[3].data[3], _arg12.data[3].data[10]);

  if (_arg12.data[3].data[3]) {
    errorR(new _Error(SR.tcOnlyRecordFieldsAndSimpleLetCanBeMutable(), _arg12.data[3].data[10]));
  }

  const patternInput = TcBindingTyparDecls(false, cenv_1, env, tpenv, _arg12.data[3].data[6]);
  const envinner = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), patternInput[0].data[1], env);
  const patternInput_1 = AnalyzeRecursiveDecl(cenv_1, envinner, patternInput[1], _arg12.data[2], _arg12.data[3].data[6], patternInput[0].data[1], _arg12.data[3].data[7].data[2], _arg12.data[3].data[7].data[1], patternInput[0], _arg12.data[1], overridesOK, _arg12.data[3].data[0], _arg12.data[3].data[8], bindingAttribs, _arg12.data[0].data[1], _arg12.data[3].data[7].data[0], ty, _arg12.data[3].data[9], _arg12.data[3].data[10]);
  const optArgsOK = _arg12.data[3].data[7].data[0] != null;
  ApplyTypesFromArgumentPatterns(cenv_1, patternInput_1[0], optArgsOK, ty, _arg12.data[3].data[10], patternInput_1[1], patternInput_1[11], _arg12.data[3].data[7].data[0]);
  const isComplete = ComputeIsComplete(patternInput_1[8], patternInput_1[12], ty);
  const prelimTyscheme = new TypeScheme(0, [append(patternInput_1[8], patternInput_1[12]), ty]);
  const partialValReprInfo = TranslateTopValSynInfo(_arg12.data[3].data[10], function (attrTgt_1, synAttribs) {
    return TcAttributes(cenv_1, patternInput_1[0], attrTgt_1, synAttribs);
  }, _arg12.data[3].data[7].data[1]);
  const topValInfo = UseSyntacticArity(_arg12.data[2], prelimTyscheme, partialValReprInfo);
  const hasDeclaredTypars = !(patternInput_1[12].tail == null);
  const prelimValScheme = new ValScheme(0, [patternInput_1[2], prelimTyscheme, topValInfo, patternInput_1[4], false, inlineFlag, new ValBaseOrThisInfo(2), patternInput_1[5], false, false, false, hasDeclaredTypars]);
  const patternInput_2 = TcLiteral(cenv_1, ty, env, patternInput_1[1], bindingAttribs, _arg12.data[3].data[9].data[2]);
  let patternInput_5;
  const extraBindings = toList(delay(function () {
    return map_2(function (extraBinding) {
      return new NormalizedRecBindingDefn(0, [_arg12.data[0], _arg12.data[1], _arg12.data[2], extraBinding]);
    }, EventDeclarationNormalization.GenerateExtraBindings(cenv_1, bindingAttribs, _arg12.data[3]));
  }));
  const patternInput_3 = mapFold(function (tupledArg, arg50_) {
    return AnalyzeAndMakeAndPublishRecursiveValue(overridesOK, true, cenv_1, env, tupledArg[0], tupledArg[1], arg50_);
  }, [patternInput_1[1], recBindIdx], extraBindings, ofArray);
  const tpenv_1 = patternInput_3[1][0];
  const recBindIdx_1 = patternInput_3[1][1] | 0;
  const patternInput_4 = unzip(patternInput_3[0]);
  patternInput_5 = [concat(patternInput_4[0]), concat(patternInput_4[1]), tpenv_1, recBindIdx_1];
  const vspec = MakeAndPublishVal(cenv_1, patternInput_1[0], _arg12.data[0].data[0], false, _arg12.data[2], new ValRecursiveScopeInfo(0, isComplete), prelimValScheme, bindingAttribs, _arg12.data[3].data[5], patternInput_2[1], isGeneratedEventVal);
  const $var346 = patternInput_1[3] != null ? (!(copyOfStruct = getValue(patternInput_1[3]).idRange, copyOfStruct.IsSynthetic) ? !equals(getValue(patternInput_1[3]).idRange, patternInput_1[2].idRange) : false) ? [0, getValue(patternInput_1[3])] : [1] : [1];

  switch ($var346[0]) {
    case 0:
      const item = new Item(0, mkLocalValRef(vspec));
      CallNameResolutionSink(cenv_1.tcSink, $var346[1].idRange, env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(6), env.DisplayEnv, env.eAccessRights);
      break;

    case 1:
      break;
  }

  const mangledId = ident(vspec.LogicalName, vspec.Range);
  const revisedBinding = new NormalizedBinding(0, [_arg12.data[3].data[0], _arg12.data[3].data[1], _arg12.data[3].data[2], _arg12.data[3].data[3], _arg12.data[3].data[4], _arg12.data[3].data[5], _arg12.data[3].data[6], _arg12.data[3].data[7], mkSynPatVar(patternInput_1[6], mangledId), patternInput_1[11], _arg12.data[3].data[10], _arg12.data[3].data[11]]);
  let rbinfo;
  let safeInitInfo_1;

  if (_arg12.data[0].data[1] != null) {
    const safeInitInfo = getValue(_arg12.data[0].data[1]).data[3];
    safeInitInfo_1 = safeInitInfo;
  } else {
    safeInitInfo_1 = new SafeInitData(1);
  }

  rbinfo = new RecursiveBindingInfo(0, [patternInput_5[3], _arg12.data[0], patternInput_1[8], inlineFlag, vspec, patternInput_1[10], partialValReprInfo, patternInput_1[4], patternInput_1[9], patternInput_1[7], safeInitInfo_1, patternInput_1[5], ty, _arg12.data[2]]);
  const recBindIdx_2 = patternInput_5[3] + 1 | 0;
  const primaryBinding = new PreCheckingRecursiveBinding(revisedBinding, rbinfo);
  return [[new List(primaryBinding, patternInput_5[0]), new List(vspec, patternInput_5[1])], [patternInput_5[2], recBindIdx_2]];
}
export function AnalyzeAndMakeAndPublishRecursiveValues(overridesOK, cenv_1, env, tpenv, binds) {
  const patternInput = mapFold(function (tupledArg, arg50_) {
    return AnalyzeAndMakeAndPublishRecursiveValue(overridesOK, false, cenv_1, env, tupledArg[0], tupledArg[1], arg50_);
  }, [tpenv, 0], binds, ofArray);
  const patternInput_1 = unzip(patternInput[0]);
  return [concat(patternInput_1[0]), concat(patternInput_1[1]), patternInput[1]];
}
export function TcLetrecBinding(cenv_1, envRec, scopem, extraGeneralizableTypars, reqdThisValTyOpt, envNonRec, generalizedRecBinds, preGeneralizationRecBinds, tpenv, uncheckedRecBindsTable, rbind) {
  const allDeclaredTypars = append(rbind.RecBindingInfo.data[2], rbind.RecBindingInfo.DeclaredTypars);
  const envRec_1 = foldBack(function (v, env) {
    return AddLocalVal(cenv_1.tcSink, scopem, v, env);
  }, defaultArg(rbind.RecBindingInfo.data[8], [], $var347 => [$var347]), envRec);
  const envRec_2 = foldBack(function (v_1, env_1) {
    return AddLocalVal(cenv_1.tcSink, scopem, v_1, env_1);
  }, defaultArg(rbind.RecBindingInfo.data[9], [], $var348 => [$var348]), envRec_1);
  const envRec_3 = MakeInnerEnvForMember(cenv_1, envRec_2, rbind.RecBindingInfo.data[4]);
  const patternInput = TcNormalizedBinding(rbind.RecBindingInfo.data[13], cenv_1, envRec_3, tpenv, rbind.RecBindingInfo.data[12], rbind.RecBindingInfo.data[9], rbind.RecBindingInfo.data[10], rbind.RecBindingInfo.data[2], rbind.RecBindingInfo.data[5], rbind.SyntacticBinding);

  try {
    UnifyTypes(cenv_1, envRec_3, rbind.RecBindingInfo.data[4].Range, op_PlusMinusGreater(allDeclaredTypars, rbind.RecBindingInfo.data[12]), rbind.RecBindingInfo.data[4].Type);
  } catch (e) {
    error_1(new Recursion(envRec_3.DisplayEnv, rbind.RecBindingInfo.data[4].Id, rbind.RecBindingInfo.data[12], rbind.RecBindingInfo.data[4].Type, rbind.RecBindingInfo.data[4].Range));
  }

  if (reqdThisValTyOpt != null) {
    let patternInput_1;
    const matchValue = GetInstanceMemberThisVariable(rbind.RecBindingInfo.data[4], patternInput[0].Expr);

    if (matchValue != null) {
      patternInput_1 = [getValue(reqdThisValTyOpt), getValue(matchValue).Type, getValue(matchValue).Range];
    } else {
      const reqdThisValTy = isByrefTy(cenv_1.g, getValue(reqdThisValTyOpt)) ? destByrefTy(cenv_1.g, getValue(reqdThisValTyOpt)) : getValue(reqdThisValTyOpt);
      const enclosingTyconRef = tcrefOfAppTy(cenv_1.g, reqdThisValTy);
      patternInput_1 = [reqdThisValTy, mkAppTy(enclosingTyconRef, map_1(function (tp) {
        return mkTyparTy(tp);
      }, rbind.RecBindingInfo.data[2])), rbind.RecBindingInfo.data[4].Range];
    }

    if (!AddCxTypeEqualsTypeUndoIfFailed(envRec_3.DisplayEnv, cenv_1.css, patternInput_1[2], patternInput_1[1], patternInput_1[0])) {
      errorR(new _Error(SR.tcNonUniformMemberUse(rbind.RecBindingInfo.data[4].DisplayName), rbind.RecBindingInfo.data[4].Range));
    }
  }

  const preGeneralizationRecBind = new PreGeneralizationRecursiveBinding(extraGeneralizableTypars, patternInput[0], rbind.RecBindingInfo);
  const uncheckedRecBindsTable_1 = remove(rbind.RecBindingInfo.Val.Stamp, uncheckedRecBindsTable);
  const preGeneralizationRecBinds_1 = new List(preGeneralizationRecBind, preGeneralizationRecBinds);
  return TcIncrementalLetRecGeneralization(cenv_1, scopem, envNonRec, generalizedRecBinds, preGeneralizationRecBinds_1, patternInput[1], uncheckedRecBindsTable_1);
}
export function TcIncrementalLetRecGeneralization(cenv_1, scopem, envNonRec, generalizedRecBinds, preGeneralizationRecBinds, tpenv, uncheckedRecBindsTable) {
  var vals;
  const denv = envNonRec.DisplayEnv;
  const freeInEnv = GeneralizationHelpers.ComputeUngeneralizableTypars(envNonRec);
  let patternInput_3;
  const freeInUncheckedRecBinds = new Lazy(function () {
    return fold_1(function (acc, vStamp, _arg72) {
      if (uncheckedRecBindsTable.has(vStamp)) {
        const fwdBind = uncheckedRecBindsTable.get(vStamp);
        return accFreeInType(CollectAllNoCaching, fwdBind.RecBindingInfo.Val.Type, acc);
      } else {
        return acc;
      }
    }, emptyFreeTyvars, cenv_1.recUses.Contents);
  });

  const loop = function (tupledArg) {
    loop: while (true) {
      const frozenBindingTypes = map_1(function (pgrbind) {
        return pgrbind.RecBindingInfo.Val.Type;
      }, tupledArg[1]);
      const freeInFrozenAndLaterBindings = frozenBindingTypes.tail == null ? freeInUncheckedRecBinds : new Lazy(function () {
        return accFreeInTypes(CollectAllNoCaching, frozenBindingTypes, freeInUncheckedRecBinds.value);
      });
      const patternInput = partition(function (pgrbind_1) {
        const freeInBinding = freeInType_1(CollectAllNoCaching, pgrbind_1.RecBindingInfo.Val.TauType).FreeTypars;

        if (freeInBinding.IsEmpty) {
          return true;
        } else {
          const freeInBinding_1 = ZsetModule.diff(freeInBinding, Zset.ofList(typarOrder, NormalizeDeclaredTyparsForEquiRecursiveInference(cenv_1.g, pgrbind_1.ExtraGeneralizableTypars)));

          if (freeInBinding_1.IsEmpty) {
            return true;
          } else {
            const freeInBinding_2 = ZsetModule.diff(freeInBinding_1, Zset.ofList(typarOrder, NormalizeDeclaredTyparsForEquiRecursiveInference(cenv_1.g, pgrbind_1.RecBindingInfo.DeclaredTypars)));

            if (freeInBinding_2.IsEmpty) {
              return true;
            } else {
              const freeInBinding_3 = ZsetModule.diff(freeInBinding_2, freeInEnv);

              if (freeInBinding_3.IsEmpty) {
                return true;
              } else {
                const freeInBinding_4 = ZsetModule.inter(freeInFrozenAndLaterBindings.value.FreeTypars, freeInBinding_3);

                if (freeInBinding_4.IsEmpty) {
                  return true;
                } else {
                  return false;
                }
              }
            }
          }
        }
      }, tupledArg[0]);

      if (patternInput[1].tail == null) {
        return [patternInput[0], tupledArg[1]];
      } else {
        tupledArg = [patternInput[0], append(patternInput[1], tupledArg[1])];
        continue loop;
      }
    }
  };

  const patternInput_1 = loop([preGeneralizationRecBinds, new List()]);
  const freeInEnv_2 = fold(function (freeInEnv_1, pgrbind_2) {
    if (GeneralizationHelpers.IsGeneralizableValue(cenv_1.g, pgrbind_2.CheckedBinding.Expr)) {
      return freeInEnv_1;
    } else {
      const freeInBinding_5 = freeInType_1(CollectAllNoCaching, pgrbind_2.RecBindingInfo.Val.TauType).FreeTypars;
      const freeInBinding_6 = ZsetModule.diff(freeInBinding_5, Zset.ofList(typarOrder, NormalizeDeclaredTyparsForEquiRecursiveInference(cenv_1.g, pgrbind_2.ExtraGeneralizableTypars)));
      const freeInBinding_7 = ZsetModule.diff(freeInBinding_6, Zset.ofList(typarOrder, NormalizeDeclaredTyparsForEquiRecursiveInference(cenv_1.g, pgrbind_2.RecBindingInfo.DeclaredTypars)));
      return ZsetModule.union(freeInBinding_7, freeInEnv_1);
    }
  }, freeInEnv, patternInput_1[0]);
  let patternInput_2;

  if (patternInput_1[0].tail == null) {
    patternInput_2 = [new List(), tpenv];
  } else {
    const supportForBindings = collect(function (pgrbind_3) {
      return TcLetrecComputeSupportForBinding(cenv_1, pgrbind_3);
    }, patternInput_1[0]);
    GeneralizationHelpers.CanonicalizePartialInferenceProblem(cenv_1, denv, scopem, supportForBindings);
    const generalizedTyparsL = map_1(function (pgrbind_4) {
      return TcLetrecComputeAndGeneralizeGenericTyparsForBinding(cenv_1, denv, freeInEnv_2, pgrbind_4);
    }, patternInput_1[0]);
    const newGeneralizedRecBinds = toList(map2(function (generalizedTypars, pgrbind_5) {
      return TcLetrecGeneralizeBinding(cenv_1, denv, generalizedTypars, pgrbind_5);
    }, generalizedTyparsL, patternInput_1[0]));
    const tpenv_1 = HideUnscopedTypars(concat(generalizedTyparsL), tpenv);
    patternInput_2 = [newGeneralizedRecBinds, tpenv_1];
  }

  patternInput_3 = [patternInput_2[0], patternInput_1[1], patternInput_2[1]];
  const envNonRec_1 = (vals = map_1(function (b) {
    return b.RecBindingInfo.Val;
  }, patternInput_3[0]), function (env) {
    return AddLocalVals(cenv_1.tcSink, scopem, vals, env);
  })(envNonRec);
  const generalizedRecBinds_1 = append(patternInput_3[0], generalizedRecBinds);
  return [envNonRec_1, generalizedRecBinds_1, patternInput_3[1], patternInput_3[2], uncheckedRecBindsTable];
}
export function TcLetrecComputeAndGeneralizeGenericTyparsForBinding(cenv_1, denv, freeInEnv, pgrbind) {
  const freeInEnv_1 = ZsetModule.diff(freeInEnv, Zset.ofList(typarOrder, NormalizeDeclaredTyparsForEquiRecursiveInference(cenv_1.g, pgrbind.ExtraGeneralizableTypars)));
  const vspec = pgrbind.RecBindingInfo.Val;
  const patternInput = pgrbind.RecBindingInfo.ExplicitTyparInfo;
  const allDeclaredTypars = append(pgrbind.RecBindingInfo.EnclosingDeclaredTypars, patternInput.data[1]);
  CheckDeclaredTypars(denv, cenv_1.css, pgrbind.CheckedBinding.data[9], patternInput.data[0], patternInput.data[1]);
  const memFlagsOpt = defaultArg(vspec.MemberInfo, null, function (memInfo) {
    return memInfo.MemberFlags;
  });
  const isCtor = memFlagsOpt != null ? getValue(memFlagsOpt).MemberKind.Equals(new MemberKind_2(1)) : false;
  GeneralizationHelpers.CheckDeclaredTyparsPermitted(memFlagsOpt, patternInput.data[1], pgrbind.CheckedBinding.data[9]);
  const canInferTypars = CanInferExtraGeneralizedTyparsForRecBinding(pgrbind);
  const tau = vspec.TauType;
  const maxInferredTypars = freeInTypeLeftToRight(cenv_1.g, false, tau);
  const canGeneralizeConstrained = GeneralizationHelpers.CanGeneralizeConstrainedTyparsForDecl(pgrbind.RecBindingInfo.DeclKind);
  const generalizedTypars = GeneralizationHelpers.ComputeAndGeneralizeGenericTypars(cenv_1, denv, pgrbind.CheckedBinding.data[9], freeInEnv_1, canInferTypars, canGeneralizeConstrained, pgrbind.CheckedBinding.data[0], pgrbind.CheckedBinding.data[6], allDeclaredTypars, maxInferredTypars, tau, isCtor);
  return generalizedTypars;
}
export function TcLetrecComputeSupportForBinding(cenv_1, pgrbind) {
  const allDeclaredTypars = append(pgrbind.RecBindingInfo.EnclosingDeclaredTypars, pgrbind.RecBindingInfo.DeclaredTypars);
  const maxInferredTypars = freeInTypeLeftToRight(cenv_1.g, false, pgrbind.RecBindingInfo.Val.TauType);
  return append(allDeclaredTypars, maxInferredTypars);
}
export function TcLetrecGeneralizeBinding(cenv_1, denv, generalizedTypars, pgrbind) {
  if (pgrbind.CheckedBinding.data[13]) {
    errorR(new _Error(SR.tcFixedNotAllowed(), Expr_get_Range.bind(pgrbind.CheckedBinding.data[6])()));
  }

  const patternInput = pgrbind.RecBindingInfo.data[4].TypeScheme;
  const pvalscheme1 = new PrelimValScheme1(0, [pgrbind.RecBindingInfo.data[4].Id, pgrbind.RecBindingInfo.data[5], patternInput[1], pgrbind.RecBindingInfo.data[6], pgrbind.RecBindingInfo.data[7], false, pgrbind.CheckedBinding.data[0], new ValBaseOrThisInfo(2), pgrbind.CheckedBinding.data[7], pgrbind.RecBindingInfo.data[11], pgrbind.CheckedBinding.data[11]]);
  const pvalscheme2 = GeneralizeVal(cenv_1, denv, pgrbind.RecBindingInfo.data[2], generalizedTypars, pvalscheme1);
  const valscheme = UseCombinedArity(cenv_1.g, pgrbind.RecBindingInfo.data[13], pgrbind.CheckedBinding.data[6], pvalscheme2);
  AdjustRecType(cenv_1, pgrbind.RecBindingInfo.data[4], valscheme);
  return new PostGeneralizationRecursiveBinding(valscheme, pgrbind.CheckedBinding, pgrbind.RecBindingInfo);
}
export function TcLetrecComputeCtorSafeThisValBind(cenv_1, safeThisValOpt) {
  if (safeThisValOpt != null) {
    const m = getValue(safeThisValOpt).Range;
    const ty = destRefCellTy(cenv_1.g, getValue(safeThisValOpt).Type);
    return mkCompGenBind(getValue(safeThisValOpt), mkRefCell(cenv_1.g, m, ty, mkNull(m, ty)));
  } else {
    return null;
  }
}
export function MakeCheckSafeInitField(g, tinst, thisValOpt, rfref, reqExpr, expr) {
  const m = Expr_get_Range.bind(expr)();
  const availExpr = thisValOpt != null ? mkRecdFieldGetViaExprAddr(exprForVal_4(m, getValue(thisValOpt)), rfref, tinst, m) : mkStaticRecdFieldGet(rfref, tinst, m);
  const failureExpr = thisValOpt != null ? mkCallFailInit(g, m) : mkCallFailStaticInit(g, m);
  return mkCompGenSequential(m, mkIfThen(g, m, mkILAsmClt(g, m, availExpr, reqExpr), failureExpr), expr);
}
export function MakeCheckSafeInit(g, tinst, safeInitInfo, reqExpr, expr) {
  if (safeInitInfo.tag === 1) {
    return expr;
  } else {
    return MakeCheckSafeInitField(g, tinst, null, safeInitInfo.data[0], reqExpr, expr);
  }
}
export function TcLetrecAdjustMemberForSpecialVals(cenv_1, pgrbind) {
  const expr = pgrbind.CheckedBinding.Expr;
  const spBind = pgrbind.CheckedBinding.SeqPoint;
  let expr_1;
  const matchValue = TcLetrecComputeCtorSafeThisValBind(cenv_1, pgrbind.RecBindingInfo.data[9]);

  if (matchValue != null) {
    const m = Expr_get_Range.bind(expr)();
    const patternInput = stripTopLambda(expr, pgrbind.RecBindingInfo.data[4].Type);
    expr_1 = mkMultiLambdas(m, patternInput[0], patternInput[1], mkLetBind(m, getValue(matchValue), patternInput[2]), patternInput[3]);
  } else {
    expr_1 = expr;
  }

  let expr_2;

  if ((pgrbind.RecBindingInfo.data[4].IsInstanceMember ? !pgrbind.RecBindingInfo.data[4].IsExtensionMember : false) ? !pgrbind.RecBindingInfo.data[4].IsConstructor : false) {
    if (pgrbind.RecBindingInfo.data[10].tag === 1) {
      expr_2 = expr_1;
    } else {
      const m_1 = Expr_get_Range.bind(expr_1)();
      const patternInput_1 = stripTopLambda(expr_1, pgrbind.RecBindingInfo.data[4].Type);
      const thisVar = patternInput_1[1].head.head;
      const thisTypeInst = argsOfAppTy(cenv_1.g, thisVar.Type);
      const newBody = MakeCheckSafeInitField(cenv_1.g, thisTypeInst, thisVar, pgrbind.RecBindingInfo.data[10].data[0], mkOne(cenv_1.g, m_1), patternInput_1[2]);
      expr_2 = mkMultiLambdas(m_1, patternInput_1[0], patternInput_1[1], newBody, patternInput_1[3]);
    }
  } else {
    expr_2 = expr_1;
  }

  let expr_3;

  if (pgrbind.RecBindingInfo.data[8] == null) {
    expr_3 = expr_2;
  } else {
    const m_2 = Expr_get_Range.bind(expr_2)();
    const patternInput_2 = stripTopLambda(expr_2, pgrbind.RecBindingInfo.data[4].Type);
    expr_3 = mkMemberLambdas(m_2, patternInput_2[0], null, pgrbind.RecBindingInfo.data[8], patternInput_2[1], patternInput_2[2], patternInput_2[3]);
  }

  return new PostBindCtorThisVarRefCellRecursiveBinding(pgrbind.ValScheme, new Binding_1(0, [pgrbind.RecBindingInfo.data[4], expr_3, spBind]));
}
export function FixupLetrecBind(cenv_1, denv, generalizedTyparsForRecursiveBlock, bind) {
  var objectArg;
  const matchValue = bind.Binding.data[0].MemberInfo;

  if (matchValue != null) {
    const matchValue_1 = PartitionValTyparsForApparentEnclosingType(cenv_1.g, bind.Binding.data[0]);

    if (matchValue_1 == null) {
      errorR(new _Error(SR.tcMemberIsNotSufficientlyGeneric(), bind.Binding.data[0].Range));
    } else {
      const parentTypars = getValue(matchValue_1)[0];
      const memberParentTypars = getValue(matchValue_1)[1];
      (objectArg = new Checker(cenv_1.g, cenv_1.amap, denv, SignatureRepackageInfo.Empty, false), function (arg00, arg10, arg20, arg30) {
        return objectArg.CheckTypars(arg00, arg10, arg20, arg30);
      })(bind.Binding.data[0].Range, TypeEquivEnv.Empty, memberParentTypars, parentTypars);
    }
  }

  const fixupPoints = GetAllUsesOfRecValue(cenv_1, bind.Binding.data[0]);
  AdjustAndForgetUsesOfRecValue(cenv_1, mkLocalValRef(bind.Binding.data[0]), bind.ValScheme);
  const expr = mkGenericBindRhs(cenv_1.g, bind.Binding.data[0].Range, generalizedTyparsForRecursiveBlock, bind.ValScheme.TypeScheme, bind.Binding.data[1]);
  return new PreInitializationGraphEliminationBinding(fixupPoints, new Binding_1(0, [bind.Binding.data[0], expr, bind.Binding.data[2]]));
}
export function unionGeneralizedTypars(typarSets) {
  return foldBack(function (l1, l2) {
    return ListSet.unionFavourRight(function (lv1, lv2) {
      return typarEq(lv1, lv2);
    }, l1, l2);
  }, typarSets, new List());
}
export function TcLetrec(overridesOK, cenv_1, env, tpenv, binds, bindsm, scopem) {
  var extraGeneralizableTypars;
  var reqdThisValTyOpt;
  var denv;
  const binds_1 = map_1(function (_arg73) {
    return new NormalizedRecBindingDefn(0, [_arg73.data[0], _arg73.data[1], _arg73.data[2], BindingNormalization.NormalizeBinding(new IsObjExprBinding(1), cenv_1, env, _arg73.data[3])]);
  }, binds);
  const patternInput = AnalyzeAndMakeAndPublishRecursiveValues(overridesOK, cenv_1, env, tpenv, binds_1);
  const tpenv_1 = patternInput[2][0];
  const envRec = AddLocalVals(cenv_1.tcSink, scopem, patternInput[1], env);
  const uncheckedRecBindsTable = create(map_1(function (rbind) {
    return [rbind.RecBindingInfo.Val.Stamp, rbind];
  }, patternInput[0]), new Comparer((x, y) => x.CompareTo(y)));
  const patternInput_1 = fold((extraGeneralizableTypars = new List(), reqdThisValTyOpt = null, function (tupledArg, rbind_1) {
    return TcLetrecBinding(cenv_1, envRec, scopem, extraGeneralizableTypars, reqdThisValTyOpt, tupledArg[0], tupledArg[1], tupledArg[2], tupledArg[3], tupledArg[4], rbind_1);
  }), [env, new List(), new List(), tpenv_1, uncheckedRecBindsTable], patternInput[0]);
  const generalizedRecBinds = toList(sortWith(($var349, $var350) => compare(function (pgrbind) {
    return pgrbind.RecBindingInfo.Index;
  }($var349), function (pgrbind) {
    return pgrbind.RecBindingInfo.Index;
  }($var350)), patternInput_1[1]));
  const generalizedTyparsForRecursiveBlock = unionGeneralizedTypars(map_1(function (pgrbind_1) {
    return pgrbind_1.GeneralizedTypars;
  }, generalizedRecBinds));
  const vxbinds = map_1(function (pgrbind_2) {
    return TcLetrecAdjustMemberForSpecialVals(cenv_1, pgrbind_2);
  }, generalizedRecBinds);
  const vxbinds_1 = map_1((denv = env.DisplayEnv, function (bind) {
    return FixupLetrecBind(cenv_1, denv, generalizedTyparsForRecursiveBlock, bind);
  }), vxbinds);
  let binds_2;
  const mustHaveArity = patternInput[0].tail != null ? DeclKind.MustHaveArity(patternInput[0].head.RecBindingInfo.DeclKind) : false;
  const results = EliminateInitializationGraphs(function (_arg74) {
    throw new Error("unreachable 2 - no type definitions in recursivve group");
  }, function (_arg76, _arg75) {
    throw new Error("unreachable 3 - no type definitions in recursivve group");
  }, function (x) {
    return x;
  }, function (morpher, oldBinds) {
    return morpher(oldBinds);
  }, cenv_1.g, mustHaveArity, env.DisplayEnv, ofArray([new MutRecShape(1, vxbinds_1)]), bindsm);
  const $var351 = results.tail != null ? results.head.tag === 1 ? results.tail.tail == null ? [1, results.head.data] : results.tail.head.tag === 1 ? results.tail.tail.tail == null ? [0, results.head.data, results.tail.head.data] : [2] : [2] : [2] : [2];

  switch ($var351[0]) {
    case 0:
      binds_2 = append($var351[1], $var351[2]);
      break;

    case 1:
      binds_2 = $var351[1];
      break;

    case 2:
      throw new Error("unreachable 4 - gave a Lets shape, expected at most one pre-lets shape back");
      break;
  }

  const envbody = AddLocalVals(cenv_1.tcSink, scopem, patternInput[1], env);
  return [binds_2, envbody, patternInput_1[3]];
}
export function TcAndPublishValSpec(cenv_1, env, containerInfo, declKind, memFlagsOpt, tpenv, valSpfn) {
  const synTypars = valSpfn.data[2].data[0];
  const synCanInferTypars = valSpfn.data[2].data[1];
  GeneralizationHelpers.CheckDeclaredTyparsPermitted(memFlagsOpt, synTypars, valSpfn.data[10]);
  const canInferTypars = GeneralizationHelpers.ComputeCanInferExtraGeneralizableTypars(containerInfo.ParentRef, synCanInferTypars, memFlagsOpt);

  const attrTgt = function (arg00, arg10) {
    return DeclKind.AllowedAttribTargets(arg00, arg10);
  }(memFlagsOpt, declKind) | 0;

  const attrs = TcAttributes(cenv_1, env, attrTgt, valSpfn.data[0]);
  const newOk = canInferTypars ? new ImplictlyBoundTyparsAllowed(1) : new ImplictlyBoundTyparsAllowed(2);
  const patternInput = TcValSpec(cenv_1, env, declKind, newOk, containerInfo, memFlagsOpt, null, tpenv, valSpfn, attrs);
  const denv = env.DisplayEnv;
  return mapFold(function (tpenv_1, valSpecResult) {
    const inlineFlag = ComputeInlineFlag(defaultArg(valSpecResult.data[1], null, function (_arg1) {
      return _arg1.data[0].MemberFlags;
    }), valSpfn.data[5], valSpfn.data[6], valSpfn.data[10]);
    const freeInType = freeInTypeLeftToRight(cenv_1.g, false, valSpecResult.data[5]);
    const allDeclaredTypars = append(valSpecResult.data[3], valSpecResult.data[4]);
    const flex = new ExplicitTyparInfo(0, [valSpecResult.data[4], valSpecResult.data[4], synCanInferTypars]);
    const generalizedTypars = GeneralizationHelpers.ComputeAndGeneralizeGenericTypars(cenv_1, denv, valSpecResult.data[2].idRange, emptyFreeTypars, canInferTypars, new GeneralizeConstrainedTyparOptions(0), inlineFlag, null, allDeclaredTypars, freeInType, valSpecResult.data[5], false);
    const valscheme1 = new PrelimValScheme1(0, [valSpecResult.data[2], flex, valSpecResult.data[5], valSpecResult.data[6], valSpecResult.data[1], valSpfn.data[6], inlineFlag, new ValBaseOrThisInfo(2), noArgOrRetAttribs, valSpfn.data[8], false]);
    const valscheme2 = GeneralizeVal(cenv_1, denv, valSpecResult.data[3], generalizedTypars, valscheme1);
    const tpenv_2 = HideUnscopedTypars(generalizedTypars, tpenv_1);
    const valscheme = BuildValScheme(valSpecResult.data[7], valSpecResult.data[6], valscheme2);
    let konst;

    if (valSpfn.data[9] != null) {
      const patternInput_1 = TcLiteral(cenv_1, valSpecResult.data[5], env, tpenv_2, attrs, getValue(valSpfn.data[9]));

      if (!patternInput_1[0]) {
        errorR(new _Error(SR.tcValueInSignatureRequiresLiteralAttribute(), getValue(valSpfn.data[9]).Range));
      }

      konst = patternInput_1[1];
    } else {
      const hasLiteralAttr = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_LiteralAttribute, attrs);

      if (hasLiteralAttr) {
        errorR(new _Error(SR.tcLiteralAttributeRequiresConstantValue(), valSpfn.data[10]));
      }

      konst = null;
    }

    const vspec = MakeAndPublishVal(cenv_1, env, valSpecResult.data[0], true, valSpecResult.data[7], new ValRecursiveScopeInfo(1), valscheme, attrs, valSpfn.data[7].ToXmlDoc(), konst, false);
    return [vspec, tpenv_2];
  }, patternInput[1], patternInput[0], ofArray);
}
export class NotUpperCaseConstructor extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, NotUpperCaseConstructor.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.NotUpperCaseConstructor",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.NotUpperCaseConstructor", NotUpperCaseConstructor);
export function CheckNamespaceModuleOrTypeName(g, id) {
  if (!g.compilingFslib ? indexOfAny(id.idText, IllegalCharactersInTypeAndNamespaceNames) !== -1 : false) {
    errorR(new _Error(SR.tcInvalidNamespaceModuleTypeUnionName(), id.idRange));
  }
}
export function CheckDuplicates(idf, k, elems) {
  iterateIndexed(function (i, uc1) {
    iterateIndexed(function (j, uc2) {
      const id1 = idf(uc1);
      const id2 = idf(uc2);

      if (j > i ? id1.idText === id2.idText : false) {
        errorR(new Duplicate(k, id1.idText, id1.idRange));
      }
    }, elems);
  }, elems);
  return elems;
}
export const TcRecdUnionAndEnumDeclarations = function (__exports) {
  const CombineReprAccess = __exports.CombineReprAccess = function (parent, vis) {
    if (parent.tag === 0) {
      return combineAccess(vis, parent.data.TypeReprAccessibility);
    } else {
      return vis;
    }
  };

  const MakeRecdFieldSpec = __exports.MakeRecdFieldSpec = function (_cenv, env, parent, isStatic, konst, ty_, attrsForProperty, attrsForField, id, nameGenerated, isMutable, vol, xmldoc, vis, m) {
    const patternInput = ComputeAccessAndCompPath(env, null, m, vis, null, parent);
    const vis_1 = CombineReprAccess(parent, patternInput[0]);
    return NewRecdField(isStatic, konst, id, nameGenerated, ty_, isMutable, vol, attrsForProperty, attrsForField, xmldoc, vis_1, false);
  };

  const TcFieldDecl = __exports.TcFieldDecl = function (cenv_1, env, parent, isIncrClass, tpenv, isStatic, synAttrs, id, nameGenerated, ty, isMutable, xmldoc, vis, m) {
    const patternInput = TcAttributesWithPossibleTargets(false, cenv_1, env, AttributeTargets.FieldDecl, synAttrs);
    const patternInput_1 = partition(function (tupledArg) {
      return (tupledArg[0] & 128) !== 0;
    }, patternInput[0]);
    const attrsForProperty = map_1(function (tuple) {
      return tuple[1];
    }, patternInput_1[0]);
    const attrsForField = map_1(function (tuple_1) {
      return tuple_1[1];
    }, patternInput_1[1]);
    const patternInput_2 = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, ty);
    const zeroInit = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_DefaultValueAttribute, attrsForField);
    const isVolatile = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_VolatileFieldAttribute, attrsForField);
    const isThreadStatic = isThreadOrContextStatic(cenv_1.g, attrsForField);

    if (isThreadStatic ? !zeroInit ? true : !isStatic : false) {
      error_1(new _Error(SR.tcThreadStaticAndContextStaticMustBeStatic(), m));
    }

    if (isVolatile) {
      error_1(new _Error(SR.tcVolatileOnlyOnClassLetBindings(), m));
    }

    if (isIncrClass ? !zeroInit ? true : !isMutable : false) {
      errorR(new _Error(SR.tcUninitializedValFieldsMustBeMutable(), m));
    }

    if (isStatic ? (!zeroInit ? true : !isMutable) ? true : !equals(vis, new SynAccess(2)) : false) {
      errorR(new _Error(SR.tcStaticValFieldsMustBeMutableAndPrivate(), m));
    }

    const konst = zeroInit ? new Const(17) : null;
    const rfspec = MakeRecdFieldSpec(cenv_1, env, parent, isStatic, konst, patternInput_2[0], attrsForProperty, attrsForField, id, nameGenerated, isMutable, isVolatile, xmldoc, vis, m);
    const $var352 = parent.tag === 0 ? useGenuineField(parent.data.Deref, rfspec) ? [0, parent.data] : [1] : [1];

    switch ($var352[0]) {
      case 0:
        TcAttributesWithPossibleTargets(false, cenv_1, env, AttributeTargets.FieldDeclRestricted, synAttrs);
        break;

      case 1:
        break;
    }

    return rfspec;
  };

  const TcAnonFieldDecl = __exports.TcAnonFieldDecl = function (cenv_1, env, parent, tpenv, nm, _arg1) {
    const id = _arg1.data[2] != null ? getValue(_arg1.data[2]) : mkSynId(_arg1.data[7], nm);
    const f = TcFieldDecl(cenv_1, env, parent, false, tpenv, _arg1.data[1], _arg1.data[0], id, CurriedLambda(() => _arg1.data[2] == null)(), _arg1.data[3], _arg1.data[4], _arg1.data[5].ToXmlDoc(), _arg1.data[6], _arg1.data[7]);

    if (_arg1.data[2] != null) {
      const item = new Item(20, [getValue(_arg1.data[2]), f.FormalType, null]);
      CallNameResolutionSink(cenv_1.tcSink, getValue(_arg1.data[2]).idRange, env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(0), env.DisplayEnv, env.AccessRights);
    }

    return f;
  };

  const TcNamedFieldDecl = __exports.TcNamedFieldDecl = function (cenv_1, env, parent, isIncrClass, tpenv, _arg1) {
    if (_arg1.data[2] != null) {
      return TcFieldDecl(cenv_1, env, parent, isIncrClass, tpenv, _arg1.data[1], _arg1.data[0], getValue(_arg1.data[2]), false, _arg1.data[3], _arg1.data[4], _arg1.data[5].ToXmlDoc(), _arg1.data[6], _arg1.data[7]);
    } else {
      return error_1(new _Error(SR.tcFieldRequiresName(), _arg1.data[7]));
    }
  };

  const TcNamedFieldDecls = __exports.TcNamedFieldDecls = function (cenv_1, env, parent, isIncrClass, tpenv, fields) {
    return map_1(function (arg50_) {
      return TcNamedFieldDecl(cenv_1, env, parent, isIncrClass, tpenv, arg50_);
    }, fields);
  };

  const CheckUnionCaseName = __exports.CheckUnionCaseName = function (cenv_1, realUnionCaseName, m) {
    CheckNamespaceModuleOrTypeName(cenv_1.g, mkSynId(m, realUnionCaseName));

    if ((!_String.isUpper(realUnionCaseName) ? realUnionCaseName !== opNameCons : false) ? realUnionCaseName !== opNameNil : false) {
      errorR(new NotUpperCaseConstructor(m));
    }
  };

  const ValidateFieldNames = __exports.ValidateFieldNames = function (synFields, tastFields) {
    const seen = new Map();
    const inputSequence = toList(zip(synFields, tastFields));

    for (let forLoopVar of inputSequence) {
      const patternInput = tryGetValue(seen, forLoopVar[1].Name, null);

      if (patternInput[0]) {
        const matchValue = [forLoopVar[0], patternInput[1]];
        const $var353 = matchValue[0].data[2] == null ? matchValue[1].data[2] != null ? [1, getValue(matchValue[1].data[2])] : [2] : matchValue[1].data[2] == null ? [1, getValue(matchValue[0].data[2])] : [0, getValue(matchValue[0].data[2])];

        switch ($var353[0]) {
          case 0:
            error_1(new _Error(SR.tcFieldNameIsUsedModeThanOnce($var353[1].idText), $var353[1].idRange));
            break;

          case 1:
            error_1(new _Error(SR.tcFieldNameConflictsWithGeneratedNameForAnonymousField($var353[1].idText), $var353[1].idRange));
            break;

          case 2:
            break;
        }
      } else {
        seen.set(forLoopVar[1].Name, forLoopVar[0]);
      }
    }
  };

  const TcUnionCaseDecl = __exports.TcUnionCaseDecl = function (cenv_1, env, parent, thisTy, tpenv, _arg1) {
    var tcAttributes;
    const attrs = TcAttributes(cenv_1, env, AttributeTargets.UnionCaseDecl, _arg1.data[0]);
    const patternInput = ComputeAccessAndCompPath(env, null, _arg1.data[5], _arg1.data[4], null, parent);
    const vis = CombineReprAccess(parent, patternInput[0]);
    const realUnionCaseName = _arg1.data[1].idText === opNameCons ? "Cons" : _arg1.data[1].idText === opNameNil ? "Empty" : _arg1.data[1].idText;

    if (realUnionCaseName === "Tags") {
      errorR(new _Error(SR.tcUnionCaseNameConflictsWithGeneratedType(realUnionCaseName, "Tags"), _arg1.data[5]));
    }

    CheckUnionCaseName(cenv_1, realUnionCaseName, _arg1.data[1].idRange);

    const mkName = function (nFields, i) {
      if (nFields <= 1) {
        return "Item";
      } else {
        return "Item" + (i + 1).toString();
      }
    };

    let patternInput_3;

    if (_arg1.data[2].tag === 1) {
      const ty = _arg1.data[2].data[0];
      const arity = _arg1.data[2].data[1];
      const patternInput_1 = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(0), new ItemOccurence(2), env, tpenv, ty);
      const patternInput_2 = GetTopTauTypeInFSharpForm(cenv_1.g, TranslatePartialArity(new List(), (tcAttributes = function (attrTgt, synAttribs) {
        return TcAttributes(cenv_1, env, attrTgt, synAttribs);
      }, function (arg20_) {
        return TranslateTopValSynInfo(_arg1.data[5], tcAttributes, arg20_);
      })(arity)).ArgInfos, patternInput_1[0], _arg1.data[5]);

      if (patternInput_2[0].length > 1) {
        errorR(new _Error(SR.tcIllegalFormForExplicitTypeDeclaration(), _arg1.data[5]));
      }

      const argtys = concat(patternInput_2[0]);
      const nFields_1 = argtys.length | 0;
      const rfields = mapIndexed(function (i_1, tupledArg) {
        let id;
        const matchValue = tupledArg[1].Name;

        if (matchValue == null) {
          id = mkSynId(_arg1.data[5], mkName(nFields_1, i_1));
        } else {
          id = getValue(matchValue);
        }

        return MakeRecdFieldSpec(cenv_1, env, parent, false, null, tupledArg[0], new List(), new List(), id, CurriedLambda(() => tupledArg[1].Name == null)(), false, false, XmlDoc.Empty, null, _arg1.data[5]);
      }, argtys);

      if (!typeEquiv(cenv_1.g, patternInput_2[1], thisTy)) {
        error_1(new _Error(SR.tcReturnTypesForUnionMustBeSameAsType(), _arg1.data[5]));
      }

      patternInput_3 = [rfields, patternInput_2[1]];
    } else {
      const nFields_2 = _arg1.data[2].data.length | 0;
      const rfields_1 = mapIndexed(function (i_2, fld) {
        return TcAnonFieldDecl(cenv_1, env, parent, tpenv, mkName(nFields_2, i_2), fld);
      }, _arg1.data[2].data);
      ValidateFieldNames(_arg1.data[2].data, rfields_1);
      patternInput_3 = [rfields_1, thisTy];
    }

    return NewUnionCase(_arg1.data[1], realUnionCaseName, patternInput_3[0], patternInput_3[1], attrs, _arg1.data[3].ToXmlDoc(), vis);
  };

  const TcUnionCaseDecls = __exports.TcUnionCaseDecls = function (cenv_1, env, parent, thisTy, tpenv, unionCases) {
    const unionCases_ = map_1(function (arg50_) {
      return TcUnionCaseDecl(cenv_1, env, parent, thisTy, tpenv, arg50_);
    }, unionCases);
    return CheckDuplicates(function (uc) {
      return uc.Id;
    }, "union case", unionCases_);
  };

  const TcEnumDecl = __exports.TcEnumDecl = function (cenv_1, env, parent, thisTy, fieldTy, _arg1) {
    const attrs = TcAttributes(cenv_1, env, 256, _arg1.data[0]);
    const $var354 = _arg1.data[2].tag === 18 ? [0] : _arg1.data[2].tag === 19 ? [0] : _arg1.data[2].tag === 16 ? [0] : [1];

    switch ($var354[0]) {
      case 0:
        return error_1(new _Error(SR.tcInvalidEnumerationLiteral(), _arg1.data[4]));

      case 1:
        const v = TcConst(cenv_1, fieldTy, _arg1.data[4], env, _arg1.data[2]);
        const patternInput = ComputeAccessAndCompPath(env, null, _arg1.data[4], null, null, parent);
        const vis = CombineReprAccess(parent, patternInput[0]);

        if (_arg1.data[1].idText === "value__") {
          errorR(new _Error(SR.tcNotValidEnumCaseName(), _arg1.data[1].idRange));
        }

        return NewRecdField(true, v, _arg1.data[1], false, thisTy, false, false, new List(), attrs, _arg1.data[3].ToXmlDoc(), vis, false);
    }
  };

  const TcEnumDecls = __exports.TcEnumDecls = function (cenv_1, env, parent, thisTy, enumCases) {
    const fieldTy = NewInferenceType();
    const enumCases_ = CheckDuplicates(function (f) {
      return f.Id;
    }, "enum element", map_1(function (arg50_) {
      return TcEnumDecl(cenv_1, env, parent, thisTy, fieldTy, arg50_);
    }, enumCases));
    return [fieldTy, enumCases_];
  };

  return __exports;
}({});
export function PublishInterface(cenv_1, denv, tcref, m, compgen, ty_) {
  if (!isInterfaceTy(cenv_1.g, ty_)) {
    errorR(new _Error(SR.tcTypeIsNotInterfaceType1(minimalStringOfType(denv, ty_)), m));
  }

  const tcaug = tcref.TypeContents;

  if (function (arg00, arg10) {
    return EntityRef_HasInterface.bind(tcref)(arg00, arg10);
  }(cenv_1.g, ty_)) {
    errorR(new _Error(SR.tcDuplicateSpecOfInterface(), m));
  }

  tcaug.tcaug_interfaces = new List([ty_, compgen, m], tcaug.tcaug_interfaces);
}
export function TcAndPublishMemberSpec(cenv_1, env, containerInfo, declKind, tpenv, memb) {
  switch (memb.tag) {
    case 2:
      return error_1(new _Error(SR.tcInheritIllegalHere(), memb.data[1]));

    case 4:
      return error_1(new _Error(SR.tcTypesCannotContainNestedTypes(), memb.data[1]));

    case 0:
      return TcAndPublishValSpec(cenv_1, env, containerInfo, declKind, memb.data[1], tpenv, memb.data[0]);

    case 1:
      return [new List(), tpenv];

    default:
      return error_1(new _Error(SR.tcFieldValIllegalHere(), memb.data[1]));
  }
}
export function TcTyconMemberSpecs(cenv_1, env, containerInfo, declKind, tpenv, augSpfn) {
  const patternInput = mapFold(function (tpenv_1, memb) {
    return TcAndPublishMemberSpec(cenv_1, env, containerInfo, declKind, tpenv_1, memb);
  }, tpenv, augSpfn, ofArray);
  return [concat(patternInput[0]), patternInput[1]];
}
export function TcModuleOrNamespaceLidAndPermitAutoResolve(tcSink, env, amap, longId) {
  if (longId.tail != null) {
    const m = function (list) {
      return reduce(function (arg00_, arg10_) {
        return unionRanges(arg00_, arg10_);
      }, list);
    }(map_1(function (id) {
      return id.idRange;
    }, longId));

    const matchValue = ResolveLongIndentAsModuleOrNamespace(tcSink, new ResultCollectionSettings(0), amap, m, true, new FullyQualifiedFlag(1), env.eNameResEnv, env.eAccessRights, longId.head, longId.tail, true);

    if (matchValue.tag === 1) {
      return ResultOrExceptionModule.raze(matchValue.data);
    } else {
      return new ResultOrException(0, matchValue.data);
    }
  } else {
    return new ResultOrException(0, new List());
  }
}
export function TcOpenDecl(tcSink, g, amap, m, scopem, env, longId) {
  const modrefs = ResultOrExceptionModule.ForceRaise(TcModuleOrNamespaceLidAndPermitAutoResolve(tcSink, env, amap, longId));

  for (let id of longId) {
    if (id.idText !== "`global`") {
      CheckNamespaceModuleOrTypeName(g, id);
    }
  }

  const IsPartiallyQualifiedNamespace = function (modref) {
    const patternInput = modref.CompilationPath;
    let p;

    if (patternInput.data[1].tail != null) {
      const h = patternInput.data[1].head[0];

      if (startsWith(h, FsiDynamicModulePrefix, 4)) {
        p = patternInput.data[1].tail;
      } else {
        p = patternInput.data[1];
      }
    } else {
      p = new List();
    }

    let isFSharpCoreSpecialCase;
    const matchValue = ccuOfTyconRef(modref);

    if (matchValue != null) {
      if (ccuEq(getValue(matchValue), g.fslibCcu) ? p.length + 1 - 1 === longId.length : false) {
        isFSharpCoreSpecialCase = item_6(0, p)[0] === "Microsoft";
      } else {
        isFSharpCoreSpecialCase = false;
      }
    } else {
      isFSharpCoreSpecialCase = false;
    }

    if (modref.IsNamespace ? p.length >= longId.length : false) {
      return !isFSharpCoreSpecialCase;
    } else {
      return false;
    }
  };

  iterate(function (tupledArg) {
    if (tupledArg[1].IsModule ? HasFSharpAttribute(g, g.attrib_RequireQualifiedAccessAttribute, tupledArg[1].Attribs) : false) {
      errorR(new _Error(SR.tcModuleRequiresQualifiedAccess(fullDisplayTextOfModRef(tupledArg[1])), m));
    }
  }, modrefs);

  if (!exists_1(function (tupledArg_1) {
    return tupledArg_1[1].IsModule ? !HasFSharpAttribute(g, g.attrib_RequireQualifiedAccessAttribute, tupledArg_1[1].Attribs) : false;
  }, modrefs)) {
    iterate(function (tupledArg_2) {
      if (IsPartiallyQualifiedNamespace(tupledArg_2[1])) {
        errorR(new _Error(SR.tcOpenUsedWithPartiallyQualifiedPath(fullDisplayTextOfModRef(tupledArg_2[1])), m));
      }
    }, modrefs);
  }

  const modrefs_1 = map_1(function (tupledArg_3) {
    return p23(tupledArg_3[0], tupledArg_3[1], tupledArg_3[2]);
  }, modrefs);
  iterate(function (modref_1) {
    CommitOperationResult(CheckEntityAttributes(g, modref_1, m));
  }, modrefs_1);
  const openDecl = OpenDeclaration.Create(longId, modrefs_1, scopem, false);
  const env_1 = OpenModulesOrNamespaces(tcSink, g, amap, scopem, false, env, modrefs_1, openDecl);
  return env_1;
}
export class ParameterlessStructCtor extends Error {
  constructor(data0) {
    super();
    Object.setPrototypeOf(this, ParameterlessStructCtor.prototype);
    this.Data0 = data0;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.ParameterlessStructCtor",
      interfaces: ["FSharpException"],
      properties: {
        Data0: range
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.ParameterlessStructCtor", ParameterlessStructCtor);
export const IncrClassChecking = function (__exports) {
  const IncrClassBindingGroup = __exports.IncrClassBindingGroup = class IncrClassBindingGroup {
    constructor(tag, data) {
      this.tag = tag | 0;
      this.data = data;
    }

    [_Symbol.reflection]() {
      return {
        type: "Microsoft.FSharp.Compiler.TypeChecker.IncrClassChecking.IncrClassBindingGroup",
        interfaces: ["FSharpUnion"],
        cases: [["IncrClassBindingGroup", makeGeneric(List, {
          T: Binding_1
        }), "boolean", "boolean"], ["IncrClassDo", Expr, "boolean"]]
      };
    }

  };
  setType("Microsoft.FSharp.Compiler.TypeChecker.IncrClassChecking.IncrClassBindingGroup", IncrClassBindingGroup);
  const IncrClassCtorLhs = __exports.IncrClassCtorLhs = class IncrClassCtorLhs {
    constructor(tyconRef, instanceCtorDeclaredTypars, staticCtorValInfo, instanceCtorVal, instanceCtorValScheme, instanceCtorArgs, instanceCtorSafeThisValOpt, instanceCtorSafeInitInfo, instanceCtorBaseValOpt, instanceCtorThisVal, nameGenerator) {
      this.TyconRef = tyconRef;
      this.InstanceCtorDeclaredTypars = instanceCtorDeclaredTypars;
      this.StaticCtorValInfo = staticCtorValInfo;
      this.InstanceCtorVal = instanceCtorVal;
      this.InstanceCtorValScheme = instanceCtorValScheme;
      this.InstanceCtorArgs = instanceCtorArgs;
      this.InstanceCtorSafeThisValOpt = instanceCtorSafeThisValOpt;
      this.InstanceCtorSafeInitInfo = instanceCtorSafeInitInfo;
      this.InstanceCtorBaseValOpt = instanceCtorBaseValOpt;
      this.InstanceCtorThisVal = instanceCtorThisVal;
      this.NameGenerator = nameGenerator;
    }

    [_Symbol.reflection]() {
      return {
        type: "Microsoft.FSharp.Compiler.TypeChecker.IncrClassChecking.IncrClassCtorLhs",
        interfaces: ["FSharpRecord"],
        properties: {
          TyconRef: EntityRef,
          InstanceCtorDeclaredTypars: makeGeneric(List, {
            T: Typar
          }),
          StaticCtorValInfo: Any,
          InstanceCtorVal: Val,
          InstanceCtorValScheme: ValScheme,
          InstanceCtorArgs: makeGeneric(List, {
            T: Val
          }),
          InstanceCtorSafeThisValOpt: Option(Val),
          InstanceCtorSafeInitInfo: SafeInitData,
          InstanceCtorBaseValOpt: Option(Val),
          InstanceCtorThisVal: Val,
          NameGenerator: NiceNameGenerator
        }
      };
    }

    GetNormalizedInstanceCtorDeclaredTypars(cenv_1, denv, m) {
      const ctorDeclaredTypars = ChooseCanonicalDeclaredTyparsAfterInference(cenv_1.g, denv, this.InstanceCtorDeclaredTypars, m);
      return ctorDeclaredTypars;
    }

  };
  setType("Microsoft.FSharp.Compiler.TypeChecker.IncrClassChecking.IncrClassCtorLhs", IncrClassCtorLhs);

  const TcImplictCtorLhs_Phase2A = __exports.TcImplictCtorLhs_Phase2A = function (cenv_1, env, tpenv, tcref, vis, attrs, spats, thisIdOpt, baseValOpt, safeInitInfo, m, copyOfTyconTypars, objTy, thisTy) {
    var attribs_1;
    let baseValOpt_1;
    const matchValue = GetSuperTypeOfType(cenv_1.g, cenv_1.amap, m, objTy);

    if (matchValue == null) {
      baseValOpt_1 = null;
    } else {
      baseValOpt_1 = MakeAndPublishBaseVal(cenv_1, env, baseValOpt != null ? getValue(baseValOpt).Id : null, getValue(matchValue));
    }

    const env_1 = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), copyOfTyconTypars, env);
    const patternInput = TcSimplePatsOfUnknownType(cenv_1, true, new CheckConstraints(0), env_1, tpenv, new SynSimplePats(0, [spats, m]));
    const names = patternInput[1][1];
    const patternInput_1 = MakeSimpleVals(cenv_1, env_1, names);

    if (tcref.IsStructOrEnumTycon ? spats.tail == null : false) {
      errorR(new ParameterlessStructCtor(tcref.Range));
    }

    const ctorArgs = map_1(function (v) {
      return NameMapModule.find(v, patternInput_1[1]);
    }, patternInput[0]);
    const safeThisValOpt = MakeAndPublishSafeThisVal(cenv_1, env_1, thisIdOpt, thisTy);
    let patternInput_2;
    const argty = mkRefTupledTy(cenv_1.g, typesOfVals(ctorArgs));
    const ctorTy = mkFunTy(argty, objTy);
    const attribs = TcAttributes(cenv_1, env_1, 32 | 64, attrs);
    const memberFlags = CtorMemberFlags;
    const synArgInfos = map_1((attribs_1 = new List(), function (p) {
      return SynInfo.InferSynArgInfoFromSimplePat(attribs_1, p);
    }), spats);
    const valSynData = new SynValInfo(0, [ofArray([synArgInfos]), SynInfo.unnamedRetVal]);
    const id = ident("new", m);
    CheckForNonAbstractInterface(new DeclKind(0), tcref, memberFlags, id.idRange);
    const memberInfo = MakeMemberDataAndMangledNameForMemberVal(cenv_1.g, tcref, false, attribs, new List(), memberFlags, valSynData, id, false);
    const partialValReprInfo = TranslateTopValSynInfo(m, function (attrTgt, synAttribs) {
      return TcAttributes(cenv_1, env_1, attrTgt, synAttribs);
    }, valSynData);
    const prelimTyschemeG = new TypeScheme(0, [copyOfTyconTypars, ctorTy]);
    const isComplete = ComputeIsComplete(copyOfTyconTypars, new List(), ctorTy);
    const topValInfo = InferGenericArityFromTyScheme(prelimTyschemeG, partialValReprInfo);
    const ctorValScheme = new ValScheme(0, [id, prelimTyschemeG, topValInfo, memberInfo, false, new ValInline(3), new ValBaseOrThisInfo(2), vis, false, true, false, false]);
    const ctorVal = MakeAndPublishVal(cenv_1, env_1, new ParentRef(0, tcref), false, new DeclKind(0), new ValRecursiveScopeInfo(0, isComplete), ctorValScheme, attribs, XmlDoc.Empty, null, false);
    patternInput_2 = [ctorValScheme, ctorVal];
    const cctorValInfo = new Lazy(function () {
      const cctorArgs = ofArray([mkCompGenLocal(m, "unitVar", cenv_1.g.unit_ty)[0]]);
      const cctorTy = mkFunTy(cenv_1.g.unit_ty, cenv_1.g.unit_ty);
      const valSynData_1 = new SynValInfo(0, [ofArray([new List()]), SynInfo.unnamedRetVal]);
      const id_1 = ident("cctor", m);
      CheckForNonAbstractInterface(new DeclKind(0), tcref, ClassCtorMemberFlags, id_1.idRange);
      const memberInfo_1 = MakeMemberDataAndMangledNameForMemberVal(cenv_1.g, tcref, false, new List(), new List(), ClassCtorMemberFlags, valSynData_1, id_1, false);
      const partialValReprInfo_1 = TranslateTopValSynInfo(m, function (attrTgt_1, synAttribs_1) {
        return TcAttributes(cenv_1, env_1, attrTgt_1, synAttribs_1);
      }, valSynData_1);
      const prelimTyschemeG_1 = new TypeScheme(0, [copyOfTyconTypars, cctorTy]);
      const topValInfo_1 = InferGenericArityFromTyScheme(prelimTyschemeG_1, partialValReprInfo_1);
      const cctorValScheme = new ValScheme(0, [id_1, prelimTyschemeG_1, topValInfo_1, memberInfo_1, false, new ValInline(3), new ValBaseOrThisInfo(2), new SynAccess(2), false, true, false, false]);
      const cctorVal = MakeAndPublishVal(cenv_1, env_1, new ParentRef(0, tcref), false, new DeclKind(0), new ValRecursiveScopeInfo(1), cctorValScheme, new List(), XmlDoc.Empty, null, false);
      return [cctorArgs, cctorVal, cctorValScheme];
    });
    let thisVal_1;
    const thisId = ident("this", m);
    const thisValScheme = new ValScheme(0, [thisId, NonGenericTypeScheme(thisTy), null, null, false, new ValInline(3), new ValBaseOrThisInfo(0), null, true, false, false, false]);
    const thisVal = MakeAndPublishVal(cenv_1, env_1, new ParentRef(1), false, new DeclKind(3, false), new ValRecursiveScopeInfo(1), thisValScheme, new List(), XmlDoc.Empty, null, false);
    thisVal_1 = thisVal;
    return new IncrClassCtorLhs(tcref, copyOfTyconTypars, cctorValInfo, patternInput_2[1], patternInput_2[0], ctorArgs, safeThisValOpt, safeInitInfo, baseValOpt_1, thisVal_1, new NiceNameGenerator());
  };

  const MakeIncrClassField = function (g, cpath, formalTyparInst, v, isStatic, rfref) {
    const name = rfref.FieldName;
    const id = ident(name, v.Range);

    const ty = function (arg10_) {
      return instType(formalTyparInst, arg10_);
    }(v.Type);

    const taccess = new Accessibility(0, ofArray([cpath]));
    const isVolatile = HasFSharpAttribute(g, g.attrib_VolatileFieldAttribute, v.Attribs);
    return NewRecdField(isStatic, null, id, false, ty, v.IsMutable, isVolatile, new List(), v.Attribs, v.XmlDoc, taccess, true);
  };

  const IncrClassValRepr = __exports.IncrClassValRepr = class IncrClassValRepr {
    constructor(tag, data) {
      this.tag = tag | 0;
      this.data = data;
    }

    [_Symbol.reflection]() {
      return {
        type: "Microsoft.FSharp.Compiler.TypeChecker.IncrClassChecking.IncrClassValRepr",
        interfaces: ["FSharpUnion"],
        cases: [["InVar", "boolean"], ["InField", "boolean", "number", RecdFieldRef], ["InMethod", "boolean", Val, ValReprInfo]]
      };
    }

  };
  setType("Microsoft.FSharp.Compiler.TypeChecker.IncrClassChecking.IncrClassValRepr", IncrClassValRepr);
  const IncrClassReprInfo = __exports.IncrClassReprInfo = class IncrClassReprInfo {
    constructor(takenFieldNames, repInfoTcGlobals, valReprs, valsWithRepresentation) {
      this.TakenFieldNames = takenFieldNames;
      this.RepInfoTcGlobals = repInfoTcGlobals;
      this.ValReprs = valReprs;
      this.ValsWithRepresentation = valsWithRepresentation;
    }

    [_Symbol.reflection]() {
      return {
        type: "Microsoft.FSharp.Compiler.TypeChecker.IncrClassChecking.IncrClassReprInfo",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          TakenFieldNames: makeGeneric(_Set_1, {
            T: "string"
          }),
          RepInfoTcGlobals: TcGlobals,
          ValReprs: makeGeneric(_Map_1, {
            Key: Val,
            Value: IncrClassValRepr,
            ComparerTag: Interface("System.Collections.Generic.IComparer")
          }),
          ValsWithRepresentation: makeGeneric(_Set, {
            T: Val,
            ComparerTag: Interface("System.Collections.Generic.IComparer")
          })
        }
      };
    }

    Equals(other) {
      return equalsRecords(this, other);
    }

    static Empty(g, names) {
      return new IncrClassReprInfo(create_1(names, new Comparer(comparePrimitives)), g, ZmapModule.empty(valOrder), ZsetModule.empty(valOrder));
    }

    LookupRepr(v) {
      const matchValue = ZmapModule.tryFind(v, this.ValReprs);

      if (matchValue != null) {
        return getValue(matchValue);
      } else {
        return error_1(new InternalError("LookupRepr: failed to find representation for value", v.Range));
      }
    }

    static IsMethodRepr(cenv_1, bind) {
      const v = bind.Var;

      if (isUnitTy(cenv_1.g, v.Type)) {
        return false;
      } else {
        const arity = InferArityOfExprBinding(cenv_1.g, new AllowTypeDirectedDetupling(0), v, bind.Expr);

        if (!arity.HasNoArgs) {
          return !v.IsMutable;
        } else {
          return false;
        }
      }
    }

    ChooseRepresentation(cenv_1, env, isStatic, isCtorArg, ctorInfo, staticForcedFieldVars, instanceForcedFieldVars, takenFieldNames, bind) {
      const v = bind.Var;
      const relevantForcedFieldVars = isStatic ? staticForcedFieldVars : instanceForcedFieldVars;
      let patternInput;
      const isNameTaken = takenFieldNames.has(v.LogicalName) ? true : CurriedLambda(() => ctorInfo.TyconRef.GetFieldByName(v.LogicalName) != null)() ? isStatic ? true : !ctorInfo.TyconRef.IsFSharpStructOrEnumTycon : false;
      const nm = isNameTaken ? ctorInfo.NameGenerator.FreshCompilerGeneratedName(v.LogicalName, v.Range) : v.LogicalName;
      patternInput = [nm, add_2(nm, takenFieldNames)];

      const reportIfUnused = () => {
        if (((!v.HasBeenReferenced ? !v.IsCompiledAsTopLevel : false) ? !(v.DisplayName.indexOf("_") === 0) : false) ? !v.IsCompilerGenerated : false) {
          warning(new _Error(SR.chkUnusedValue(v.DisplayName), v.Range));
        }
      };

      let repr;
      const matchValue = InferArityOfExprBinding(cenv_1.g, new AllowTypeDirectedDetupling(0), v, bind.Expr);

      if (matchValue.HasNoArgs ? true : v.IsMutable) {
        if ((v.IsMutable ? true : relevantForcedFieldVars.Contains_0(v)) ? true : ctorInfo.TyconRef.IsStructOrEnumTycon) {
          const rfref = new RecdFieldRef(0, [ctorInfo.TyconRef, patternInput[0]]);
          reportIfUnused();
          repr = new IncrClassValRepr(1, [isStatic, this.ValReprs.Count, rfref]);
        } else {
          repr = new IncrClassValRepr(0, isCtorArg);
        }
      } else {
        const patternInput_1 = GetTopValTypeInCompiledForm(cenv_1.g, matchValue, v.Type, v.Range);
        const valSynInfo = new SynValInfo(0, [List_1.mapSquared(tupledArg => new SynArgInfo(0, [new List(), false, tupledArg[1].Name]), patternInput_1[1]), SynInfo.unnamedRetVal]);
        const memberFlags = (isStatic ? k => StaticMemberFlags(k) : k_1 => NonVirtualMemberFlags(k_1))(new MemberKind_2(2));
        const id = mkSynId(v.Range, patternInput[0]);
        const memberInfo = MakeMemberDataAndMangledNameForMemberVal(cenv_1.g, ctorInfo.TyconRef, false, new List(), new List(), memberFlags, valSynInfo, mkSynId(v.Range, patternInput[0]), true);

        const copyOfTyconTypars = ((arg00, arg10, arg20) => ctorInfo.GetNormalizedInstanceCtorDeclaredTypars(arg00, arg10, arg20))(cenv_1, env.DisplayEnv, ctorInfo.TyconRef.Range);

        let patternInput_2;
        const tauTy = v.TauType;

        if (isStatic) {
          patternInput_2 = [tauTy, matchValue];
        } else {
          const tauTy_1 = op_MinusMinusGreater(ctorInfo.InstanceCtorThisVal.Type, v.TauType);
          const topValInfo = new ValReprInfo(0, [matchValue.data[0], new List(ValReprInfoModule.selfMetadata, matchValue.data[1]), matchValue.data[2]]);
          patternInput_2 = [tauTy_1, topValInfo];
        }

        const topValInfo_1 = new ValReprInfo(0, [append(patternInput_2[1].data[0], ValReprInfoModule.InferTyparInfo(copyOfTyconTypars)), patternInput_2[1].data[1], patternInput_2[1].data[2]]);
        const prelimTyschemeG = new TypeScheme(0, [append(copyOfTyconTypars, patternInput_1[0]), patternInput_2[0]]);
        const memberValScheme = new ValScheme(0, [id, prelimTyschemeG, topValInfo_1, memberInfo, false, new ValInline(3), new ValBaseOrThisInfo(2), null, true, true, false, false]);
        const methodVal = MakeAndPublishVal(cenv_1, env, new ParentRef(0, ctorInfo.TyconRef), false, new DeclKind(0), new ValRecursiveScopeInfo(1), memberValScheme, v.Attribs, XmlDoc.Empty, null, false);
        reportIfUnused();
        repr = new IncrClassValRepr(2, [isStatic, methodVal, topValInfo_1]);
      }

      return [repr, patternInput[1]];
    }

    ChooseAndAddRepresentation(cenv_1, env, isStatic, isCtorArg, ctorInfo, staticForcedFieldVars, instanceForcedFieldVars, bind) {
      const v = bind.Var;
      const patternInput = this.ChooseRepresentation(cenv_1, env, isStatic, isCtorArg, ctorInfo, staticForcedFieldVars, instanceForcedFieldVars, this.TakenFieldNames, bind);
      const ValReprs = ZmapModule.add(v, patternInput[0], this.ValReprs);
      return new IncrClassReprInfo(patternInput[1], this.RepInfoTcGlobals, ValReprs, this.ValsWithRepresentation);
    }

    ValNowWithRepresentation(v) {
      const ValsWithRepresentation = ZsetModule.add(v, this.ValsWithRepresentation);
      return new IncrClassReprInfo(this.TakenFieldNames, this.RepInfoTcGlobals, this.ValReprs, ValsWithRepresentation);
    }

    IsValWithRepresentation(v) {
      return this.ValsWithRepresentation.Contains_0(v);
    }

    IsValRepresentedAsLocalVar(v) {
      const matchValue = this.LookupRepr(v);
      const $var355 = matchValue.tag === 0 ? matchValue.data ? [1] : [0] : [1];

      switch ($var355[0]) {
        case 0:
          return true;

        case 1:
          return false;
      }
    }

    MakeValueLookup(thisValOpt, tinst, safeStaticInitInfo, v, tyargs, m) {
      const matchValue = [this.LookupRepr(v), thisValOpt];

      if (matchValue[0].tag === 1) {
        if (matchValue[0].data[0]) {
          const expr = mkStaticRecdFieldGet(matchValue[0].data[2], tinst, m);
          return MakeCheckSafeInit(this.RepInfoTcGlobals, tinst, safeStaticInitInfo, mkInt(this.RepInfoTcGlobals, m, matchValue[0].data[1]), expr);
        } else if (matchValue[1] == null) {
          return error_1(new InternalError("Unexpected missing 'this' variable in MakeValueLookup", m));
        } else {
          const thise = exprForVal_4(m, getValue(matchValue[1]));
          return mkRecdFieldGetViaExprAddr(thise, matchValue[0].data[2], tinst, m);
        }
      } else if (matchValue[0].tag === 2) {
        const patternInput = AdjustValForExpectedArity(this.RepInfoTcGlobals, m, mkLocalValRef(matchValue[0].data[1]), new ValUseFlag(1), matchValue[0].data[2]);
        const tyargs_1 = append(tinst, tyargs);
        const thisArgs = matchValue[0].data[0] ? new List() : toList(defaultArg(defaultArg(thisValOpt, null, arg10_ => exprForVal_4(m, arg10_)), [], $var356 => [$var356]));
        return MakeApplicationAndBetaReduce(this.RepInfoTcGlobals, patternInput[0], patternInput[1], ofArray([tyargs_1]), thisArgs, m);
      } else {
        return exprForVal_4(m, v);
      }
    }

    MakeValueAssign(thisValOpt, tinst, safeStaticInitInfo, v, expr, m) {
      const matchValue = [this.LookupRepr(v), thisValOpt];

      if (matchValue[0].tag === 0) {
        return mkValSet(m, mkLocalValRef(v), expr);
      } else if (matchValue[0].tag === 2) {
        return error_1(new InternalError("Local was given method storage, yet later it's been assigned to", m));
      } else if (matchValue[0].data[0]) {
        const expr_1 = mkStaticRecdFieldSet(matchValue[0].data[2], tinst, expr, m);
        return MakeCheckSafeInit(this.RepInfoTcGlobals, tinst, safeStaticInitInfo, mkInt(this.RepInfoTcGlobals, m, matchValue[0].data[1]), expr_1);
      } else if (matchValue[1] == null) {
        return error_1(new InternalError("Unexpected missing 'this' variable in MakeValueAssign", m));
      } else {
        const thise = exprForVal_4(m, getValue(matchValue[1]));
        return mkRecdFieldSetViaExprAddr(thise, matchValue[0].data[2], tinst, expr, m);
      }
    }

    MakeValueGetAddress(thisValOpt, tinst, safeStaticInitInfo, v, m) {
      const matchValue = [this.LookupRepr(v), thisValOpt];

      if (matchValue[0].tag === 0) {
        return mkValAddr(m, mkLocalValRef(v));
      } else if (matchValue[0].tag === 2) {
        return error_1(new InternalError("Local was given method storage, yet later it's address was required", m));
      } else if (matchValue[0].data[0]) {
        const expr = mkStaticRecdFieldGetAddr(matchValue[0].data[2], tinst, m);
        return MakeCheckSafeInit(this.RepInfoTcGlobals, tinst, safeStaticInitInfo, mkInt(this.RepInfoTcGlobals, m, matchValue[0].data[1]), expr);
      } else if (matchValue[1] == null) {
        return error_1(new InternalError("Unexpected missing 'this' variable in MakeValueGetAddress", m));
      } else {
        const thise = exprForVal_4(m, getValue(matchValue[1]));
        return mkRecdFieldGetAddrViaExprAddr(thise, matchValue[0].data[2], tinst, m);
      }
    }

    PublishIncrClassFields(cenv_1, denv, cpath, ctorInfo, safeStaticInitInfo) {
      var inputRecord;
      const rfspecs = toList(delay(() => append_1(collect_1(matchValue => {
        const activePatternResult42915 = matchValue;

        if (activePatternResult42915[1].tag === 1) {
          if (activePatternResult42915[1].data[0] ? true : !ctorInfo.TyconRef.IsFSharpStructOrEnumTycon) {
            const ctorDeclaredTypars = ((arg00, arg10, arg20) => ctorInfo.GetNormalizedInstanceCtorDeclaredTypars(arg00, arg10, arg20))(cenv_1, denv, ctorInfo.TyconRef.Range);

            const revTypeInst = toList(zip(ctorDeclaredTypars, (list => map_1(tp => mkTyparTy(tp), list))(ctorInfo.TyconRef.TyparsNoRange)));
            return singleton(MakeIncrClassField(this.RepInfoTcGlobals, cpath, revTypeInst, activePatternResult42915[0], activePatternResult42915[1].data[0], activePatternResult42915[1].data[2]));
          } else {
            return empty();
          }
        } else {
          return empty();
        }
      }, this.ValReprs), delay(() => safeStaticInitInfo.tag === 1 ? empty() : singleton(safeStaticInitInfo.data[1])))));
      const recdFields = MakeRecdFieldsTable(append(rfspecs, ctorInfo.TyconRef.AllFieldsAsList));
      ctorInfo.TyconRef.Deref.entity_tycon_repr = new TyconRepresentation(0, (inputRecord = ctorInfo.TyconRef.FSharpObjectModelTypeInfo, new TyconObjModelData(inputRecord.fsobjmodel_kind, inputRecord.fsobjmodel_vslots, recdFields)));
    }

    FixupIncrClassExprPhase2C(thisValOpt, safeStaticInitInfo, thisTyInst, expr) {
      const FixupExprNode = (rw, e) => {
        var matchValue;
        var arg_1;
        let $var357;

        if (e.tag === 5) {
          if (e.data[0].tag === 1) {
            const activePatternResult42951 = _ValDeref_(e.data[0].data[0]);

            if (this.IsValWithRepresentation(activePatternResult42951) ? (matchValue = this.LookupRepr(activePatternResult42951), matchValue.tag === 2 ? true : false) : false) {
              $var357 = [0, e.data[3], e.data[4], e.data[2], activePatternResult42951];
            } else {
              $var357 = [1];
            }
          } else {
            $var357 = [1];
          }
        } else {
          $var357 = [1];
        }

        switch ($var357[0]) {
          case 0:
            const expr_1 = ((arg00, arg10, arg20, arg30, arg40, arg50) => this.MakeValueLookup(arg00, arg10, arg20, arg30, arg40, arg50))(thisValOpt, thisTyInst, safeStaticInitInfo, $var357[4], $var357[3], $var357[2]);

            const args = (list => map_1(rw, list))($var357[1]);

            return MakeApplicationAndBetaReduce(this.RepInfoTcGlobals, expr_1, tyOfExpr(this.RepInfoTcGlobals, expr_1), new List(), args, $var357[2]);

          case 1:
            let $var358;

            if (e.tag === 1) {
              const activePatternResult42950 = _ValDeref_(e.data[0]);

              if (this.IsValWithRepresentation(activePatternResult42950)) {
                $var358 = [0, e.data[2], activePatternResult42950];
              } else {
                $var358 = [1];
              }
            } else {
              $var358 = [1];
            }

            switch ($var358[0]) {
              case 0:
                return ((arg00_1, arg10_1, arg20_1, arg30_1, arg40_1, arg50_1) => this.MakeValueLookup(arg00_1, arg10_1, arg20_1, arg30_1, arg40_1, arg50_1))(thisValOpt, thisTyInst, safeStaticInitInfo, $var358[2], new List(), $var358[1]);

              case 1:
                let $var359;

                if (e.tag === 11) {
                  if (e.data[0].tag === 30) {
                    if (e.data[0].data[0].tag === 2) {
                      const activePatternResult42949 = _ValDeref_(e.data[0].data[1]);

                      if (e.data[1].tail == null) {
                        if (e.data[2].tail != null) {
                          if (e.data[2].tail.tail == null) {
                            if (arg_1 = e.data[2].head, this.IsValWithRepresentation(activePatternResult42949)) {
                              $var359 = [0, e.data[2].head, e.data[3], activePatternResult42949];
                            } else {
                              $var359 = [1];
                            }
                          } else {
                            $var359 = [1];
                          }
                        } else {
                          $var359 = [1];
                        }
                      } else {
                        $var359 = [1];
                      }
                    } else {
                      $var359 = [1];
                    }
                  } else {
                    $var359 = [1];
                  }
                } else {
                  $var359 = [1];
                }

                switch ($var359[0]) {
                  case 0:
                    const arg = rw($var359[1]);
                    return ((arg00_2, arg10_2, arg20_2, arg30_2, arg40_2, arg50_2) => this.MakeValueAssign(arg00_2, arg10_2, arg20_2, arg30_2, arg40_2, arg50_2))(thisValOpt, thisTyInst, safeStaticInitInfo, $var359[3], arg, $var359[2]);

                  case 1:
                    let $var360;

                    if (e.tag === 11) {
                      if (e.data[0].tag === 30) {
                        if (e.data[0].data[0].tag === 0) {
                          const activePatternResult42948 = _ValDeref_(e.data[0].data[1]);

                          if (e.data[1].tail == null) {
                            if (e.data[2].tail == null) {
                              if (this.IsValWithRepresentation(activePatternResult42948)) {
                                $var360 = [0, e.data[3], activePatternResult42948];
                              } else {
                                $var360 = [1];
                              }
                            } else {
                              $var360 = [1];
                            }
                          } else {
                            $var360 = [1];
                          }
                        } else {
                          $var360 = [1];
                        }
                      } else {
                        $var360 = [1];
                      }
                    } else {
                      $var360 = [1];
                    }

                    switch ($var360[0]) {
                      case 0:
                        return ((arg00_3, arg10_3, arg20_3, arg30_3, arg40_3) => this.MakeValueGetAddress(arg00_3, arg10_3, arg20_3, arg30_3, arg40_3))(thisValOpt, thisTyInst, safeStaticInitInfo, $var360[2], $var360[1]);

                      case 1:
                        return null;
                    }

                }

            }

        }
      };

      return RewriteExpr(new ExprRewritingEnv(FixupExprNode, _arg2 => null, null, true), expr);
    }

  };
  setType("Microsoft.FSharp.Compiler.TypeChecker.IncrClassChecking.IncrClassReprInfo", IncrClassReprInfo);
  const IncrClassConstructionBindingsPhase2C = __exports.IncrClassConstructionBindingsPhase2C = class IncrClassConstructionBindingsPhase2C {
    constructor(tag, data) {
      this.tag = tag | 0;
      this.data = data;
    }

    [_Symbol.reflection]() {
      return {
        type: "Microsoft.FSharp.Compiler.TypeChecker.IncrClassChecking.IncrClassConstructionBindingsPhase2C",
        interfaces: ["FSharpUnion"],
        cases: [["Phase2CBindings", makeGeneric(List, {
          T: IncrClassBindingGroup
        })], ["Phase2CCtorJustAfterSuperInit"], ["Phase2CCtorJustAfterLastLet"]]
      };
    }

  };
  setType("Microsoft.FSharp.Compiler.TypeChecker.IncrClassChecking.IncrClassConstructionBindingsPhase2C", IncrClassConstructionBindingsPhase2C);

  const MakeCtorForIncrClassConstructionPhase2C = __exports.MakeCtorForIncrClassConstructionPhase2C = function (cenv_1, env, ctorInfo, inheritsExpr, inheritsIsVisible, decs, memberBinds, generalizedTyparsForRecursiveBlock, safeStaticInitInfo) {
    var denv_1;
    const denv = env.DisplayEnv;
    const m = ctorInfo.InstanceCtorThisVal.Range;

    const ctorDeclaredTypars = function (arg00, arg10, arg20) {
      return ctorInfo.GetNormalizedInstanceCtorDeclaredTypars(arg00, arg10, arg20);
    }(cenv_1, denv, m);

    iterate((denv_1 = env.DisplayEnv, function (tp) {
      SetTyparRigid(cenv_1.g, denv_1, m, tp);
    }), ctorDeclaredTypars);
    ctorInfo.InstanceCtorVal.SetType(tryMkForallTy(ctorDeclaredTypars, ctorInfo.InstanceCtorVal.TauType));
    const freeChoiceTypars = ListSet.subtract(function (lv1, lv2) {
      return typarEq(lv1, lv2);
    }, generalizedTyparsForRecursiveBlock, ctorDeclaredTypars);
    const thisTyInst = map_1(function (tp_1) {
      return mkTyparTy(tp_1);
    }, ctorDeclaredTypars);

    const accFreeInExpr = function (acc, expr) {
      return unionFreeVars(acc, freeInExpr(CollectLocalsNoCaching, expr));
    };

    const accFreeInBinding = function (acc_1, bind) {
      return accFreeInExpr(acc_1, bind.Expr);
    };

    const accFreeInBindings = function (acc_2, binds) {
      return function (state, list) {
        return fold(accFreeInBinding, state, list);
      }(acc_2, binds);
    };

    let patternInput_1;
    const patternInput = fold(function (tupledArg, dec) {
      const $var361 = dec.tag === 1 ? [0] : dec.tag === 0 ? [1] : [0];

      switch ($var361[0]) {
        case 0:
          return [tupledArg[0], tupledArg[1]];

        case 1:
          return fold(function (tupledArg_1, dec_1) {
            if (dec_1.tag === 1) {
              const staticForcedFieldVars = dec_1.data[1] ? tupledArg_1[0] : unionFreeVars(tupledArg_1[0], freeInExpr(CollectLocalsNoCaching, dec_1.data[0]));
              return [staticForcedFieldVars, tupledArg_1[1]];
            } else {
              const methodBinds = filter(CurriedLambda(function (arg00_1, arg10_1) {
                return IncrClassReprInfo.IsMethodRepr(arg00_1, arg10_1);
              })(cenv_1), dec_1.data[0]);
              const staticForcedFieldVars_1 = dec_1.data[1] ? accFreeInBindings(tupledArg_1[0], methodBinds) : accFreeInBindings(tupledArg_1[0], dec_1.data[0]);
              const instanceForcedFieldVars = accFreeInBindings(tupledArg_1[1], methodBinds);
              return [staticForcedFieldVars_1, instanceForcedFieldVars];
            }
          }, [tupledArg[0], tupledArg[1]], dec.data);
      }
    }, [emptyFreeVars, emptyFreeVars], decs);
    const staticForcedFieldVars_2 = accFreeInBindings(patternInput[0], memberBinds);
    const instanceForcedFieldVars_1 = accFreeInBindings(patternInput[1], memberBinds);
    const staticForcedFieldVars_3 = accFreeInExpr(staticForcedFieldVars_2, inheritsExpr);
    patternInput_1 = [staticForcedFieldVars_3.FreeLocals, instanceForcedFieldVars_1.FreeLocals];

    const TransBind = function (reps, _arg1) {
      if (_arg1.data[0].MustInline) {
        error_1(new _Error(SR.tcLocalClassBindingsCannotBeInline(), _arg1.data[0].Range));
      }

      const rhsExpr = function (arg00_2, arg10_2, arg20_1, arg30) {
        return reps.FixupIncrClassExprPhase2C(arg00_2, arg10_2, arg20_1, arg30);
      }(ctorInfo.InstanceCtorThisVal, safeStaticInitInfo, thisTyInst, _arg1.data[1]);

      const isPriorToSuperInit = ctorInfo.InstanceCtorSafeThisValOpt != null ? valEq(_arg1.data[0], getValue(ctorInfo.InstanceCtorSafeThisValOpt)) : false;
      const matchValue = reps.LookupRepr(_arg1.data[0]);

      if (matchValue.tag === 0) {
        return [[isPriorToSuperInit, function (e) {
          return matchValue.data ? e : mkLetBind(m, new Binding_1(0, [_arg1.data[0], rhsExpr, _arg1.data[2]]), e);
        }], new List()];
      } else if (matchValue.tag === 1) {
        let m_2;
        const matchValue_1 = [_arg1.data[2], rhsExpr];
        const $var362 = matchValue_1[1].tag === 3 ? [0] : matchValue_1[1].tag === 4 ? [0] : matchValue_1[0].tag === 0 ? [1] : [2];

        switch ($var362[0]) {
          case 0:
            m_2 = _arg1.data[0].Range;
            break;

          case 1:
            const m_1 = matchValue_1[0].data;
            m_2 = m_1;
            break;

          case 2:
            m_2 = _arg1.data[0].Range;
            break;
        }

        const assignExpr = function (arg00_3, arg10_3, arg20_2, arg30_1, arg40, arg50) {
          return reps.MakeValueAssign(arg00_3, arg10_3, arg20_2, arg30_1, arg40, arg50);
        }(ctorInfo.InstanceCtorThisVal, thisTyInst, new SafeInitData(1), _arg1.data[0], rhsExpr, m_2);

        let adjustSafeInitFieldExprOpt;

        if (matchValue.data[0]) {
          if (safeStaticInitInfo.tag === 1) {
            adjustSafeInitFieldExprOpt = null;
          } else {
            const setExpr = mkStaticRecdFieldSet(safeStaticInitInfo.data[0], thisTyInst, mkInt(cenv_1.g, m_2, matchValue.data[1]), m_2);

            const setExpr_1 = function (arg00_4, arg10_4, arg20_3, arg30_2) {
              return reps.FixupIncrClassExprPhase2C(arg00_4, arg10_4, arg20_3, arg30_2);
            }(ctorInfo.InstanceCtorThisVal, new SafeInitData(1), thisTyInst, setExpr);

            adjustSafeInitFieldExprOpt = setExpr_1;
          }
        } else {
          adjustSafeInitFieldExprOpt = null;
        }

        return [[isPriorToSuperInit, function (e_1) {
          const e_2 = adjustSafeInitFieldExprOpt != null ? mkCompGenSequential(m_2, getValue(adjustSafeInitFieldExprOpt), e_1) : e_1;
          return mkSequential(new SequencePointInfoForSeq(0), m_2, assignExpr, e_2);
        }], new List()];
      } else {
        const patternInput_2 = rhsExpr.tag === 13 ? [new List(), rhsExpr.data[0], rhsExpr.data[1], tyOfExpr(cenv_1.g, rhsExpr.data[1]), m] : rhsExpr.tag === 4 ? rhsExpr.data[2].tag === 13 ? [rhsExpr.data[1], rhsExpr.data[2].data[0], rhsExpr.data[2].data[1], rhsExpr.data[4], rhsExpr.data[3]] : [rhsExpr.data[1], new List(), rhsExpr.data[2], rhsExpr.data[4], rhsExpr.data[3]] : [new List(), new List(), rhsExpr, tyOfExpr(cenv_1.g, rhsExpr), Expr_get_Range.bind(rhsExpr)()];
        const chooseTps = append(patternInput_2[1], ListSet.subtract(function (lv1_1, lv2_1) {
          return typarEq(lv1_1, lv2_1);
        }, freeChoiceTypars, matchValue.data[1].Typars));
        let patternInput_3;

        if (matchValue.data[0]) {
          patternInput_3 = [patternInput_2[2], patternInput_2[3]];
        } else {
          const e_3 = mkLambda_1(patternInput_2[4], ctorInfo.InstanceCtorThisVal, patternInput_2[2], patternInput_2[3]);
          patternInput_3 = [e_3, tyOfExpr(cenv_1.g, e_3)];
        }

        const rhsExpr_1 = mkTypeLambda(patternInput_2[4], matchValue.data[1].Typars, mkTypeChoose(patternInput_2[4], chooseTps, patternInput_3[0]), patternInput_3[1]);
        return [[isPriorToSuperInit, function (e_4) {
          return e_4;
        }], ofArray([new Binding_1(0, [matchValue.data[1], rhsExpr_1, _arg1.data[2]])])];
      }
    };

    const TransTrueDec = function (isCtorArg, reps_1, dec_2) {
      if (dec_2.tag === 1) {
        const doExpr = function (arg00_5, arg10_5, arg20_4, arg30_3) {
          return reps_1.FixupIncrClassExprPhase2C(arg00_5, arg10_5, arg20_4, arg30_3);
        }(ctorInfo.InstanceCtorThisVal, safeStaticInitInfo, thisTyInst, dec_2.data[0]);

        const binder = function (e_5) {
          return mkSequential(new SequencePointInfoForSeq(0), Expr_get_Range.bind(doExpr)(), doExpr, e_5);
        };

        if (dec_2.data[1]) {
          return [[ofArray([[false, binder]]), new List(), new List()], reps_1];
        } else {
          return [[new List(), ofArray([[false, binder]]), new List()], reps_1];
        }
      } else {
        let patternInput_6;
        const reps_2 = fold(function (rep, bind_1) {
          return rep.ChooseAndAddRepresentation(cenv_1, env, dec_2.data[1], isCtorArg, ctorInfo, patternInput_1[0], patternInput_1[1], bind_1);
        }, reps_1, dec_2.data[0]);

        if (dec_2.data[2]) {
          const reps_3 = fold(function (rep_1, bind_2) {
            return rep_1.ValNowWithRepresentation(bind_2.Var);
          }, reps_2, dec_2.data[0]);
          const patternInput_4 = unzip(map_1(CurriedLambda(TransBind)(reps_3), dec_2.data[0]));
          patternInput_6 = [patternInput_4[0], reps_3, patternInput_4[1]];
        } else {
          const patternInput_5 = unzip(map_1(CurriedLambda(TransBind)(reps_2), dec_2.data[0]));
          const reps_4 = fold(function (rep_2, bind_3) {
            return rep_2.ValNowWithRepresentation(bind_3.Var);
          }, reps_2, dec_2.data[0]);
          patternInput_6 = [patternInput_5[0], reps_4, patternInput_5[1]];
        }

        const methodBinds_1 = concat(patternInput_6[2]);

        if (dec_2.data[1]) {
          return [[patternInput_6[0], new List(), methodBinds_1], patternInput_6[1]];
        } else {
          return [[new List(), patternInput_6[0], methodBinds_1], patternInput_6[1]];
        }
      }
    };

    const TransDec = function (reps_5, dec_3) {
      if (dec_3.tag === 2) {
        const binders = toList(delay(function () {
          if (ctorInfo.InstanceCtorSafeInitInfo.tag === 1) {
            return empty();
          } else {
            const setExpr_2 = mkRecdFieldSetViaExprAddr(exprForVal_4(m, ctorInfo.InstanceCtorThisVal), ctorInfo.InstanceCtorSafeInitInfo.data[0], thisTyInst, mkOne(cenv_1.g, m), m);

            const setExpr_3 = function (arg00_6, arg10_6, arg20_5, arg30_4) {
              return reps_5.FixupIncrClassExprPhase2C(arg00_6, arg10_6, arg20_5, arg30_4);
            }(ctorInfo.InstanceCtorThisVal, safeStaticInitInfo, thisTyInst, setExpr_2);

            const binder_1 = function (e_6) {
              return mkSequential(new SequencePointInfoForSeq(0), Expr_get_Range.bind(setExpr_3)(), setExpr_3, e_6);
            };

            return singleton([false, binder_1]);
          }
        }));
        return [[new List(), binders, new List()], reps_5];
      } else if (dec_3.tag === 0) {
        const patternInput_7 = mapFold(CurriedLambda(TransTrueDec)(false), reps_5, dec_3.data, ofArray);
        const patternInput_8 = unzip3(patternInput_7[0]);
        return [[concat(patternInput_8[0]), concat(patternInput_8[1]), concat(patternInput_8[2])], patternInput_7[1]];
      } else {
        const binders_1 = toList(delay(function () {
          if (ctorInfo.InstanceCtorSafeThisValOpt != null) {
            const setExpr_4 = mkRefCellSet(cenv_1.g, m, ctorInfo.InstanceCtorThisVal.Type, exprForVal_4(m, getValue(ctorInfo.InstanceCtorSafeThisValOpt)), exprForVal_4(m, ctorInfo.InstanceCtorThisVal));

            const setExpr_5 = function (arg00_7, arg10_7, arg20_6, arg30_5) {
              return reps_5.FixupIncrClassExprPhase2C(arg00_7, arg10_7, arg20_6, arg30_5);
            }(ctorInfo.InstanceCtorThisVal, safeStaticInitInfo, thisTyInst, setExpr_4);

            const binder_2 = function (e_7) {
              return mkSequential(new SequencePointInfoForSeq(0), Expr_get_Range.bind(setExpr_5)(), setExpr_5, e_7);
            };

            return singleton([false, binder_2]);
          } else {
            return empty();
          }
        }));
        return [[new List(), binders_1, new List()], reps_5];
      }
    };

    const takenFieldNames = toList(delay(function () {
      return collect_1(function (b) {
        return append_1(singleton(b.Var.CompiledName), delay(function () {
          return append_1(singleton(b.Var.DisplayName), delay(function () {
            return append_1(singleton(b.Var.CoreDisplayName), delay(function () {
              return singleton(b.Var.LogicalName);
            }));
          }));
        }));
      }, memberBinds);
    }));
    const reps_6 = IncrClassReprInfo.Empty(cenv_1.g, takenFieldNames);
    let patternInput_9;
    const binds_1 = map_1(function (v) {
      return mkInvisibleBind(v, exprForVal_4(v.Range, v));
    }, ctorInfo.InstanceCtorArgs);
    patternInput_9 = TransTrueDec(true, reps_6, new IncrClassBindingGroup(0, [binds_1, false, false]));
    const methodBinds1 = patternInput_9[0][2];
    const ctorInitActions1 = patternInput_9[0][1];
    const cctorInitActions1 = patternInput_9[0][0];
    const patternInput_10 = mapFold(TransDec, patternInput_9[1], decs, ofArray);
    const patternInput_11 = unzip3(patternInput_10[0]);
    const cctorInitActions = append(cctorInitActions1, concat(patternInput_11[0]));
    const ctorInitActions = append(ctorInitActions1, concat(patternInput_11[1]));
    const methodBinds_2 = append(methodBinds1, concat(patternInput_11[2]));
    let ctorBody_5;
    const patternInput_12 = partition(function (tupledArg_2) {
      return tupledArg_2[0];
    }, ctorInitActions);
    const ctorBody = mkUnit(cenv_1.g, m);
    const ctorBody_1 = foldBack(function (tupledArg_3, acc_3) {
      return tupledArg_3[1](acc_3);
    }, patternInput_12[1], ctorBody);
    let ctorBody_2;
    let inheritsExpr_1;
    const $var363 = ctorInfo.InstanceCtorSafeThisValOpt != null ? !patternInput_10[1].IsValRepresentedAsLocalVar(getValue(ctorInfo.InstanceCtorSafeThisValOpt)) ? [0, getValue(ctorInfo.InstanceCtorSafeThisValOpt)] : [1] : [1];

    switch ($var363[0]) {
      case 0:
        const ldexpr = function (arg00_8, arg10_8, arg20_7, arg30_6) {
          return patternInput_10[1].FixupIncrClassExprPhase2C(arg00_8, arg10_8, arg20_7, arg30_6);
        }(ctorInfo.InstanceCtorThisVal, safeStaticInitInfo, thisTyInst, exprForVal_4(m, $var363[1]));

        inheritsExpr_1 = mkInvisibleLet(m, $var363[1], ldexpr, inheritsExpr);
        break;

      case 1:
        inheritsExpr_1 = inheritsExpr;
        break;
    }

    const spAtSuperInit = inheritsIsVisible ? new SequencePointInfoForSeq(0) : new SequencePointInfoForSeq(1);
    ctorBody_2 = mkSequential(spAtSuperInit, m, inheritsExpr_1, ctorBody_1);
    const ctorBody_3 = foldBack(function (tupledArg_4, acc_4) {
      return tupledArg_4[1](acc_4);
    }, patternInput_12[0], ctorBody_2);
    const ctorBody_4 = mkMemberLambdas(m, new List(), ctorInfo.InstanceCtorThisVal, ctorInfo.InstanceCtorBaseValOpt, ofArray([ctorInfo.InstanceCtorArgs]), ctorBody_3, cenv_1.g.unit_ty);
    ctorBody_5 = ctorBody_4;
    let cctorBodyOpt;

    if (cctorInitActions.tail == null) {
      cctorBodyOpt = null;
    } else {
      const cctorInitAction = foldBack(function (tupledArg_5, acc_5) {
        return tupledArg_5[1](acc_5);
      }, cctorInitActions, mkUnit(cenv_1.g, m));
      const m_3 = ctorInfo.InstanceCtorThisVal.Range;
      const patternInput_13 = ctorInfo.StaticCtorValInfo.value;
      patternInput_13[1].SetType(tryMkForallTy(ctorDeclaredTypars, patternInput_13[1].TauType));
      const cctorBody = mkMemberLambdas(m_3, new List(), null, null, ofArray([patternInput_13[0]]), cctorInitAction, cenv_1.g.unit_ty);
      cctorBodyOpt = cctorBody;
    }

    return [ctorBody_5, cctorBodyOpt, methodBinds_2, patternInput_10[1]];
  };

  return __exports;
}({});
export const MutRecBindingChecking = function (__exports) {
  const TyconBindingPhase2A = __exports.TyconBindingPhase2A = class TyconBindingPhase2A {
    constructor(tag, data) {
      this.tag = tag | 0;
      this.data = data;
    }

    [_Symbol.reflection]() {
      return {
        type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecBindingChecking.TyconBindingPhase2A",
        interfaces: ["FSharpUnion"],
        cases: [["Phase2AIncrClassCtor", IncrClassChecking.IncrClassCtorLhs], ["Phase2AInherit", SynType, SynExpr, Option(Val), range], ["Phase2AIncrClassBindings", EntityRef, makeGeneric(List, {
          T: SynBinding
        }), "boolean", "boolean", range], ["Phase2AMember", PreCheckingRecursiveBinding], ["Phase2AIncrClassCtorJustAfterSuperInit"], ["Phase2AIncrClassCtorJustAfterLastLet"]]
      };
    }

  };
  setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecBindingChecking.TyconBindingPhase2A", TyconBindingPhase2A);
  const TyconBindingsPhase2A = __exports.TyconBindingsPhase2A = class TyconBindingsPhase2A {
    constructor(tag, data) {
      this.tag = tag | 0;
      this.data = data;
    }

    [_Symbol.reflection]() {
      return {
        type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecBindingChecking.TyconBindingsPhase2A",
        interfaces: ["FSharpUnion"],
        cases: [["TyconBindingsPhase2A", Option(Entity), DeclKind, makeGeneric(List, {
          T: Val
        }), EntityRef, makeGeneric(List, {
          T: Typar
        }), TType, makeGeneric(List, {
          T: TyconBindingPhase2A
        })]]
      };
    }

  };
  setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecBindingChecking.TyconBindingsPhase2A", TyconBindingsPhase2A);
  const TyconBindingPhase2B = __exports.TyconBindingPhase2B = class TyconBindingPhase2B {
    constructor(tag, data) {
      this.tag = tag | 0;
      this.data = data;
    }

    [_Symbol.reflection]() {
      return {
        type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecBindingChecking.TyconBindingPhase2B",
        interfaces: ["FSharpUnion"],
        cases: [["Phase2BIncrClassCtor", IncrClassChecking.IncrClassCtorLhs, Option(Binding_1)], ["Phase2BInherit", Expr, Option(Val)], ["Phase2BIncrClassBindings", makeGeneric(List, {
          T: IncrClassChecking.IncrClassBindingGroup
        })], ["Phase2BMember", "number"], ["Phase2BIncrClassCtorJustAfterSuperInit"], ["Phase2BIncrClassCtorJustAfterLastLet"]]
      };
    }

  };
  setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecBindingChecking.TyconBindingPhase2B", TyconBindingPhase2B);
  const TyconBindingsPhase2B = __exports.TyconBindingsPhase2B = class TyconBindingsPhase2B {
    constructor(tag, data) {
      this.tag = tag | 0;
      this.data = data;
    }

    [_Symbol.reflection]() {
      return {
        type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecBindingChecking.TyconBindingsPhase2B",
        interfaces: ["FSharpUnion"],
        cases: [["TyconBindingsPhase2B", Option(Entity), EntityRef, makeGeneric(List, {
          T: TyconBindingPhase2B
        })]]
      };
    }

  };
  setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecBindingChecking.TyconBindingsPhase2B", TyconBindingsPhase2B);
  const TyconBindingPhase2C = __exports.TyconBindingPhase2C = class TyconBindingPhase2C {
    constructor(tag, data) {
      this.tag = tag | 0;
      this.data = data;
    }

    [_Symbol.reflection]() {
      return {
        type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecBindingChecking.TyconBindingPhase2C",
        interfaces: ["FSharpUnion"],
        cases: [["Phase2CIncrClassCtor", IncrClassChecking.IncrClassCtorLhs, Option(Binding_1)], ["Phase2CInherit", Expr, Option(Val)], ["Phase2CIncrClassBindings", makeGeneric(List, {
          T: IncrClassChecking.IncrClassBindingGroup
        })], ["Phase2CMember", PreInitializationGraphEliminationBinding], ["Phase2CIncrClassCtorJustAfterSuperInit"], ["Phase2CIncrClassCtorJustAfterLastLet"]]
      };
    }

  };
  setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecBindingChecking.TyconBindingPhase2C", TyconBindingPhase2C);
  const TyconBindingsPhase2C = __exports.TyconBindingsPhase2C = class TyconBindingsPhase2C {
    constructor(tag, data) {
      this.tag = tag | 0;
      this.data = data;
    }

    [_Symbol.reflection]() {
      return {
        type: "Microsoft.FSharp.Compiler.TypeChecker.MutRecBindingChecking.TyconBindingsPhase2C",
        interfaces: ["FSharpUnion"],
        cases: [["TyconBindingsPhase2C", Option(Entity), EntityRef, makeGeneric(List, {
          T: TyconBindingPhase2C
        })]]
      };
    }

  };
  setType("Microsoft.FSharp.Compiler.TypeChecker.MutRecBindingChecking.TyconBindingsPhase2C", TyconBindingsPhase2C);

  const TcMutRecBindings_Phase2A_CreateRecursiveValuesAndCheckArgumentPatterns = __exports.TcMutRecBindings_Phase2A_CreateRecursiveValuesAndCheckArgumentPatterns = function (cenv_1, tpenv, envMutRec, mutRecDefns) {
    let patternInput_4;
    const initialOuterState = [tpenv, 0, new List()];
    patternInput_4 = MutRecShapes.mapFoldWithEnv(function (outerState, envForDecls, defn) {
      var overridesOK;

      switch (defn.tag) {
        case 4:
          return [new MutRecShape(4, defn.data), outerState];

        case 3:
          return [new MutRecShape(3, defn.data), outerState];

        case 1:
          const normRecDefns = toList(delay(function () {
            return collect_1(function (matchValue) {
              return singleton(new NormalizedRecBindingDefn(0, [matchValue.data[0], matchValue.data[1], matchValue.data[2], BindingNormalization.NormalizeBinding(new IsObjExprBinding(1), cenv_1, envForDecls, matchValue.data[3])]));
            }, defn.data);
          }));
          const patternInput = mapFold((overridesOK = new OverridesOK(2), function (tupledArg, arg50_) {
            return AnalyzeAndMakeAndPublishRecursiveValue(overridesOK, false, cenv_1, envForDecls, tupledArg[0], tupledArg[1], arg50_);
          }), [outerState[0], outerState[1]], normRecDefns, ofArray);
          const tpenv_1 = patternInput[1][0];
          const recBindIdx = patternInput[1][1] | 0;
          const binds = collect(function (tuple) {
            return tuple[0];
          }, patternInput[0]);
          const defnAs = new MutRecShape(1, binds);
          return [defnAs, [tpenv_1, recBindIdx, append(reverse(binds), outerState[2])]];

        case 0:
          const tyconOpt = defn.data.data[0];
          const tcref = defn.data.data[1];
          const declaredTyconTypars = defn.data.data[2];
          const declKind = defn.data.data[3];
          const binds_1 = defn.data.data[4];
          const isExtrinsic = declKind.Equals(new DeclKind(2));
          const innitalEnvForTycon = MakeInnerEnvForTyconRef(cenv_1, envForDecls, tcref, isExtrinsic);
          const envForTycon = isExtrinsic ? innitalEnvForTycon : AddLocalTyconRefs(true, cenv_1.g, cenv_1.amap, tcref.Range, ofArray([tcref]), innitalEnvForTycon);
          const patternInput_1 = FreshenObjectArgType(cenv_1, tcref.Range, new TyparRigidity(1), tcref, isExtrinsic, declaredTyconTypars);
          const initialInnerState = [null, envForTycon, outerState[0], outerState[1], outerState[2]];
          const patternInput_3 = List_1.collectFold(function (innerState, defn_1) {
            var clo1;

            if (tcref.IsTypeAbbrev) {
              error_1(new _Error(SR.tcTypeAbbreviationsMayNotHaveMembers(), trimRangeToLine(defn_1.data[4])));
            }

            if (tcref.IsEnumTycon ? !defn_1.data[2].Equals(new DeclKind(2)) : false) {
              error_1(new _Error(SR.tcEnumerationsMayNotHaveMembers(), trimRangeToLine(defn_1.data[4])));
            }

            const matchValue_1 = [defn_1.data[3], defn_1.data[0]];
            const $var364 = matchValue_1[0].tag === 2 ? matchValue_1[1].data[1] != null ? [0, matchValue_1[0].data[1], getValue(matchValue_1[1].data[1]).data[2], matchValue_1[0].data[4], getValue(matchValue_1[1].data[1]).data[3], matchValue_1[0].data[2], getValue(matchValue_1[1].data[1]).data[0], matchValue_1[0].data[3], matchValue_1[0].data[0]] : [4, matchValue_1] : matchValue_1[0].tag === 3 ? [1, matchValue_1[0].data[2], matchValue_1[0].data[1], matchValue_1[0].data[3], matchValue_1[0].data[0]] : matchValue_1[0].tag === 4 ? [2, matchValue_1[0].data[2], matchValue_1[0].data[1], matchValue_1[0].data[0], matchValue_1[0].data[3]] : matchValue_1[0].tag === 1 ? [3, matchValue_1[0].data[0], matchValue_1[0].data[1]] : [4, matchValue_1];

            switch ($var364[0]) {
              case 0:
                if ($var364[6].TypeOrMeasureKind.Equals(new TyparKind(1))) {
                  error_1(new _Error(SR.tcMeasureDeclarationsRequireStaticMembers(), $var364[3]));
                }

                const incrClassCtorLhs = IncrClassChecking.TcImplictCtorLhs_Phase2A(cenv_1, innerState[1], innerState[2], $var364[6], $var364[8], $var364[1], $var364[5], $var364[7], $var364[2], $var364[4], $var364[3], patternInput_1[1], patternInput_1[3], patternInput_1[4]);
                const envForTycon_1 = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), incrClassCtorLhs.InstanceCtorDeclaredTypars, innerState[1]);
                const innerState_1 = [incrClassCtorLhs, envForTycon_1, innerState[2], innerState[3], innerState[4]];
                return [ofArray([new TyconBindingPhase2A(0, incrClassCtorLhs)]), innerState_1];

              case 1:
                if (tcref.TypeOrMeasureKind.Equals(new TyparKind(1))) {
                  error_1(new _Error(SR.tcMeasureDeclarationsRequireStaticMembers(), $var364[3]));
                }

                const baseValOpt = defaultArg(innerState[0], null, function (x) {
                  return x.InstanceCtorBaseValOpt;
                });
                const innerState_2 = [innerState[0], innerState[1], innerState[2], innerState[3], innerState[4]];
                return [ofArray([new TyconBindingPhase2A(1, [$var364[4], $var364[2], baseValOpt, $var364[3]]), new TyconBindingPhase2A(4)]), innerState_2];

              case 2:
                const matchValue_2 = [tcref.TypeOrMeasureKind, $var364[2]];
                const $var365 = matchValue_2[0].tag === 1 ? matchValue_2[1] ? [1] : [0] : [1];

                switch ($var365[0]) {
                  case 0:
                    error_1(new _Error(SR.tcMeasureDeclarationsRequireStaticMembers(), $var364[4]));
                    break;

                  case 1:
                    break;
                }

                if (!$var364[2] ? tcref.IsStructOrEnumTycon : false) {
                  const allDo = forAll(function (_arg1) {
                    return _arg1.data[1].tag === 2 ? true : false;
                  }, $var364[3]);

                  if (allDo) {
                    errorR(new Deprecated(SR.tcStructsMayNotContainDoBindings(), trimRangeToLine($var364[4])));
                  } else {
                    errorR(new _Error(SR.tcStructsMayNotContainLetBindings(), trimRangeToLine($var364[4])));
                  }
                }

                if ($var364[2] ? innerState[0] == null : false) {
                  errorR(new _Error(SR.tcStaticLetBindingsRequireClassesWithImplicitConstructors(), $var364[4]));
                }

                const innerState_3 = [innerState[0], innerState[1], innerState[2], innerState[3], innerState[4]];
                return [ofArray([new TyconBindingPhase2A(2, [tcref, $var364[3], $var364[2], $var364[1], $var364[4]])]), innerState_3];

              case 3:
                const bind = BindingNormalization.NormalizeBinding(new IsObjExprBinding(1), cenv_1, innerState[1], $var364[1]);
                const matchValue_3 = tcref.TypeOrMeasureKind;

                if (matchValue_3.tag === 1) {
                  if (bind.data[7].data[0] != null) {
                    if (getValue(bind.data[7].data[0]).IsInstance) {
                      error_1(new _Error(SR.tcMeasureDeclarationsRequireStaticMembers(), $var364[2]));
                    }

                    if (getValue(bind.data[7].data[0]).MemberKind.tag === 1) {
                      error_1(new _Error(SR.tcMeasureDeclarationsRequireStaticMembersNotConstructors(), $var364[2]));
                    }
                  }
                }

                const rbind = new NormalizedRecBindingDefn(0, [defn_1.data[0], defn_1.data[1], defn_1.data[2], bind]);
                const overridesOK_1 = DeclKind.CanOverrideOrImplement(defn_1.data[2]);
                const patternInput_2 = AnalyzeAndMakeAndPublishRecursiveValue(overridesOK_1, false, cenv_1, innerState[1], innerState[2], innerState[3], rbind);
                const tpenv_2 = patternInput_2[1][0];
                const recBindIdx_1 = patternInput_2[1][1] | 0;
                const binds_2 = patternInput_2[0][0];
                const _values = patternInput_2[0][1];
                const cbinds = toList(delay(function () {
                  return map_2(function (rbind_1) {
                    return new TyconBindingPhase2A(3, rbind_1);
                  }, binds_2);
                }));
                const innerState_4 = [innerState[0], innerState[1], tpenv_2, recBindIdx_1, append(reverse(binds_2), innerState[4])];
                return [cbinds, innerState_4];

              case 4:
                return error_1(new InternalError((clo1 = toText(printf("Unexpected definition %A")), function (tupledArg_1) {
                  return clo1([tupledArg_1[0], tupledArg_1[1]]);
                })($var364[1]), defn_1.data[4]));
            }
          }, initialInnerState, binds_1);
          const uncheckedBindsRev = patternInput_3[1][4];
          const tpenv_3 = patternInput_3[1][2];
          const recBindIdx_2 = patternInput_3[1][3] | 0;
          const _envForTycon = patternInput_3[1][1];
          let defnAs_1;
          const $var366 = patternInput_3[0].tail != null ? patternInput_3[0].head.tag === 0 ? [0, patternInput_3[0].head, patternInput_3[0].tail] : [1, patternInput_3[0]] : [1, patternInput_3[0]];

          switch ($var366[0]) {
            case 0:
              const rest = exists_1(function (_arg2) {
                return _arg2.tag === 4 ? true : false;
              }, $var366[2]) ? $var366[2] : new List(new TyconBindingPhase2A(4), $var366[2]);
              let rest_1;

              const isAfter = function (b) {
                switch (b.tag) {
                  case 1:
                  case 4:
                    return false;

                  case 2:
                    return exists_1(function (_arg3) {
                      return _arg3.data[1].tag === 2 ? true : false;
                    }, b.data[1]);

                  case 5:
                  case 3:
                    return true;

                  default:
                    return false;
                }
              };

              const restRev = reverse(rest);

              const afterRev = function (list) {
                return toList(takeWhile(isAfter, list));
              }(restRev);

              const beforeRev = function (list_1) {
                return toList(skipWhile(isAfter, list_1));
              }(restRev);

              rest_1 = toList(delay(function () {
                return append_1(reverse(beforeRev), delay(function () {
                  return append_1(singleton(new TyconBindingPhase2A(5)), delay(function () {
                    return reverse(afterRev);
                  }));
                }));
              }));
              defnAs_1 = new List($var366[1], rest_1);
              break;

            case 1:
              defnAs_1 = $var366[1];
              break;
          }

          const prelimRecValues = toList(delay(function () {
            return collect_1(function (x_1) {
              return x_1.tag === 3 ? singleton(x_1.data.RecBindingInfo.Val) : empty();
            }, defnAs_1);
          }));
          const defnAs_2 = new MutRecShape(0, new TyconBindingsPhase2A(0, [tyconOpt, declKind, prelimRecValues, tcref, patternInput_1[1], patternInput_1[4], defnAs_1]));
          return [defnAs_2, [tpenv_3, recBindIdx_2, uncheckedBindsRev]];

        default:
          throw new Error("unreachable");
      }
    }, initialOuterState, envMutRec, mutRecDefns);
    const uncheckedBindsRev_1 = patternInput_4[1][2];
    const tpenv_4 = patternInput_4[1][0];
    const uncheckedRecBinds = reverse(uncheckedBindsRev_1);
    return [patternInput_4[0], uncheckedRecBinds, tpenv_4];
  };

  const TcMutRecBindings_Phase2B_TypeCheckAndIncrementalGeneralization = __exports.TcMutRecBindings_Phase2B_TypeCheckAndIncrementalGeneralization = function (cenv_1, tpenv, envInitial, envMutRec, defnsAs, uncheckedRecBinds, scopem) {
    let patternInput_10;
    const uncheckedRecBindsTable = create(map_1(function (rbind) {
      return [rbind.RecBindingInfo.Val.Stamp, rbind];
    }, uncheckedRecBinds), new Comparer((x, y) => x.CompareTo(y)));
    const initialOuterState = [tpenv, new List(), new List(), uncheckedRecBindsTable, envInitial];
    patternInput_10 = MutRecShapes.mapFoldWithEnv(function (outerState, envForDecls, defnsA) {
      switch (defnsA.tag) {
        case 4:
          return [new MutRecShape(4, defnsA.data), outerState];

        case 3:
          return [new MutRecShape(3, defnsA.data), outerState];

        case 1:
          let patternInput_1;
          const initialInnerState = [outerState[0], envForDecls, outerState[4], outerState[1], outerState[2], outerState[3]];
          patternInput_1 = mapFold(function (innerState, rbind_1) {
            const patternInput = TcLetrecBinding(cenv_1, innerState[1], scopem, new List(), null, innerState[2], innerState[3], innerState[4], innerState[0], innerState[5], rbind_1);
            const innerState_1 = [innerState[0], innerState[1], patternInput[0], patternInput[1], patternInput[2], patternInput[4]];
            return [rbind_1.RecBindingInfo.Index, innerState_1];
          }, initialInnerState, defnsA.data, ofArray);
          const uncheckedRecBindsTable_1 = patternInput_1[1][5];
          const tpenv_1 = patternInput_1[1][0];
          const preGeneralizationRecBinds = patternInput_1[1][4];
          const generalizedRecBinds = patternInput_1[1][3];
          const envNonRec = patternInput_1[1][2];
          const outerState_1 = [tpenv_1, generalizedRecBinds, preGeneralizationRecBinds, uncheckedRecBindsTable_1, envNonRec];
          return [new MutRecShape(1, patternInput_1[0]), outerState_1];

        case 0:
          const tyconOpt = defnsA.data.data[0];
          const thisTy = defnsA.data.data[5];
          const tcref = defnsA.data.data[3];
          const defnAs = defnsA.data.data[6];
          const declKind = defnsA.data.data[1];
          const copyOfTyconTypars = defnsA.data.data[4];
          const isExtrinsic = declKind.Equals(new DeclKind(2));
          const envForTycon = MakeInnerEnvForTyconRef(cenv_1, envForDecls, tcref, isExtrinsic);
          const envForTycon_1 = isExtrinsic ? envForTycon : AddLocalTyconRefs(true, cenv_1.g, cenv_1.amap, tcref.Range, ofArray([tcref]), envForTycon);
          let envForTycon_2;
          const eCtorInfo = InitialImplicitCtorInfo();
          envForTycon_2 = new TcEnv(envForTycon_1.eNameResEnv, envForTycon_1.eUngeneralizableItems, envForTycon_1.ePath, envForTycon_1.eCompPath, envForTycon_1.eAccessPath, envForTycon_1.eAccessRights, envForTycon_1.eInternalsVisibleCompPaths, envForTycon_1.eModuleOrNamespaceTypeAccumulator, envForTycon_1.eContextInfo, envForTycon_1.eFamilyType, eCtorInfo, envForTycon_1.eCallerMemberName);
          const reqdThisValTyOpt = thisTy;
          let patternInput_9;
          const initialInnerState_1 = [outerState[0], envForTycon_2, envForTycon_2, outerState[4], outerState[1], outerState[2], outerState[3]];
          patternInput_9 = mapFold(function (innerState_2, defnA) {
            switch (defnA.tag) {
              case 1:
                const patternInput_2 = TcType(cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(0), new ItemOccurence(1), innerState_2[1], innerState_2[0], defnA.data[0]);
                const patternInput_3 = TcNewExpr(cenv_1, innerState_2[1], patternInput_2[1], patternInput_2[0], defnA.data[0].Range, true, defnA.data[1], defnA.data[3]);
                const envInstance = defnA.data[2] == null ? innerState_2[1] : AddLocalVal(cenv_1.tcSink, scopem, getValue(defnA.data[2]), innerState_2[1]);
                const envNonRec_1 = defnA.data[2] == null ? innerState_2[3] : AddLocalVal(cenv_1.tcSink, scopem, getValue(defnA.data[2]), innerState_2[3]);
                const innerState_3 = [patternInput_3[1], envInstance, innerState_2[2], envNonRec_1, innerState_2[4], innerState_2[5], innerState_2[6]];
                return [new TyconBindingPhase2B(1, [patternInput_3[0], defnA.data[2]]), innerState_3];

              case 2:
                const envForBinding = defnA.data[2] ? innerState_2[2] : innerState_2[1];
                let patternInput_7;

                if (defnA.data[3]) {
                  const binds = map_1(function (bind) {
                    return new RecDefnBindingInfo(0, [ExprContainerInfo, new NewSlotsOK(1), new DeclKind(3, defnA.data[2]), bind]);
                  }, defnA.data[1]);
                  const patternInput_4 = TcLetrec(new OverridesOK(2), cenv_1, envForBinding, innerState_2[0], binds, scopem, scopem);
                  const bindRs = ofArray([new IncrClassChecking.IncrClassBindingGroup(0, [patternInput_4[0], defnA.data[2], true])]);
                  patternInput_7 = [patternInput_4[0], bindRs, patternInput_4[1], patternInput_4[2]];
                } else {
                  const patternInput_5 = TcLetBindings(cenv_1, envForBinding, ExprContainerInfo, new DeclKind(3, defnA.data[2]), innerState_2[0], defnA.data[1], defnA.data[4], scopem);
                  const patternInput_6 = unzip(map_1(function (_arg1) {
                    return _arg1.tag === 2 ? [ofArray([_arg1.data[0]]), new IncrClassChecking.IncrClassBindingGroup(0, [ofArray([_arg1.data[0]]), defnA.data[2], false])] : _arg1.tag === 3 ? [new List(), new IncrClassChecking.IncrClassBindingGroup(1, [_arg1.data[0], defnA.data[2]])] : error_1(new InternalError("unexpected definition kind", defnA.data[0].Range));
                  }, patternInput_5[0]));
                  patternInput_7 = [concat(patternInput_6[0]), patternInput_6[1], patternInput_5[1], patternInput_5[2]];
                }

                const envNonRec_2 = fold(function (acc, bind_1) {
                  return AddLocalValPrimitive(bind_1.Var, acc);
                }, innerState_2[3], patternInput_7[0]);

                for (let bind_2 of patternInput_7[0]) {
                  if (!defnA.data[2] ? HasFSharpAttributeOpt(cenv_1.g, cenv_1.g.attrib_DllImportAttribute, bind_2.Var.Attribs) : false) {
                    errorR(new _Error(SR.tcDllImportNotAllowed(), bind_2.Var.Range));
                  }

                  const nm = bind_2.Var.DisplayName;
                  const ty = generalizedTyconRef(defnA.data[0]);
                  const matchValue = [TryFindIntrinsicMethInfo(cenv_1.infoReader, bind_2.Var.Range, envNonRec_2.eAccessRights, nm, ty), TryFindPropInfo(cenv_1.infoReader, bind_2.Var.Range, envNonRec_2.eAccessRights, nm, ty)];
                  const $var367 = matchValue[0].tail == null ? matchValue[1].tail == null ? [0] : [1] : [1];

                  switch ($var367[0]) {
                    case 0:
                      break;

                    case 1:
                      errorR(new _Error(SR.tcMemberAndLocalClassBindingHaveSameName(nm), bind_2.Var.Range));
                      break;
                  }
                }

                const envInstance_1 = defnA.data[2] ? foldBack(function (b, e) {
                  return AddLocalVal(cenv_1.tcSink, scopem, b.Var, e);
                }, patternInput_7[0], innerState_2[1]) : patternInput_7[2];
                const envStatic = defnA.data[2] ? patternInput_7[2] : innerState_2[2];
                const innerState_4 = [patternInput_7[3], envInstance_1, envStatic, envNonRec_2, innerState_2[4], innerState_2[5], innerState_2[6]];
                return [new TyconBindingPhase2B(2, patternInput_7[1]), innerState_4];

              case 4:
                const innerState_5 = [innerState_2[0], innerState_2[1], innerState_2[2], innerState_2[3], innerState_2[4], innerState_2[5], innerState_2[6]];
                return [new TyconBindingPhase2B(4), innerState_5];

              case 5:
                const innerState_6 = [innerState_2[0], innerState_2[1], innerState_2[2], innerState_2[3], innerState_2[4], innerState_2[5], innerState_2[6]];
                return [new TyconBindingPhase2B(5), innerState_6];

              case 3:
                const v = defnA.data.RecBindingInfo.Val;
                const envForBinding_1 = v.IsInstanceMember ? innerState_2[1] : innerState_2[2];
                const patternInput_8 = TcLetrecBinding(cenv_1, envForBinding_1, scopem, copyOfTyconTypars, reqdThisValTyOpt, innerState_2[3], innerState_2[4], innerState_2[5], innerState_2[0], innerState_2[6], defnA.data);
                const innerState_7 = [innerState_2[0], innerState_2[1], innerState_2[2], patternInput_8[0], patternInput_8[1], patternInput_8[2], patternInput_8[4]];
                return [new TyconBindingPhase2B(3, defnA.data.RecBindingInfo.Index), innerState_7];

              default:
                const envInstance_2 = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), defnA.data.InstanceCtorDeclaredTypars, innerState_2[1]);
                const envStatic_1 = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), defnA.data.InstanceCtorDeclaredTypars, innerState_2[2]);
                const envInstance_3 = defnA.data.InstanceCtorSafeThisValOpt == null ? envInstance_2 : AddLocalVal(cenv_1.tcSink, scopem, getValue(defnA.data.InstanceCtorSafeThisValOpt), envInstance_2);
                const envInstance_4 = foldBack(function (v_1, env) {
                  return AddLocalValPrimitive(v_1, env);
                }, defnA.data.InstanceCtorArgs, envInstance_3);
                const envNonRec_3 = defnA.data.InstanceCtorSafeThisValOpt == null ? innerState_2[3] : AddLocalVal(cenv_1.tcSink, scopem, getValue(defnA.data.InstanceCtorSafeThisValOpt), innerState_2[3]);
                const envNonRec_4 = foldBack(function (v_2, env_1) {
                  return AddLocalValPrimitive(v_2, env_1);
                }, defnA.data.InstanceCtorArgs, envNonRec_3);
                const safeThisValBindOpt = TcLetrecComputeCtorSafeThisValBind(cenv_1, defnA.data.InstanceCtorSafeThisValOpt);
                const innerState_8 = [innerState_2[0], envInstance_4, envStatic_1, envNonRec_4, innerState_2[4], innerState_2[5], innerState_2[6]];
                return [new TyconBindingPhase2B(0, [defnA.data, safeThisValBindOpt]), innerState_8];
            }
          }, initialInnerState_1, defnAs, ofArray);
          const uncheckedRecBindsTable_2 = patternInput_9[1][6];
          const tpenv_2 = patternInput_9[1][0];
          const preGeneralizationRecBinds_1 = patternInput_9[1][5];
          const generalizedRecBinds_1 = patternInput_9[1][4];
          const envNonRec_5 = patternInput_9[1][3];
          const defnBs = new MutRecShape(0, new TyconBindingsPhase2B(0, [tyconOpt, tcref, patternInput_9[0]]));
          const outerState_2 = [tpenv_2, generalizedRecBinds_1, preGeneralizationRecBinds_1, uncheckedRecBindsTable_2, envNonRec_5];
          return [defnBs, outerState_2];

        default:
          throw new Error("unreachable");
      }
    }, initialOuterState, envMutRec, defnsAs);
    const tpenv_3 = patternInput_10[1][0];
    const preGeneralizationRecBinds_2 = patternInput_10[1][2];
    const generalizedRecBinds_2 = patternInput_10[1][1];
    return [patternInput_10[0], generalizedRecBinds_2, tpenv_3];
  };

  const TcMutRecBindings_Phase2C_FixupRecursiveReferences = __exports.TcMutRecBindings_Phase2C_FixupRecursiveReferences = function (cenv_1, denv, defnsBs, generalizedTyparsForRecursiveBlock, generalizedRecBinds, scopem) {
    const generalizedBindingsMap = create(map_1(function (pgrbind) {
      return [pgrbind.RecBindingInfo.Index, pgrbind];
    }, generalizedRecBinds), new Comparer(comparePrimitives));
    return MutRecShapes.mapTyconsAndLets(function (_arg1) {
      const defnCs = map_1(function (defnB) {
        switch (defnB.tag) {
          case 1:
            return new TyconBindingPhase2C(1, [defnB.data[0], defnB.data[1]]);

          case 2:
            return new TyconBindingPhase2C(2, defnB.data);

          case 4:
            return new TyconBindingPhase2C(4);

          case 5:
            return new TyconBindingPhase2C(5);

          case 3:
            const generalizedBinding = generalizedBindingsMap.get(defnB.data);
            const vxbind = TcLetrecAdjustMemberForSpecialVals(cenv_1, generalizedBinding);
            const pgbrind = FixupLetrecBind(cenv_1, denv, generalizedTyparsForRecursiveBlock, vxbind);
            return new TyconBindingPhase2C(3, pgbrind);

          default:
            const valscheme = ChooseCanonicalValSchemeAfterInference(cenv_1.g, denv, defnB.data[0].InstanceCtorValScheme, scopem);
            AdjustRecType(cenv_1, defnB.data[0].InstanceCtorVal, valscheme);
            return new TyconBindingPhase2C(0, [defnB.data[0], defnB.data[1]]);
        }
      }, _arg1.data[2]);
      return new TyconBindingsPhase2C(0, [_arg1.data[0], _arg1.data[1], defnCs]);
    }, function (bindIdxs) {
      return toList(delay(function () {
        return collect_1(function (idx) {
          const generalizedBinding_1 = generalizedBindingsMap.get(idx);
          const vxbind_1 = TcLetrecAdjustMemberForSpecialVals(cenv_1, generalizedBinding_1);
          return singleton(FixupLetrecBind(cenv_1, denv, generalizedTyparsForRecursiveBlock, vxbind_1));
        }, bindIdxs);
      }));
    }, defnsBs);
  };

  const TcMutRecBindings_Phase2D_ExtractImplicitFieldAndMethodBindings = __exports.TcMutRecBindings_Phase2D_ExtractImplicitFieldAndMethodBindings = function (cenv_1, envMutRec, tpenv, denv, generalizedTyparsForRecursiveBlock, defnsCs) {
    return MutRecShapes.mapTyconsWithEnv(function (envForDecls, _arg1) {
      var ctorValueExprBinding;
      var rbind;
      var patternInput_3;
      var cctorValueExprBinding;
      var rbind_1;
      const $var368 = _arg1.data[2].tail != null ? _arg1.data[2].head.tag === 0 ? [0, _arg1.data[2].tail, _arg1.data[2].head.data[0], _arg1.data[2].head.data[1]] : [1, _arg1.data[2]] : [1, _arg1.data[2]];

      switch ($var368[0]) {
        case 0:
          let safeStaticInitInfo;
          const needsSafeStaticInit = !cenv_1.g.compilingFslib;
          const hasStaticBindings = exists_1(function (_arg1_1) {
            return _arg1_1.tag === 2 ? exists_1(function (_arg2) {
              return _arg2.tag === 0 ? _arg2.data[1] ? exists_1($var369 => function (value) {
                return !value;
              }(CurriedLambda(function (arg00, arg10) {
                return IncrClassChecking.IncrClassReprInfo.IsMethodRepr(arg00, arg10);
              })(cenv_1)($var369)), _arg2.data[0]) : false : false;
            }, _arg1_1.data) : false;
          }, $var368[1]);

          if (needsSafeStaticInit ? hasStaticBindings : false) {
            const rfield = MakeSafeInitField(cenv_1.g, envForDecls, _arg1.data[1].Range, true);
            safeStaticInitInfo = new SafeInitData(0, [mkRecdFieldRef(_arg1.data[1], rfield.Name), rfield]);
          } else {
            safeStaticInitInfo = new SafeInitData(1);
          }

          let patternInput_1;
          const matchValue = partition(function (_arg3) {
            return _arg3.tag === 1 ? true : false;
          }, $var368[1]);
          const $var370 = matchValue[0].tail != null ? matchValue[0].head.tag === 1 ? matchValue[0].tail.tail == null ? [0, matchValue[0].head.data[1], matchValue[1], matchValue[0].head.data[0]] : [1] : [1] : [1];

          switch ($var370[0]) {
            case 0:
              patternInput_1 = [$var370[3], true, $var370[1], $var370[2]];
              break;

            case 1:
              if ($var368[2].TyconRef.IsStructOrEnumTycon) {
                patternInput_1 = [mkUnit(cenv_1.g, $var368[2].TyconRef.Range), false, null, $var368[1]];
              } else {
                const patternInput = TcNewExpr(cenv_1, envForDecls, tpenv, cenv_1.g.obj_ty, null, true, new SynExpr(2, [new SynConst(0), $var368[2].TyconRef.Range]), $var368[2].TyconRef.Range);
                patternInput_1 = [patternInput[0], false, null, $var368[1]];
              }

              break;
          }

          const envForTycon = MakeInnerEnvForTyconRef(cenv_1, envForDecls, $var368[2].TyconRef, false);
          const localDecs = filter(function (_arg4) {
            const $var371 = _arg4.tag === 2 ? [0] : _arg4.tag === 4 ? [0] : _arg4.tag === 5 ? [0] : [1];

            switch ($var371[0]) {
              case 0:
                return true;

              case 1:
                return false;
            }
          }, patternInput_1[3]);
          const memberBindsWithFixups = choose_1(function (_arg5) {
            return _arg5.tag === 3 ? _arg5.data : null;
          }, patternInput_1[3]);
          const localDecs_1 = $var368[3] != null ? new List(new TyconBindingPhase2C(2, ofArray([new IncrClassChecking.IncrClassBindingGroup(0, [ofArray([getValue($var368[3])]), false, false])])), localDecs) : localDecs;
          let patternInput_2;
          const localDecs_2 = toList(delay(function () {
            return collect_1(function (localDec) {
              return localDec.tag === 2 ? singleton(new IncrClassChecking.IncrClassConstructionBindingsPhase2C(0, localDec.data)) : localDec.tag === 4 ? singleton(new IncrClassChecking.IncrClassConstructionBindingsPhase2C(1)) : localDec.tag === 5 ? singleton(new IncrClassChecking.IncrClassConstructionBindingsPhase2C(2)) : empty();
            }, localDecs_1);
          }));
          const memberBinds = map_1(function (x) {
            return x.Binding;
          }, memberBindsWithFixups);
          patternInput_2 = IncrClassChecking.MakeCtorForIncrClassConstructionPhase2C(cenv_1, envForTycon, $var368[2], patternInput_1[0], patternInput_1[1], localDecs_2, memberBinds, generalizedTyparsForRecursiveBlock, safeStaticInitInfo);
          const ctorValueExprBindings = append(ofArray([(ctorValueExprBinding = new Binding_1(0, [$var368[2].InstanceCtorVal, patternInput_2[0], new SequencePointInfoForBinding(3)]), rbind = new PostBindCtorThisVarRefCellRecursiveBinding($var368[2].InstanceCtorValScheme, ctorValueExprBinding), FixupLetrecBind(cenv_1, envForDecls.DisplayEnv, generalizedTyparsForRecursiveBlock, rbind))]), patternInput_2[1] != null ? ofArray([(patternInput_3 = $var368[2].StaticCtorValInfo.value, cctorValueExprBinding = new Binding_1(0, [patternInput_3[1], getValue(patternInput_2[1]), new SequencePointInfoForBinding(3)]), rbind_1 = new PostBindCtorThisVarRefCellRecursiveBinding(patternInput_3[2], cctorValueExprBinding), FixupLetrecBind(cenv_1, envForDecls.DisplayEnv, generalizedTyparsForRecursiveBlock, rbind_1))]) : new List());
          patternInput_2[3].PublishIncrClassFields(cenv_1, denv, envForTycon.eAccessPath, $var368[2], safeStaticInitInfo);
          const memberBindsWithFixups_1 = map_1(function (pgrbind) {
            const thisValOpt = GetInstanceMemberThisVariable(pgrbind.Binding.data[0], pgrbind.Binding.data[1]);
            const thisTyInst = map_1(function (tp) {
              return mkTyparTy(tp);
            }, List_1.take($var368[2].TyconRef.Typars(pgrbind.Binding.data[0].Range).length, pgrbind.Binding.data[0].Typars));

            const x_1 = function (arg00_1, arg10_1, arg20, arg30) {
              return patternInput_2[3].FixupIncrClassExprPhase2C(arg00_1, arg10_1, arg20, arg30);
            }(thisValOpt, safeStaticInitInfo, thisTyInst, pgrbind.Binding.data[1]);

            const Binding = new Binding_1(0, [pgrbind.Binding.data[0], x_1, pgrbind.Binding.data[2]]);
            return new PreInitializationGraphEliminationBinding(pgrbind.FixupPoints, Binding);
          }, memberBindsWithFixups);
          return [_arg1.data[0], append(ctorValueExprBindings, memberBindsWithFixups_1), patternInput_2[2]];

        case 1:
          const memberBindsWithFixups_2 = choose_1(function (_arg6) {
            return _arg6.tag === 3 ? _arg6.data : null;
          }, $var368[1]);
          return [_arg1.data[0], memberBindsWithFixups_2, new List()];
      }
    }, envMutRec, defnsCs);
  };

  const TcModuleAbbrevDecl = __exports.TcModuleAbbrevDecl = function (cenv_1, scopem, env, id, p, m) {
    const resolved = p.tail != null ? ResolveLongIndentAsModuleOrNamespace(cenv_1.tcSink, new ResultCollectionSettings(0), cenv_1.amap, m, true, new FullyQualifiedFlag(1), env.eNameResEnv, env.eAccessRights, p.head, p.tail, false) : new ResultOrException(0, new List());
    const mvvs = ResultOrExceptionModule.ForceRaise(resolved);

    if (mvvs.tail == null) {
      return env;
    } else {
      const modrefs = map_1(function (tupledArg) {
        return p23(tupledArg[0], tupledArg[1], tupledArg[2]);
      }, mvvs);

      if (!(modrefs.tail == null) ? forAll(function (modref) {
        return modref.IsNamespace;
      }, modrefs) : false) {
        errorR(new _Error(SR.tcModuleAbbreviationForNamespace(fullDisplayTextOfModRef(modrefs.head)), m));
      }

      const modrefs_1 = filter(function (mvv) {
        return !mvv.IsNamespace;
      }, modrefs);

      if (modrefs_1.tail == null) {
        return env;
      } else {
        iterate(function (modref_1) {
          CommitOperationResult(CheckEntityAttributes(cenv_1.g, modref_1, m));
        }, modrefs_1);
        const env_1 = AddModuleAbbreviationAndReport(cenv_1.tcSink, scopem, id, modrefs_1, env);
        return env_1;
      }
    }
  };

  const TcMutRecDefns_UpdateNSContents = __exports.TcMutRecDefns_UpdateNSContents = function (mutRecNSInfo) {
    const $var372 = mutRecNSInfo != null ? getValue(mutRecNSInfo)[0] != null ? [0, getValue(getValue(mutRecNSInfo)[0]), getValue(mutRecNSInfo)[1]] : [1] : [1];

    switch ($var372[0]) {
      case 0:
        $var372[1].entity_modul_contents = new MaybeLazy(0, $var372[2].contents);
        break;

      case 1:
        break;
    }
  };

  const TcMutRecDefns_UpdateModuleContents = __exports.TcMutRecDefns_UpdateModuleContents = function (mutRecNSInfo, defns) {
    MutRecShapes.iterModules(function (tupledArg) {
      tupledArg[0].data[1].entity_modul_contents = new MaybeLazy(0, tupledArg[0].data[0].contents);
    }, defns);
    TcMutRecDefns_UpdateNSContents(mutRecNSInfo);
  };

  const TcMutRecDefns_ComputeEnvs = __exports.TcMutRecDefns_ComputeEnvs = function (getTyconOpt, getVals, cenv_1, report, scopem, m, envInitial, mutRecShape) {
    return MutRecShapes.computeEnvs(function (envAbove, _arg1) {
      return MakeInnerEnvWithAcc(envAbove, _arg1.data[1].Id, _arg1.data[0], _arg1.data[1].ModuleOrNamespaceType.ModuleOrNamespaceKind);
    }, function (envAbove_1, decls) {
      const tycons = choose_1(function (_arg1_1) {
        return _arg1_1.tag === 0 ? getTyconOpt(_arg1_1.data) : null;
      }, decls);
      const mspecs = choose_1(function (_arg2) {
        if (_arg2.tag === 2) {
          const mspec = _arg2.data[0].data[1];
          return mspec;
        } else {
          return null;
        }
      }, decls);
      const moduleAbbrevs = choose_1(function (_arg3) {
        if (_arg3.tag === 3) {
          const mp = _arg3.data.data[1];
          const m_1 = _arg3.data.data[2];
          const id = _arg3.data.data[0];
          return [id, mp, m_1];
        } else {
          return null;
        }
      }, decls);
      const opens = choose_1(function (_arg4) {
        if (_arg4.tag === 4) {
          const mp_1 = _arg4.data.data[0];
          const m_2 = _arg4.data.data[1];
          return [mp_1, m_2];
        } else {
          return null;
        }
      }, decls);
      const lets = collect(function (_arg5) {
        return _arg5.tag === 1 ? getVals(_arg5.data) : new List();
      }, decls);
      const exns = filter(function (tycon) {
        return tycon.IsExceptionDecl;
      }, tycons);
      const envForDecls = fold(CurriedLambda(report ? function (g, amap, m_3, env, modul) {
        return AddLocalSubModuleAndReport(cenv_1.tcSink, scopem, g, amap, m_3, env, modul);
      } : function (g_1, amap_1, m_4, env_1, modul_1) {
        return AddLocalSubModule(g_1, amap_1, m_4, env_1, modul_1);
      })(cenv_1.g, cenv_1.amap, m), envAbove_1, mspecs);
      const envForDecls_1 = fold(function (env_2, tupledArg) {
        return TcOpenDecl(cenv_1.tcSink, cenv_1.g, cenv_1.amap, tupledArg[1], scopem, env_2, tupledArg[0]);
      }, envForDecls, opens);
      const envForDecls_2 = (report ? function (g_2, amap_2, m_5, tycons_1, env_3) {
        return AddLocalTyconsAndReport(cenv_1.tcSink, scopem, g_2, amap_2, m_5, tycons_1, env_3);
      } : function (g_3, amap_3, m_6, tycons_2, env_4) {
        return AddLocalTycons(g_3, amap_3, m_6, tycons_2, env_4);
      })(cenv_1.g, cenv_1.amap, m, tycons, envForDecls_1);
      const envForDecls_3 = fold(function (env_5, exnc) {
        return AddLocalExnDefnAndReport(cenv_1.tcSink, scopem, env_5, exnc);
      }, envForDecls_2, exns);
      const envForDecls_4 = fold(function (env_6, modul_2) {
        return AddLocalSubModule(cenv_1.g, cenv_1.amap, m, env_6, modul_2);
      }, envForDecls_3, mspecs);
      const envForDecls_5 = fold(function (env_7, tupledArg_1) {
        return TcModuleAbbrevDecl(cenv_1, scopem, env_7, tupledArg_1[0], tupledArg_1[1], tupledArg_1[2]);
      }, envForDecls_4, moduleAbbrevs);
      const envForDecls_6 = AddLocalVals(cenv_1.tcSink, scopem, lets, envForDecls_5);
      return envForDecls_6;
    }, envInitial, mutRecShape);
  };

  const TcMutRecDefns_Phase2_Bindings = __exports.TcMutRecDefns_Phase2_Bindings = function (cenv_1, envInitial, tpenv, bindsm, scopem, mutRecNSInfo, envMutRecPrelimWithReprs, mutRecDefns) {
    var getTyconOpt;
    var getVals;
    const denv = envMutRecPrelimWithReprs.DisplayEnv;
    const patternInput = TcMutRecBindings_Phase2A_CreateRecursiveValuesAndCheckArgumentPatterns(cenv_1, tpenv, envMutRecPrelimWithReprs, mutRecDefns);
    MutRecShapes.iterTycons(function (_arg1) {
      _arg1.data[5]();
    }, mutRecDefns);
    TcMutRecDefns_UpdateModuleContents(mutRecNSInfo, patternInput[0]);
    let patternInput_1;
    const tupledArg = (getTyconOpt = function (_arg2) {
      return _arg2.data[0];
    }, getVals = function (binds) {
      return toList(delay(function () {
        return map_2(function (bind) {
          return bind.RecBindingInfo.Val;
        }, binds);
      }));
    }, function (envInitial_1, mutRecShape) {
      return TcMutRecDefns_ComputeEnvs(getTyconOpt, getVals, cenv_1, false, scopem, scopem, envInitial_1, mutRecShape);
    })(envInitial, MutRecShapes.dropEnvs(patternInput[0]));
    let func;

    const f1 = function (envForDecls, decls) {
      const prelimRecValues_1 = collect(function (_arg1_1) {
        if (_arg1_1.tag === 0) {
          const prelimRecValues = _arg1_1.data.data[2];
          return prelimRecValues;
        } else if (_arg1_1.tag === 1) {
          return toList(delay(function () {
            return map_2(function (bind_1) {
              return bind_1.RecBindingInfo.Val;
            }, _arg1_1.data);
          }));
        } else {
          return new List();
        }
      }, decls);
      const ctorVals = collect(function (_arg3) {
        return toList(delay(function () {
          return collect_1(function (defnB) {
            return defnB.tag === 0 ? singleton(defnB.data.InstanceCtorVal) : empty();
          }, _arg3.data[6]);
        }));
      }, MutRecShapes.topTycons(decls));

      const envForDeclsUpdated = function (env) {
        return AddLocalVals(cenv_1.tcSink, scopem, ctorVals, env);
      }(function (env_1) {
        return AddLocalVals(cenv_1.tcSink, scopem, prelimRecValues_1, env_1);
      }(envForDecls));

      return envForDeclsUpdated;
    };

    func = function (env_2, xs) {
      return MutRecShapes.extendEnvs(f1, env_2, xs);
    };

    patternInput_1 = func(tupledArg[0], tupledArg[1]);
    const patternInput_2 = TcMutRecBindings_Phase2B_TypeCheckAndIncrementalGeneralization(cenv_1, patternInput[2], envInitial, patternInput_1[0], patternInput_1[1], patternInput[1], scopem);
    const generalizedTyparsForRecursiveBlock = unionGeneralizedTypars(map_1(function (pgrbind) {
      return pgrbind.GeneralizedTypars;
    }, patternInput_2[1]));
    const allExtraGeneralizableTypars = collect(function (_arg4) {
      return toList(delay(function () {
        return append_1(_arg4.data[4], delay(function () {
          return collect_1(function (defnA) {
            return defnA.tag === 3 ? defnA.data.RecBindingInfo.EnclosingDeclaredTypars : empty();
          }, _arg4.data[6]);
        }));
      }));
    }, MutRecShapes.collectTycons(patternInput_1[1]));

    if (!(allExtraGeneralizableTypars.tail == null)) {
      const freeInInitialEnv = GeneralizationHelpers.ComputeUngeneralizableTypars(envInitial);

      for (let extraTypar of allExtraGeneralizableTypars) {
        if (ZsetModule.memberOf(freeInInitialEnv, extraTypar)) {
          const ty = mkTyparTy(extraTypar);
          error_1(new _Error(SR.tcNotSufficientlyGenericBecauseOfScope(prettyStringOfTy(denv, ty)), extraTypar.Range));
        }
      }
    }

    let unsolvedTyparsForRecursiveBlockInvolvingGeneralizedVariables;
    const genSet = freeInTypes(CollectAllNoCaching, toList(delay(function () {
      return map_2(function (tp) {
        return mkTyparTy(tp);
      }, generalizedTyparsForRecursiveBlock);
    }))).FreeTypars;
    const allTypes = toList(delay(function () {
      return append_1(map_2(function (pgrbind_1) {
        return pgrbind_1.RecBindingInfo.Val.Type;
      }, patternInput_2[1]), delay(function () {
        return collect_1(function (matchValue) {
          return collect_1(function (defnB_1) {
            return defnB_1.tag === 0 ? singleton(defnB_1.data[0].InstanceCtorVal.Type) : empty();
          }, matchValue.data[2]);
        }, MutRecShapes.collectTycons(patternInput_2[0]));
      }));
    }));
    const unsolvedTypars = freeInTypesLeftToRight(cenv_1.g, true, allTypes);
    const unsolvedTyparsInvolvingGeneralizedVariables = filter(function (tp_1) {
      const freeInTypar = freeInType_1(CollectAllNoCaching, mkTyparTy(tp_1)).FreeTypars;

      if (!genSet.Contains_0(tp_1)) {
        return freeInTypar.Exists(function (otherTypar) {
          return genSet.Contains_0(otherTypar);
        });
      } else {
        return false;
      }
    }, unsolvedTypars);
    unsolvedTyparsForRecursiveBlockInvolvingGeneralizedVariables = unsolvedTyparsInvolvingGeneralizedVariables;

    for (let tp_2 of unsolvedTyparsForRecursiveBlockInvolvingGeneralizedVariables) {
      if (!tp_2.Rigidity.Equals(new TyparRigidity(0)) ? !tp_2.IsSolved : false) {
        ChooseTyparSolutionAndSolve(cenv_1.css, denv, tp_2);
      }
    }

    const defnsCs = TcMutRecBindings_Phase2C_FixupRecursiveReferences(cenv_1, denv, patternInput_2[0], generalizedTyparsForRecursiveBlock, patternInput_2[1], scopem);
    const defnsDs = TcMutRecBindings_Phase2D_ExtractImplicitFieldAndMethodBindings(cenv_1, patternInput_1[0], patternInput_2[2], denv, generalizedTyparsForRecursiveBlock, defnsCs);
    const defnsEs = EliminateInitializationGraphs(function (tupledArg_1) {
      return p23(tupledArg_1[0], tupledArg_1[1], tupledArg_1[2]);
    }, function (morpher, tupledArg_2) {
      return [tupledArg_2[0], append(morpher(tupledArg_2[1]), tupledArg_2[2])];
    }, function (x) {
      return x;
    }, function (morpher_1, oldBinds) {
      return morpher_1(oldBinds);
    }, cenv_1.g, true, denv, defnsDs, bindsm);
    return [defnsEs, patternInput_1[0]];
  };

  return __exports;
}({});
export function TcMutRecDefns_Phase2(cenv_1, envInitial, bindsm, scopem, mutRecNSInfo, envMutRec, mutRecDefns) {
  const interfacesFromTypeDefn = function (envForTycon, tyconMembersData) {
    const overridesOK = DeclKind.CanOverrideOrImplement(tyconMembersData.data[2]);
    return collect(function (_arg1) {
      if (_arg1.tag === 6) {
        const patternInput = tyconMembersData.data[3].Deref.IsExceptionDecl ? [new List(), cenv_1.g.exn_ty] : generalizeTyconRef(tyconMembersData.data[3]);
        const m = _arg1.data[0].Range;

        if (tyconMembersData.data[3].IsTypeAbbrev) {
          error_1(new _Error(SR.tcTypeAbbreviationsCannotHaveInterfaceDeclaration(), m));
        }

        if (tyconMembersData.data[3].IsEnumTycon) {
          error_1(new _Error(SR.tcEnumerationsCannotHaveInterfaceDeclaration(), m));
        }

        let ity_;
        const envinner = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), tyconMembersData.data[6], envForTycon);
        ity_ = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(0), new ItemOccurence(2), envinner, emptyUnscopedTyparEnv, _arg1.data[0])[0];

        if (!isInterfaceTy(cenv_1.g, ity_)) {
          errorR(new _Error(SR.tcTypeIsNotInterfaceType0(), _arg1.data[0].Range));
        }

        if (!function (arg00, arg10) {
          return EntityRef_HasInterface.bind(tyconMembersData.data[3])(arg00, arg10);
        }(cenv_1.g, ity_)) {
          error_1(new _Error(SR.tcAllImplementedInterfacesShouldBeDeclared(), _arg1.data[0].Range));
        }

        if (((((typeEquiv(cenv_1.g, ity_, cenv_1.g.mk_IComparable_ty) ? tyconMembersData.data[3].GeneratedCompareToValues != null : false) ? true : typeEquiv(cenv_1.g, ity_, cenv_1.g.mk_IStructuralComparable_ty) ? tyconMembersData.data[3].GeneratedCompareToWithComparerValues != null : false) ? true : typeEquiv(cenv_1.g, ity_, mkAppTy(cenv_1.g.system_GenericIComparable_tcref, ofArray([patternInput[1]]))) ? tyconMembersData.data[3].GeneratedCompareToValues != null : false) ? true : typeEquiv(cenv_1.g, ity_, mkAppTy(cenv_1.g.system_GenericIEquatable_tcref, ofArray([patternInput[1]]))) ? tyconMembersData.data[3].GeneratedHashAndEqualsWithComparerValues != null : false) ? true : typeEquiv(cenv_1.g, ity_, cenv_1.g.mk_IStructuralEquatable_ty) ? tyconMembersData.data[3].GeneratedHashAndEqualsWithComparerValues != null : false) {
          errorR(new _Error(SR.tcDefaultImplementationForInterfaceHasAlreadyBeenAdded(), _arg1.data[0].Range));
        }

        if (overridesOK.Equals(new OverridesOK(1))) {
          warning(new IntfImplInIntrinsicAugmentation(_arg1.data[0].Range));
        }

        if (overridesOK.Equals(new OverridesOK(2))) {
          errorR(new IntfImplInExtrinsicAugmentation(_arg1.data[0].Range));
        }

        if (_arg1.data[1] != null) {
          return ofArray([[ity_, getValue(_arg1.data[1]), m]]);
        } else {
          return new List();
        }
      } else {
        return new List();
      }
    }, tyconMembersData.data[7]);
  };

  const interfaceMembersFromTypeDefn = function (tyconMembersData_1, tupledArg, implTySet) {
    const containerInfo = new ContainerInfo(0, [tyconMembersData_1.data[1], new MemberOrValContainerInfo(0, [tyconMembersData_1.data[3], [tupledArg[0], implTySet], tyconMembersData_1.data[4], tyconMembersData_1.data[5], tyconMembersData_1.data[6]])]);
    return choose_1(function (mem) {
      if (mem.tag === 1) {
        return new TyconBindingDefn(0, [containerInfo, tyconMembersData_1.data[9], tyconMembersData_1.data[2], mem, mem.data[1]]);
      } else if (mem.tag === 10) {
        return new TyconBindingDefn(0, [containerInfo, tyconMembersData_1.data[9], tyconMembersData_1.data[2], mem, mem.data[10]]);
      } else {
        errorR(new _Error(SR.tcMemberNotPermittedInInterfaceImplementation(), mem.Range));
        return null;
      }
    }, tupledArg[1]);
  };

  const tyconBindingsOfTypeDefn = function (_arg3) {
    const containerInfo_1 = new ContainerInfo(0, [_arg3.data[1], new MemberOrValContainerInfo(0, [_arg3.data[3], null, _arg3.data[4], _arg3.data[5], _arg3.data[6]])]);
    return choose_1(function (memb) {
      switch (memb.tag) {
        case 3:
        case 4:
        case 10:
        case 1:
        case 0:
          return new TyconBindingDefn(0, [containerInfo_1, _arg3.data[9], _arg3.data[2], memb, memb.Range]);

        case 6:
          return null;

        case 5:
        case 8:
        case 7:
          return error_1(new InternalError("Unexpected declaration element", memb.Range));

        case 9:
          return error_1(new _Error(SR.tcTypesCannotContainNestedTypes(), memb.Range));

        default:
          return new TyconBindingDefn(0, [containerInfo_1, _arg3.data[9], _arg3.data[2], memb, memb.Range]);
      }
    }, _arg3.data[7]);
  };

  const tpenv = emptyUnscopedTyparEnv;

  try {
    MutRecShapes.iterTycons(function (tyconData) {
      const tcaug = tyconData.data[3].TypeContents;

      if (tcaug.tcaug_closed ? !tyconData.data[2].Equals(new DeclKind(2)) : false) {
        error_1(new InternalError("Intrinsic augmentations of types are only permitted in the same file as the definition of the type", tyconData.data[8]));
      }

      iterate(function (mem_1) {
        const $var373 = mem_1.tag === 1 ? [0] : mem_1.tag === 6 ? [1] : mem_1.tag === 0 ? tyconData.data[9].Equals(new NewSlotsOK(0)) ? [2] : [3] : mem_1.tag === 10 ? tyconData.data[9].Equals(new NewSlotsOK(0)) ? [2] : [3] : mem_1.tag === 4 ? tyconData.data[9].Equals(new NewSlotsOK(0)) ? [2] : [3] : mem_1.tag === 2 ? tyconData.data[9].Equals(new NewSlotsOK(0)) ? [2] : [3] : mem_1.tag === 3 ? tyconData.data[9].Equals(new NewSlotsOK(0)) ? [2] : [3] : [3];

        switch ($var373[0]) {
          case 0:
            break;

          case 1:
            break;

          case 2:
            break;

          case 3:
            error_1(new _Error(SR.tcDeclarationElementNotPermittedInAugmentation(), mem_1.Range));
            break;
        }
      }, tyconData.data[7]);
    }, mutRecDefns);
    const binds = MutRecShapes.mapTyconsWithEnv(function (envForDecls, tyconData_1) {
      const obinds = tyconBindingsOfTypeDefn(tyconData_1);
      let ibinds;
      const intfTypes = interfacesFromTypeDefn(envForDecls, tyconData_1);
      const slotImplSets = DispatchSlotChecking.GetSlotImplSets(cenv_1.infoReader, envForDecls.DisplayEnv, false, map_1(function (tupledArg_1) {
        return [tupledArg_1[0], tupledArg_1[2]];
      }, intfTypes));
      ibinds = concat(toList(map2(CurriedLambda(interfaceMembersFromTypeDefn)(tyconData_1), intfTypes, slotImplSets)));
      return new MutRecDefnsPhase2InfoForTycon(0, [tyconData_1.data[0], tyconData_1.data[3], tyconData_1.data[6], tyconData_1.data[2], append(obinds, ibinds), tyconData_1.data[10]]);
    }, envMutRec, mutRecDefns);
    return MutRecBindingChecking.TcMutRecDefns_Phase2_Bindings(cenv_1, envInitial, tpenv, bindsm, scopem, mutRecNSInfo, envMutRec, binds);
  } catch (e) {
    errorRecovery(e, scopem);
    return [new List(), envMutRec];
  }
}
export const AddAugmentationDeclarations = function (__exports) {
  const tcaugHasNominalInterface = __exports.tcaugHasNominalInterface = function (g, tcaug, tcref) {
    return exists_1(function (tupledArg) {
      const matchValue = tryDestAppTy(g, tupledArg[0]);
      const $var374 = matchValue != null ? tyconRefEq(g, getValue(matchValue), tcref) ? [0, getValue(matchValue)] : [1] : [1];

      switch ($var374[0]) {
        case 0:
          return true;

        case 1:
          return false;
      }
    }, tcaug.tcaug_interfaces);
  };

  const AddGenericCompareDeclarations = __exports.AddGenericCompareDeclarations = function (cenv_1, env, scSet, tycon) {
    if (TyconIsCandidateForAugmentationWithCompare(cenv_1.g, tycon) ? scSet.has(tycon.Stamp) : false) {
      const tcref = mkLocalTyconRef(tycon);
      const tcaug = tycon.TypeContents;
      const patternInput = tcref.Deref.IsExceptionDecl ? [new List(), cenv_1.g.exn_ty] : generalizeTyconRef(tcref);
      const m = tycon.Range;
      const genericIComparableTy = mkAppTy(cenv_1.g.system_GenericIComparable_tcref, ofArray([patternInput[1]]));

      const hasExplicitIComparable = function (arg00, arg10) {
        return Entity_HasInterface.bind(tycon)(arg00, arg10);
      }(cenv_1.g, cenv_1.g.mk_IComparable_ty);

      const hasExplicitGenericIComparable = tcaugHasNominalInterface(cenv_1.g, tcaug, cenv_1.g.system_GenericIComparable_tcref);

      const hasExplicitIStructuralComparable = function (arg00_1, arg10_1) {
        return Entity_HasInterface.bind(tycon)(arg00_1, arg10_1);
      }(cenv_1.g, cenv_1.g.mk_IStructuralComparable_ty);

      if (hasExplicitIComparable) {
        errorR(new _Error(SR.tcImplementsIComparableExplicitly(tycon.DisplayName), m));
      } else if (hasExplicitGenericIComparable) {
        errorR(new _Error(SR.tcImplementsGenericIComparableExplicitly(tycon.DisplayName), m));
      } else if (hasExplicitIStructuralComparable) {
        errorR(new _Error(SR.tcImplementsIStructuralComparableExplicitly(tycon.DisplayName), m));
      } else {
        const hasExplicitGenericIComparable_1 = function (arg00_2, arg10_2) {
          return Entity_HasInterface.bind(tycon)(arg00_2, arg10_2);
        }(cenv_1.g, genericIComparableTy);

        const patternInput_1 = MakeValsForCompareAugmentation(cenv_1.g, tcref);
        const cvspec3 = MakeValsForCompareWithComparerAugmentation(cenv_1.g, tcref);
        PublishInterface(cenv_1, env.DisplayEnv, tcref, m, true, cenv_1.g.mk_IStructuralComparable_ty);
        PublishInterface(cenv_1, env.DisplayEnv, tcref, m, true, cenv_1.g.mk_IComparable_ty);

        if (!tycon.IsExceptionDecl ? !hasExplicitGenericIComparable_1 : false) {
          PublishInterface(cenv_1, env.DisplayEnv, tcref, m, true, genericIComparableTy);
        }

        tcaug.SetCompare([mkLocalValRef(patternInput_1[0]), mkLocalValRef(patternInput_1[1])]);
        tcaug.SetCompareWith(mkLocalValRef(cvspec3));
        PublishValueDefn(cenv_1, env, new DeclKind(0), patternInput_1[0]);
        PublishValueDefn(cenv_1, env, new DeclKind(0), patternInput_1[1]);
        PublishValueDefn(cenv_1, env, new DeclKind(0), cvspec3);
      }
    }
  };

  const AddGenericEqualityWithComparerDeclarations = __exports.AddGenericEqualityWithComparerDeclarations = function (cenv_1, env, seSet, tycon) {
    if (TyconIsCandidateForAugmentationWithEquals(cenv_1.g, tycon) ? seSet.has(tycon.Stamp) : false) {
      const tcref = mkLocalTyconRef(tycon);
      const tcaug = tycon.TypeContents;
      const m = tycon.Range;

      const hasExplicitIStructuralEquatable = function (arg00, arg10) {
        return Entity_HasInterface.bind(tycon)(arg00, arg10);
      }(cenv_1.g, cenv_1.g.mk_IStructuralEquatable_ty);

      if (hasExplicitIStructuralEquatable) {
        errorR(new _Error(SR.tcImplementsIStructuralEquatableExplicitly(tycon.DisplayName), m));
      } else {
        const patternInput = MakeValsForEqualityWithComparerAugmentation(cenv_1.g, tcref);
        PublishInterface(cenv_1, env.DisplayEnv, tcref, m, true, cenv_1.g.mk_IStructuralEquatable_ty);
        tcaug.SetHashAndEqualsWith([mkLocalValRef(patternInput[0]), mkLocalValRef(patternInput[1]), mkLocalValRef(patternInput[2])]);
        PublishValueDefn(cenv_1, env, new DeclKind(0), patternInput[0]);
        PublishValueDefn(cenv_1, env, new DeclKind(0), patternInput[1]);
        PublishValueDefn(cenv_1, env, new DeclKind(0), patternInput[2]);
      }
    }
  };

  const AddGenericCompareBindings = __exports.AddGenericCompareBindings = function (cenv_1, tycon) {
    if (tycon.GeneratedCompareToValues != null) {
      return MakeBindingsForCompareAugmentation(cenv_1.g, tycon);
    } else {
      return new List();
    }
  };

  const AddGenericCompareWithComparerBindings = __exports.AddGenericCompareWithComparerBindings = function (cenv_1, tycon) {
    if (tycon.GeneratedCompareToWithComparerValues != null) {
      return MakeBindingsForCompareWithComparerAugmentation(cenv_1.g, tycon);
    } else {
      return new List();
    }
  };

  const AddGenericEqualityWithComparerBindings = __exports.AddGenericEqualityWithComparerBindings = function (cenv_1, tycon) {
    if (TyconIsCandidateForAugmentationWithEquals(cenv_1.g, tycon) ? tycon.GeneratedHashAndEqualsWithComparerValues != null : false) {
      return MakeBindingsForEqualityWithComparerAugmentation(cenv_1.g, tycon);
    } else {
      return new List();
    }
  };

  const AddGenericHashAndComparisonDeclarations = __exports.AddGenericHashAndComparisonDeclarations = function (cenv_1, env, scSet, seSet, tycon) {
    AddGenericCompareDeclarations(cenv_1, env, scSet, tycon);
    AddGenericEqualityWithComparerDeclarations(cenv_1, env, seSet, tycon);
  };

  const AddGenericHashAndComparisonBindings = __exports.AddGenericHashAndComparisonBindings = function (cenv_1, tycon) {
    return append(AddGenericCompareBindings(cenv_1, tycon), append(AddGenericCompareWithComparerBindings(cenv_1, tycon), AddGenericEqualityWithComparerBindings(cenv_1, tycon)));
  };

  const AddGenericEqualityBindings = __exports.AddGenericEqualityBindings = function (cenv_1, env, tycon) {
    if (TyconIsCandidateForAugmentationWithEquals(cenv_1.g, tycon)) {
      const tcref = mkLocalTyconRef(tycon);
      const tcaug = tycon.TypeContents;
      const patternInput = tcref.Deref.IsExceptionDecl ? [new List(), cenv_1.g.exn_ty] : generalizeTyconRef(tcref);
      const m = tycon.Range;

      const hasExplicitObjectEqualsOverride = function (arg00, arg10, arg20) {
        return Entity_HasOverride.bind(tycon)(arg00, arg10, arg20);
      }(cenv_1.g, "Equals", ofArray([cenv_1.g.obj_ty]));

      const hasExplicitGenericIEquatable = tcaugHasNominalInterface(cenv_1.g, tcaug, cenv_1.g.system_GenericIEquatable_tcref);

      if (hasExplicitGenericIEquatable) {
        errorR(new _Error(SR.tcImplementsIEquatableExplicitly(tycon.DisplayName), m));
      }

      if (!hasExplicitObjectEqualsOverride ? tycon.GeneratedHashAndEqualsWithComparerValues != null : false) {
        const patternInput_1 = MakeValsForEqualsAugmentation(cenv_1.g, tcref);
        tcaug.SetEquals([mkLocalValRef(patternInput_1[0]), mkLocalValRef(patternInput_1[1])]);

        if (!tycon.IsExceptionDecl) {
          PublishInterface(cenv_1, env.DisplayEnv, tcref, m, true, mkAppTy(cenv_1.g.system_GenericIEquatable_tcref, ofArray([patternInput[1]])));
        }

        PublishValueDefn(cenv_1, env, new DeclKind(0), patternInput_1[0]);
        PublishValueDefn(cenv_1, env, new DeclKind(0), patternInput_1[1]);
        return MakeBindingsForEqualsAugmentation(cenv_1.g, tycon);
      } else {
        return new List();
      }
    } else {
      return new List();
    }
  };

  return __exports;
}({});
export const TyconConstraintInference = function (__exports) {
  const InferSetOfTyconsSupportingComparable = __exports.InferSetOfTyconsSupportingComparable = function (cenv_1, denv, tyconsWithStructuralTypes) {
    const tab = create(map_1(function (tupledArg) {
      return [tupledArg[0].Stamp, [tupledArg[0], tupledArg[1]]];
    }, tyconsWithStructuralTypes), new Comparer((x, y) => x.CompareTo(y)));
    const initialAssumedTycons = create_1(toList(delay(function () {
      return collect_1(function (matchValue) {
        return TyconIsCandidateForAugmentationWithCompare(cenv_1.g, matchValue[0]) ? singleton(matchValue[0].Stamp) : empty();
      }, tyconsWithStructuralTypes);
    })), new Comparer((x, y) => x.CompareTo(y)));
    const initialAsssumedTypars = create_1(null, new Comparer(compare));

    const loop = function (assumedTycons, assumedTypars) {
      loop: while (true) {
        const assumedTyparsAcc = {
          contents: assumedTypars
        };

        const checkIfFieldTypeSupportsComparison = function (tycon, ty) {
          const matchValue_1 = tryDestTyparTy(cenv_1.g, ty);

          if (matchValue_1 == null) {
            const activePatternResult43285 = function (arg10_) {
              return _SpecialComparableHeadType___(cenv_1.g, arg10_);
            }(ty);

            if (activePatternResult43285 != null) {
              return forAll(CurriedLambda(checkIfFieldTypeSupportsComparison)(tycon), getValue(activePatternResult43285));
            } else {
              const activePatternResult43283 = function (arg10__1) {
                return _AppTy___(cenv_1.g, arg10__1);
              }(ty);

              if (activePatternResult43283 != null) {
                if ((initialAssumedTycons.has(getValue(activePatternResult43283)[0].Stamp) ? assumedTycons.has(getValue(activePatternResult43283)[0].Stamp) : ExistsSameHeadTypeInHierarchy(cenv_1.g, cenv_1.amap, range0, ty, cenv_1.g.mk_IComparable_ty) ? true : ExistsSameHeadTypeInHierarchy(cenv_1.g, cenv_1.amap, range0, ty, cenv_1.g.mk_IStructuralComparable_ty)) ? !HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_NoComparisonAttribute, getValue(activePatternResult43283)[0].Attribs) : false) {
                  return List_1.lengthsEqAndForall2(function (ty_1, tp) {
                    return (tp.ComparisonConditionalOn ? true : assumedTypars.has(tp.Stamp)) ? checkIfFieldTypeSupportsComparison(tycon, ty_1) : true;
                  }, getValue(activePatternResult43283)[1], getValue(activePatternResult43283)[0].TyparsNoRange);
                } else {
                  return false;
                }
              } else {
                return false;
              }
            }
          } else if (exists_1(function (_arg1) {
            return _arg1.tag === 9 ? true : false;
          }, getValue(matchValue_1).Constraints)) {
            return true;
          } else if (exists_1(function (tp2) {
            return typarRefEq(getValue(matchValue_1), tp2);
          }, tycon.TyparsNoRange)) {
            assumedTyparsAcc.contents = add_2(getValue(matchValue_1).Stamp, assumedTyparsAcc.contents);
            return true;
          } else {
            return false;
          }
        };

        const newSet = filter_1(function (tyconStamp) {
          const patternInput = tab.get(tyconStamp);

          if (((cenv_1.g.compilingFslib ? TyconIsCandidateForAugmentationWithCompare(cenv_1.g, patternInput[0]) : false) ? !HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_StructuralComparisonAttribute, patternInput[0].Attribs) : false) ? !HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_NoComparisonAttribute, patternInput[0].Attribs) : false) {
            errorR(new _Error(SR.tcFSharpCoreRequiresExplicit(), patternInput[0].Range));
          }

          const res = forAll($var375 => CurriedLambda(checkIfFieldTypeSupportsComparison)(patternInput[0])(function (tuple) {
            return tuple[0];
          }($var375)), patternInput[1]);

          if (!res) {
            const matchValue_2 = TryFindFSharpBoolAttribute(cenv_1.g, cenv_1.g.attrib_StructuralComparisonAttribute, patternInput[0].Attribs);

            if (matchValue_2 == null) {
              const matchValue_3 = tryFind($var377 => function (value) {
                return !value;
              }(($var376 => CurriedLambda(checkIfFieldTypeSupportsComparison)(patternInput[0])(function (tuple_1) {
                return tuple_1[0];
              }($var376)))($var377)), patternInput[1]);

              if (matchValue_3 != null) {
                const ty_2 = getValue(matchValue_3)[0];

                if (isTyparTy(cenv_1.g, ty_2)) {
                  warning(new _Error(SR.tcNoComparisonNeeded1(patternInput[0].DisplayName, prettyStringOfTy(denv, ty_2), patternInput[0].DisplayName), patternInput[0].Range));
                } else {
                  warning(new _Error(SR.tcNoComparisonNeeded2(patternInput[0].DisplayName, prettyStringOfTy(denv, ty_2), patternInput[0].DisplayName), patternInput[0].Range));
                }
              } else {
                throw new Error("unreachable");
              }
            } else if (getValue(matchValue_2)) {
              const matchValue_4 = tryFind($var379 => function (value_1) {
                return !value_1;
              }(($var378 => CurriedLambda(checkIfFieldTypeSupportsComparison)(patternInput[0])(function (tuple_2) {
                return tuple_2[0];
              }($var378)))($var379)), patternInput[1]);

              if (matchValue_4 != null) {
                const ty_3 = getValue(matchValue_4)[0];

                if (isTyparTy(cenv_1.g, ty_3)) {
                  errorR(new _Error(SR.tcStructuralComparisonNotSatisfied1(patternInput[0].DisplayName, prettyStringOfTy(denv, ty_3)), patternInput[0].Range));
                } else {
                  errorR(new _Error(SR.tcStructuralComparisonNotSatisfied2(patternInput[0].DisplayName, prettyStringOfTy(denv, ty_3)), patternInput[0].Range));
                }
              } else {
                throw new Error("unreachable");
              }
            }
          }

          return res;
        }, assumedTycons);

        if (newSet.Equals(assumedTycons) ? assumedTypars.Equals(assumedTyparsAcc.contents) : false) {
          return [newSet, assumedTyparsAcc.contents];
        } else {
          assumedTycons = newSet;
          assumedTypars = assumedTyparsAcc.contents;
          continue loop;
        }
      }
    };

    const patternInput_1 = loop(initialAssumedTycons, initialAsssumedTypars);

    for (let tyconStamp_1 of patternInput_1[0]) {
      const patternInput_2 = tab.get(tyconStamp_1);
      const inputSequence = patternInput_2[0].Typars(patternInput_2[0].Range);

      for (let tp_1 of inputSequence) {
        if (patternInput_1[1].has(tp_1.Stamp)) {
          tp_1.SetComparisonDependsOn(true);
        }
      }
    }

    return patternInput_1[0];
  };

  const InferSetOfTyconsSupportingEquatable = __exports.InferSetOfTyconsSupportingEquatable = function (cenv_1, denv, tyconsWithStructuralTypes) {
    const tab = create(map_1(function (tupledArg) {
      return [tupledArg[0].Stamp, [tupledArg[0], tupledArg[1]]];
    }, tyconsWithStructuralTypes), new Comparer((x, y) => x.CompareTo(y)));
    const initialAssumedTycons = create_1(toList(delay(function () {
      return collect_1(function (matchValue) {
        return TyconIsCandidateForAugmentationWithEquals(cenv_1.g, matchValue[0]) ? singleton(matchValue[0].Stamp) : empty();
      }, tyconsWithStructuralTypes);
    })), new Comparer((x, y) => x.CompareTo(y)));
    const initialAssumedTypars = create_1(null, new Comparer(compare));

    const loop = function (assumedTycons, assumedTypars) {
      loop: while (true) {
        const assumedTyparsAcc = {
          contents: assumedTypars
        };

        const checkIfFieldTypeSupportsEquality = function (tycon, ty) {
          const matchValue_1 = tryDestTyparTy(cenv_1.g, ty);

          if (matchValue_1 == null) {
            const activePatternResult43316 = function (arg10_) {
              return _SpecialEquatableHeadType___(cenv_1.g, arg10_);
            }(ty);

            if (activePatternResult43316 != null) {
              return forAll(CurriedLambda(checkIfFieldTypeSupportsEquality)(tycon), getValue(activePatternResult43316));
            } else {
              const activePatternResult43314 = function (arg10__1) {
                return _SpecialNotEquatableHeadType___(cenv_1.g, arg10__1);
              }(ty);

              if (activePatternResult43314 != null) {
                return false;
              } else {
                const activePatternResult43312 = function (arg10__2) {
                  return _AppTy___(cenv_1.g, arg10__2);
                }(ty);

                if (activePatternResult43312 != null) {
                  if ((initialAssumedTycons.has(getValue(activePatternResult43312)[0].Stamp) ? assumedTycons.has(getValue(activePatternResult43312)[0].Stamp) : TyconIsCandidateForAugmentationWithEquals(cenv_1.g, getValue(activePatternResult43312)[0].Deref) ? getValue(activePatternResult43312)[0].GeneratedHashAndEqualsWithComparerValues != null : true) ? !HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_NoEqualityAttribute, getValue(activePatternResult43312)[0].Attribs) : false) {
                    return List_1.lengthsEqAndForall2(function (ty_1, tp) {
                      return (tp.EqualityConditionalOn ? true : assumedTypars.has(tp.Stamp)) ? checkIfFieldTypeSupportsEquality(tycon, ty_1) : true;
                    }, getValue(activePatternResult43312)[1], getValue(activePatternResult43312)[0].TyparsNoRange);
                  } else {
                    return false;
                  }
                } else {
                  return false;
                }
              }
            }
          } else if (exists_1(function (_arg1) {
            return _arg1.tag === 10 ? true : false;
          }, getValue(matchValue_1).Constraints)) {
            return true;
          } else if (exists_1(function (tp2) {
            return typarRefEq(getValue(matchValue_1), tp2);
          }, tycon.Typars(tycon.Range))) {
            assumedTyparsAcc.contents = add_2(getValue(matchValue_1).Stamp, assumedTyparsAcc.contents);
            return true;
          } else {
            return false;
          }
        };

        const newSet = filter_1(function (tyconStamp) {
          const patternInput = tab.get(tyconStamp);

          if (((cenv_1.g.compilingFslib ? TyconIsCandidateForAugmentationWithEquals(cenv_1.g, patternInput[0]) : false) ? !HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_StructuralEqualityAttribute, patternInput[0].Attribs) : false) ? !HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_NoEqualityAttribute, patternInput[0].Attribs) : false) {
            errorR(new _Error(SR.tcFSharpCoreRequiresExplicit(), patternInput[0].Range));
          }

          const res = forAll($var380 => CurriedLambda(checkIfFieldTypeSupportsEquality)(patternInput[0])(function (tuple) {
            return tuple[0];
          }($var380)), patternInput[1]);

          if (!res) {
            const matchValue_2 = TryFindFSharpBoolAttribute(cenv_1.g, cenv_1.g.attrib_StructuralEqualityAttribute, patternInput[0].Attribs);

            if (matchValue_2 == null) {
              if (TyconIsCandidateForAugmentationWithEquals(cenv_1.g, patternInput[0])) {
                const matchValue_3 = tryFind($var382 => function (value) {
                  return !value;
                }(($var381 => CurriedLambda(checkIfFieldTypeSupportsEquality)(patternInput[0])(function (tuple_1) {
                  return tuple_1[0];
                }($var381)))($var382)), patternInput[1]);

                if (matchValue_3 != null) {
                  const ty_2 = getValue(matchValue_3)[0];

                  if (isTyparTy(cenv_1.g, ty_2)) {
                    warning(new _Error(SR.tcNoEqualityNeeded1(patternInput[0].DisplayName, prettyStringOfTy(denv, ty_2), patternInput[0].DisplayName), patternInput[0].Range));
                  } else {
                    warning(new _Error(SR.tcNoEqualityNeeded2(patternInput[0].DisplayName, prettyStringOfTy(denv, ty_2), patternInput[0].DisplayName), patternInput[0].Range));
                  }
                } else {
                  throw new Error("unreachable");
                }
              }
            } else if (getValue(matchValue_2)) {
              if (TyconIsCandidateForAugmentationWithEquals(cenv_1.g, patternInput[0])) {
                const matchValue_4 = tryFind($var384 => function (value_1) {
                  return !value_1;
                }(($var383 => CurriedLambda(checkIfFieldTypeSupportsEquality)(patternInput[0])(function (tuple_2) {
                  return tuple_2[0];
                }($var383)))($var384)), patternInput[1]);

                if (matchValue_4 != null) {
                  const ty_3 = getValue(matchValue_4)[0];

                  if (isTyparTy(cenv_1.g, ty_3)) {
                    errorR(new _Error(SR.tcStructuralEqualityNotSatisfied1(patternInput[0].DisplayName, prettyStringOfTy(denv, ty_3)), patternInput[0].Range));
                  } else {
                    errorR(new _Error(SR.tcStructuralEqualityNotSatisfied2(patternInput[0].DisplayName, prettyStringOfTy(denv, ty_3)), patternInput[0].Range));
                  }
                } else {
                  throw new Error("unreachable");
                }
              }
            }
          }

          return res;
        }, assumedTycons);

        if (newSet.Equals(assumedTycons) ? assumedTypars.Equals(assumedTyparsAcc.contents) : false) {
          return [newSet, assumedTyparsAcc.contents];
        } else {
          assumedTycons = newSet;
          assumedTypars = assumedTyparsAcc.contents;
          continue loop;
        }
      }
    };

    const patternInput_1 = loop(initialAssumedTycons, initialAssumedTypars);

    for (let tyconStamp_1 of patternInput_1[0]) {
      const patternInput_2 = tab.get(tyconStamp_1);
      const inputSequence = patternInput_2[0].Typars(patternInput_2[0].Range);

      for (let tp_1 of inputSequence) {
        if (patternInput_1[1].has(tp_1.Stamp)) {
          tp_1.SetEqualityDependsOn(true);
        }
      }
    }

    return patternInput_1[0];
  };

  return __exports;
}({});
export function ComputeModuleName(longPath) {
  var copyOfStruct;

  if (longPath.length !== 1) {
    error_1(new _Error(SR.tcInvalidModuleName(), (copyOfStruct = longPath.head, copyOfStruct.idRange)));
  }

  return longPath.head;
}
export function CheckForDuplicateConcreteType(env, nm, m) {
  const curr = GetCurrAccumulatedModuleOrNamespaceType(env);

  if (curr.AllEntitiesByCompiledAndLogicalMangledNames.has(nm)) {
    error_1(new Duplicate(SR.tcTypeExceptionOrModule(), nm, m));
  }
}
export function CheckForDuplicateModule(env, nm, m) {
  const curr = GetCurrAccumulatedModuleOrNamespaceType(env);

  if (curr.ModulesAndNamespacesByDemangledName.has(nm)) {
    errorR(new Duplicate(SR.tcTypeOrModule(), nm, m));
  }
}
export const TcExceptionDeclarations = function (__exports) {
  const TcExnDefnCore_Phase1A = __exports.TcExnDefnCore_Phase1A = function (cenv_1, env, parent, _arg1) {
    const id = _arg1.data[1].data[1];
    const attrs = TcAttributes(cenv_1, env, AttributeTargets.ExnDecl, _arg1.data[0]);

    if (!_String.isUpper(id.idText)) {
      errorR(new NotUpperCaseConstructor(_arg1.data[5]));
    }

    const patternInput = ComputeAccessAndCompPath(env, null, _arg1.data[5], _arg1.data[4], null, parent);
    const vis = TcRecdUnionAndEnumDeclarations.CombineReprAccess(parent, patternInput[0]);
    CheckForDuplicateConcreteType(env, id.idText + "Exception", id.idRange);
    CheckForDuplicateConcreteType(env, id.idText, id.idRange);
    return NewExn(patternInput[1], id, vis, new ExceptionInfo(2, MakeRecdFieldsTable(new List())), attrs, _arg1.data[3].ToXmlDoc());
  };

  const TcExnDefnCore_Phase1G_EstablishRepresentation = __exports.TcExnDefnCore_Phase1G_EstablishRepresentation = function (cenv_1, env, parent, exnc, _arg1) {
    var tcref;
    const args = _arg1.data[1].data[2];
    const args_1 = args.tag === 0 ? args.data : error_1(new _Error(SR.tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors(), _arg1.data[5]));
    const id = exnc.Id;
    const args_ = mapIndexed(function (i, fdef) {
      return TcRecdUnionAndEnumDeclarations.TcAnonFieldDecl(cenv_1, env, parent, emptyUnscopedTyparEnv, "Data" + i.toString(), fdef);
    }, args_1);
    TcRecdUnionAndEnumDeclarations.ValidateFieldNames(args_1, args_);
    let repr;

    if (_arg1.data[2] == null) {
      repr = new ExceptionInfo(2, MakeRecdFieldsTable(args_));
    } else {
      const matchValue = ResolveExprLongIdent(cenv_1.tcSink, cenv_1.nameResolver, _arg1.data[5], env.eAccessRights, env.eNameResEnv, TypeNameResolutionInfo.Default, getValue(_arg1.data[2]));
      const $var385 = matchValue[0].tag === 4 ? matchValue[1].tail == null ? [0, matchValue[0].data] : [2] : matchValue[0].tag === 11 ? matchValue[1].tail == null ? [1, matchValue[0].data[1]] : [2] : [2];

      switch ($var385[0]) {
        case 0:
          CheckTyconAccessible(cenv_1.amap, _arg1.data[5], env.eAccessRights, $var385[1]);

          if (!(args_.tail == null)) {
            errorR(new _Error(SR.tcExceptionAbbreviationsShouldNotHaveArgumentList(), _arg1.data[5]));
          }

          repr = new ExceptionInfo(0, $var385[1]);
          break;

        case 1:
          if (args_.tail == null) {} else {
            error_1(new _Error(SR.tcAbbreviationsFordotNetExceptionsCannotTakeArguments(), _arg1.data[5]));
          }

          const candidates = filter(function (minfo) {
            return minfo.NumArgs.Equals(ofArray([args_.length])) ? minfo.GenericArity === 0 : false;
          }, $var385[1]);
          const $var386 = candidates.tail != null ? candidates.tail.tail == null ? [0, candidates.head] : [1] : [1];

          switch ($var386[0]) {
            case 0:
              const matchValue_1 = $var386[1].ApparentEnclosingType;
              let $var387;

              const activePatternResult43349 = function (arg10_) {
                return _AppTy___(cenv_1.g, arg10_);
              }(matchValue_1);

              if (activePatternResult43349 != null) {
                if (tcref = getValue(activePatternResult43349)[0], TypeDefinitelySubsumesTypeNoCoercion(0, cenv_1.g, cenv_1.amap, _arg1.data[5], cenv_1.g.exn_ty, matchValue_1)) {
                  $var387 = [0, matchValue_1, getValue(activePatternResult43349)[0]];
                } else {
                  $var387 = [1];
                }
              } else {
                $var387 = [1];
              }

              switch ($var387[0]) {
                case 0:
                  const tref = $var387[2].CompiledRepresentationForNamedType;
                  repr = new ExceptionInfo(1, tref);
                  break;

                case 1:
                  repr = error_1(new _Error(SR.tcExceptionAbbreviationsMustReferToValidExceptions(), _arg1.data[5]));
                  break;
              }

              break;

            case 1:
              repr = error_1(new _Error(SR.tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor(), _arg1.data[5]));
              break;
          }

          break;

        case 2:
          repr = error_1(new _Error(SR.tcNotAnException(), _arg1.data[5]));
          break;
      }
    }

    exnc.SetExceptionInfo(repr);
    const item = new Item(4, mkLocalTyconRef(exnc));
    CallNameResolutionSink(cenv_1.tcSink, id.idRange, env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(0), env.DisplayEnv, env.eAccessRights);
    return args_;
  };

  const TcExnDefnCore = function (cenv_1, env, parent, synExnDefnRepr) {
    const exnc = TcExnDefnCore_Phase1A(cenv_1, env, parent, synExnDefnRepr);
    const args_ = TcExnDefnCore_Phase1G_EstablishRepresentation(cenv_1, env, parent, exnc, synExnDefnRepr);
    exnc.TypeContents.tcaug_super = cenv_1.g.exn_ty;
    PublishTypeDefn(cenv_1, env, exnc);
    const structuralTypes = map_1(function (rf) {
      return [rf.FormalType, rf.Range];
    }, args_);
    const scSet = TyconConstraintInference.InferSetOfTyconsSupportingComparable(cenv_1, env.DisplayEnv, ofArray([[exnc, structuralTypes]]));
    const seSet = TyconConstraintInference.InferSetOfTyconsSupportingEquatable(cenv_1, env.DisplayEnv, ofArray([[exnc, structuralTypes]]));
    let binds;
    const matchValue = exnc.ExceptionInfo;
    const $var388 = matchValue.tag === 3 ? [0] : matchValue.tag === 1 ? [0] : matchValue.tag === 2 ? [1] : [0];

    switch ($var388[0]) {
      case 0:
        binds = new List();
        break;

      case 1:
        AddAugmentationDeclarations.AddGenericHashAndComparisonDeclarations(cenv_1, env, scSet, seSet, exnc);
        binds = AddAugmentationDeclarations.AddGenericHashAndComparisonBindings(cenv_1, exnc);
        break;
    }

    return [binds, exnc];
  };

  const TcExnDefn = __exports.TcExnDefn = function (cenv_1, envInitial, parent, _arg1, scopem) {
    const patternInput = TcExnDefnCore(cenv_1, envInitial, parent, _arg1.data[0]);
    const envMutRec = AddLocalExnDefnAndReport(cenv_1.tcSink, scopem, AddLocalTycons(cenv_1.g, cenv_1.amap, scopem, ofArray([patternInput[1]]), envInitial), patternInput[1]);
    const defns = ofArray([new MutRecShape(0, new MutRecDefnsPhase2DataForTycon(0, [patternInput[1], parent, new DeclKind(0), mkLocalEntityRef(patternInput[1]), null, new SafeInitData(1), new List(), _arg1.data[1], _arg1.data[2], new NewSlotsOK(1), function () {}]))]);
    const patternInput_1 = TcMutRecDefns_Phase2(cenv_1, envInitial, _arg1.data[2], scopem, null, envMutRec, defns);
    const binds2flat = collect(function (tuple) {
      return tuple[1];
    }, MutRecShapes.collectTycons(patternInput_1[0]));
    const binds3 = AddAugmentationDeclarations.AddGenericEqualityBindings(cenv_1, patternInput_1[1], patternInput[1]);
    return [append(patternInput[0], append(binds2flat, binds3)), patternInput[1], patternInput_1[1]];
  };

  const TcExnSignature = __exports.TcExnSignature = function (cenv_1, envInitial, parent, tpenv, _arg1, scopem) {
    const patternInput = TcExnDefnCore(cenv_1, envInitial, parent, _arg1.data[0]);
    const envMutRec = AddLocalExnDefnAndReport(cenv_1.tcSink, scopem, AddLocalTycons(cenv_1.g, cenv_1.amap, scopem, ofArray([patternInput[1]]), envInitial), patternInput[1]);
    const ecref = mkLocalEntityRef(patternInput[1]);
    const patternInput_1 = TcTyconMemberSpecs(cenv_1, envMutRec, new ContainerInfo(0, [parent, new MemberOrValContainerInfo(0, [ecref, null, null, new SafeInitData(1), new List()])]), new DeclKind(0), tpenv, _arg1.data[1]);
    return [patternInput[0], patternInput_1[0], ecref, envMutRec];
  };

  return __exports;
}({});
export const EstablishTypeDefinitionCores = function (__exports) {
  const ComputeTyconName = function (longPath, doErase, typars) {
    var copyOfStruct;

    if (longPath.length !== 1) {
      error_1(new _Error(SR.tcInvalidTypeExtension(), (copyOfStruct = longPath.head, copyOfStruct.idRange)));
    }

    const id = longPath.head;
    const erasedArity = (doErase ? sumBy(function (tp) {
      return tp.IsErased ? 0 : 1;
    }, typars) : typars.length) | 0;
    return mkSynId(id.idRange, erasedArity === 0 ? id.idText : id.idText + "`" + erasedArity.toString());
  };

  const GetTyconAttribs = function (g, attrs) {
    const hasClassAttr = HasFSharpAttribute(g, g.attrib_ClassAttribute, attrs);
    const hasAbstractClassAttr = HasFSharpAttribute(g, g.attrib_AbstractClassAttribute, attrs);
    const hasInterfaceAttr = HasFSharpAttribute(g, g.attrib_InterfaceAttribute, attrs);
    const hasStructAttr = HasFSharpAttribute(g, g.attrib_StructAttribute, attrs);
    const hasMeasureAttr = HasFSharpAttribute(g, g.attrib_MeasureAttribute, attrs);
    return [hasClassAttr, hasAbstractClassAttr, hasInterfaceAttr, hasStructAttr, hasMeasureAttr];
  };

  const InferTyconKind = function (g, kind, attrs, slotsigs, fields, inSig, isConcrete, m) {
    const patternInput = GetTyconAttribs(g, attrs);

    const bi = function (b) {
      if (b) {
        return 1;
      } else {
        return 0;
      }
    };

    if (bi(patternInput[0]) + bi(patternInput[2]) + bi(patternInput[3]) + bi(patternInput[4]) > 1 ? true : bi(patternInput[1]) + bi(patternInput[2]) + bi(patternInput[3]) + bi(patternInput[4]) > 1) {
      error_1(new _Error(SR.tcAttributesOfTypeSpecifyMultipleKindsForType(), m));
    }

    if (kind.tag === 0) {
      if ((patternInput[0] ? true : patternInput[1]) ? true : patternInput[4]) {
        return new SynTypeDefnKind(1);
      } else if (patternInput[2]) {
        return new SynTypeDefnKind(2);
      } else if (patternInput[3]) {
        return new SynTypeDefnKind(3);
      } else if (isConcrete ? true : !(fields.tail == null)) {
        return new SynTypeDefnKind(1);
      } else if (slotsigs.tail == null ? inSig : false) {
        return new SynTypeDefnKind(7);
      } else {
        return new SynTypeDefnKind(2);
      }
    } else {
      if ((((patternInput[0] ? !(kind.tag === 1 ? true : false) : false) ? true : patternInput[4] ? !(() => {
        const $var389 = kind.tag === 1 ? [0] : kind.tag === 6 ? [0] : kind.tag === 7 ? [0] : [1];

        switch ($var389[0]) {
          case 0:
            return true;

          case 1:
            return false;
        }
      })() : false) ? true : patternInput[2] ? !(kind.tag === 2 ? true : false) : false) ? true : patternInput[3] ? !(() => {
        const $var390 = kind.tag === 3 ? [0] : kind.tag === 4 ? [0] : kind.tag === 5 ? [0] : [1];

        switch ($var390[0]) {
          case 0:
            return true;

          case 1:
            return false;
        }
      })() : false) {
        error_1(new _Error(SR.tcKindOfTypeSpecifiedDoesNotMatchDefinition(), m));
      }

      return kind;
    }
  };

  const _TyconCoreAbbrevThatIsReallyAUnion___ = function (hasMeasureAttr, envinner, id, synTyconRepr) {
    var unionCaseName;
    const $var391 = synTyconRepr.tag === 5 ? synTyconRepr.data[1].tag === 0 ? synTyconRepr.data[1].data.data[0].tail != null ? synTyconRepr.data[1].data.data[0].tail.tail == null ? (unionCaseName = synTyconRepr.data[1].data.data[0].head, !hasMeasureAttr ? LookupTypeNameInEnvNoArity(new FullyQualifiedFlag(1), unionCaseName.idText, envinner.eNameResEnv).tail == null ? true : id.idText === unionCaseName.idText : false) ? [0, synTyconRepr.data[2], synTyconRepr.data[1].data.data[0].head] : [1] : [1] : [1] : [1] : [1];

    switch ($var391[0]) {
      case 0:
        return [$var391[2], $var391[1]];

      case 1:
        return null;
    }
  };

  const GetStructuralElementsOfTyconDefn = function (cenv_1, env, tpenv, _arg1, tycon) {
    const thisTyconRef = mkLocalTyconRef(tycon);
    const m = tycon.Range;
    const env_1 = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), tycon.Typars(m), env);
    const env_2 = MakeInnerEnvForTyconRef(cenv_1, env_1, thisTyconRef, false);
    return toList(delay(function () {
      const $var392 = _arg1.data[1].tag === 6 ? [0] : _arg1.data[1].tag === 0 ? [1, _arg1.data[1].data[1]] : _arg1.data[1].tag === 3 ? tycon.IsFSharpStructOrEnumTycon ? [2, _arg1.data[1].data[3], _arg1.data[1].data[6]] : [3] : [3];

      switch ($var392[0]) {
        case 0:
          return empty();

        case 1:
          return collect_1(function (matchValue) {
            var tcAttributes;

            if (matchValue.data[2].tag === 1) {
              const ty = matchValue.data[2].data[0];
              const arity = matchValue.data[2].data[1];
              const patternInput = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(1), new ItemOccurence(2), env_2, tpenv, ty);
              const patternInput_1 = GetTopTauTypeInFSharpForm(cenv_1.g, TranslatePartialArity(new List(), (tcAttributes = function (attrTgt, synAttribs) {
                return TcAttributes(cenv_1, env_2, attrTgt, synAttribs);
              }, function (arg20_) {
                return TranslateTopValSynInfo(matchValue.data[5], tcAttributes, arg20_);
              })(arity)).ArgInfos, patternInput[0], matchValue.data[5]);
              return append_1(patternInput_1[0].length > 1 ? (errorR(new _Error(SR.tcIllegalFormForExplicitTypeDeclaration(), matchValue.data[5])), empty()) : empty(), delay(function () {
                return collect_1(function (argtys) {
                  return collect_1(function (matchValue_1) {
                    return singleton([matchValue_1[0], matchValue.data[5]]);
                  }, argtys);
                }, patternInput_1[0]);
              }));
            } else {
              return collect_1(function (matchValue_2) {
                const patternInput_2 = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(1), new ItemOccurence(2), env_2, tpenv, matchValue_2.data[3]);
                return singleton([patternInput_2[0], matchValue_2.data[7]]);
              }, matchValue.data[2].data);
            }
          }, $var392[1]);

        case 2:
          return append_1(collect_1(function (matchValue_3) {
            if (!matchValue_3.data[1]) {
              const patternInput_3 = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(1), new ItemOccurence(2), env_2, tpenv, matchValue_3.data[3]);
              return singleton([patternInput_3[0], matchValue_3.data[7]]);
            } else {
              return empty();
            }
          }, $var392[1]), delay(function () {
            if ($var392[2] != null) {
              const patternInput_4 = TcSimplePatsOfUnknownType(cenv_1, true, new CheckConstraints(1), env_2, tpenv, new SynSimplePats(0, [getValue($var392[2]), m]));
              const names = patternInput_4[1][1];
              return collect_1(function (arg) {
                const ty_1 = names.get(arg).Type;
                let m_1;
                let copyOfStruct = names.get(arg).Ident;
                m_1 = copyOfStruct.idRange;
                return append_1(!(ListSet.subtract(function (lv1, lv2) {
                  return typarEq(lv1, lv2);
                }, freeInTypeLeftToRight(cenv_1.g, false, ty_1), tycon.TyparsNoRange).tail == null) ? (errorR(new _Error(SR.tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly(), m_1)), empty()) : empty(), delay(function () {
                  return singleton([ty_1, m_1]);
                }));
              }, patternInput_4[0]);
            } else {
              return empty();
            }
          }));

        case 3:
          if (_arg1.data[1].tag === 2) {
            return collect_1(function (matchValue_4) {
              const patternInput_5 = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(1), new ItemOccurence(2), env_2, tpenv, matchValue_4.data[3]);
              return singleton([patternInput_5[0], matchValue_4.data[7]]);
            }, _arg1.data[1].data[1]);
          } else {
            return empty();
          }

      }
    }));
  };

  const ComputeModuleOrNamespaceKind = __exports.ComputeModuleOrNamespaceKind = function (g, isModule, typeNames, attribs, nm) {
    if (!isModule) {
      return new ModuleOrNamespaceKind(2);
    } else if (ModuleNameIsMangled(g, attribs) ? true : typeNames.has(nm)) {
      return new ModuleOrNamespaceKind(0);
    } else {
      return new ModuleOrNamespaceKind(1);
    }
  };

  const AdjustModuleName = __exports.AdjustModuleName = function (modKind, nm) {
    if (modKind.tag === 0) {
      return nm + "Module";
    } else {
      return nm;
    }
  };

  const TypeNamesInMutRecDecls = __exports.TypeNamesInMutRecDecls = function (compDecls) {
    return create_1(toList(delay(function () {
      return collect_1(function (d) {
        var copyOfStruct;

        if (d.tag === 0) {
          const isAtOriginalTyconDefn = d.data[0].data[5];
          const ids = d.data[0].data[0].data[3];

          if (isAtOriginalTyconDefn) {
            return singleton((copyOfStruct = last(ids), copyOfStruct.idText));
          } else {
            return empty();
          }
        } else {
          return empty();
        }
      }, compDecls);
    })), new Comparer(comparePrimitives));
  };

  const TypeNamesInNonMutRecDecls = __exports.TypeNamesInNonMutRecDecls = function (defs) {
    return create_1(toList(delay(function () {
      return collect_1(function (def) {
        return def.tag === 4 ? collect_1(function (matchValue) {
          var copyOfStruct;
          const typars = matchValue.data[0].data[1];
          const ids = matchValue.data[0].data[3];

          if (typars.tail == null) {
            const $var393 = matchValue.data[1].tag === 0 ? matchValue.data[1].data[0].tag === 8 ? [0] : [1] : [1];

            switch ($var393[0]) {
              case 0:
                return empty();

              case 1:
                return singleton((copyOfStruct = last(ids), copyOfStruct.idText));
            }
          } else {
            return empty();
          }
        }, def.data[0]) : empty();
      }, defs);
    })), new Comparer(comparePrimitives));
  };

  const TypeNamesInNonMutRecSigDecls = __exports.TypeNamesInNonMutRecSigDecls = function (defs) {
    return create_1(toList(delay(function () {
      return collect_1(function (def) {
        return def.tag === 3 ? collect_1(function (matchValue) {
          var copyOfStruct;
          const typars = matchValue.data[0].data[1];
          const ids = matchValue.data[0].data[3];

          if (typars.tail == null) {
            const $var394 = matchValue.data[1].tag === 1 ? matchValue.data[1].data[0].tag === 6 ? !(matchValue.data[2].tail == null) ? [0] : [1] : [1] : [1];

            switch ($var394[0]) {
              case 0:
                return empty();

              case 1:
                return singleton((copyOfStruct = last(ids), copyOfStruct.idText));
            }
          } else {
            return empty();
          }
        }, def.data[0]) : empty();
      }, defs);
    })), new Comparer(comparePrimitives));
  };

  const TcTyconDefnCore_Phase1A_BuildInitialModule = __exports.TcTyconDefnCore_Phase1A_BuildInitialModule = function (cenv_1, envInitial, parent, typeNames, compInfo, decls) {
    const id = ComputeModuleName(compInfo.data[3]);
    const modAttrs = TcAttributes(cenv_1, envInitial, AttributeTargets.ModuleDecl, compInfo.data[0]);
    const modKind = ComputeModuleOrNamespaceKind(cenv_1.g, true, typeNames, modAttrs, id.idText);
    const modName = AdjustModuleName(modKind, id.idText);
    const patternInput = ComputeAccessAndCompPath(envInitial, null, id.idRange, compInfo.data[6], null, parent);
    CheckForDuplicateModule(envInitial, id.idText, id.idRange);
    const id_1 = ident(modName, id.idRange);
    CheckForDuplicateConcreteType(envInitial, id_1.idText, compInfo.data[7]);
    CheckNamespaceModuleOrTypeName(cenv_1.g, id_1);
    const patternInput_1 = MakeInnerEnv(envInitial, id_1, modKind);
    const mspec = NewModuleOrNamespace(envInitial.eCompPath, patternInput[0], id_1, compInfo.data[4].ToXmlDoc(), modAttrs, new MaybeLazy(0, NewEmptyModuleOrNamespaceType(modKind)));
    const innerParent = new ParentRef(0, mkLocalModRef(mspec));
    const innerTypeNames = TypeNamesInMutRecDecls(decls);
    return [new MutRecDefnsPhase2DataForModule(0, [patternInput_1[1], mspec]), [innerParent, innerTypeNames, patternInput_1[0]]];
  };

  const TcTyconDefnCore_Phase1A_BuildInitialTycon = function (cenv_1, env, parent, _arg1) {
    const checkedTypars = TcTyparDecls(cenv_1, env, _arg1.data[0].data[1]);
    iterate(function (id) {
      CheckNamespaceModuleOrTypeName(cenv_1.g, id);
    }, _arg1.data[0].data[3]);

    if (_arg1.data[1].tag === 7) {
      return TcExceptionDeclarations.TcExnDefnCore_Phase1A(cenv_1, env, parent, _arg1.data[1].data);
    } else {
      const id_1 = ComputeTyconName(_arg1.data[0].data[3], _arg1.data[1].tag === 5 ? false : true, checkedTypars);
      CheckForDuplicateConcreteType(env, id_1.idText, id_1.idRange);
      const patternInput = ComputeAccessAndCompPath(env, null, id_1.idRange, _arg1.data[0].data[6], null, parent);
      let synVisOfRepr;

      switch (_arg1.data[1].tag) {
        case 5:
          synVisOfRepr = null;
          break;

        case 0:
          synVisOfRepr = _arg1.data[1].data[0];
          break;

        case 4:
          synVisOfRepr = null;
          break;

        case 2:
          synVisOfRepr = _arg1.data[1].data[0];
          break;

        case 3:
          synVisOfRepr = null;
          break;

        case 1:
          synVisOfRepr = null;
          break;

        case 7:
          synVisOfRepr = null;
          break;

        default:
          synVisOfRepr = null;
      }

      const patternInput_1 = ComputeAccessAndCompPath(env, null, id_1.idRange, synVisOfRepr, null, parent);
      const visOfRepr = combineAccess(patternInput[0], patternInput_1[0]);
      const lmtyp = new MaybeLazy(0, NewEmptyModuleOrNamespaceType(new ModuleOrNamespaceKind(1)));
      return NewTycon(patternInput[1], id_1.idText, id_1.idRange, patternInput[0], visOfRepr, new TyparKind(0), LazyWithContext.NotLazy(checkedTypars), _arg1.data[0].data[4].ToXmlDoc(), _arg1.data[0].data[5], _arg1.data[3], _arg1.data[4], lmtyp);
    }
  };

  const TcTyconDefnCore_Phase1B_EstablishBasicKind = function (cenv_1, inSig, envinner, _arg1, tycon) {
    const m = tycon.Range;
    const id = tycon.Id;
    const patternInput = TcAttributesCanFail(cenv_1, envinner, AttributeTargets.TyconDecl, _arg1.data[0].data[0]);
    const hasMeasureAttr = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_MeasureAttribute, patternInput[0]);
    let isStructRecordOrUnionType;
    let $var395;

    if (_arg1.data[1].tag === 2) {
      $var395 = [0];
    } else if (_arg1.data[1].tag === 0) {
      const activePatternResult43428 = _TyconCoreAbbrevThatIsReallyAUnion___(hasMeasureAttr, envinner, id, _arg1.data[1]);

      if (activePatternResult43428 != null) {
        $var395 = [0];
      } else {
        $var395 = [0];
      }
    } else {
      const activePatternResult43429 = _TyconCoreAbbrevThatIsReallyAUnion___(hasMeasureAttr, envinner, id, _arg1.data[1]);

      if (activePatternResult43429 != null) {
        $var395 = [0];
      } else {
        $var395 = [1];
      }
    }

    switch ($var395[0]) {
      case 0:
        isStructRecordOrUnionType = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_StructAttribute, patternInput[0]);
        break;

      case 1:
        isStructRecordOrUnionType = false;
        break;
    }

    tycon.SetIsStructRecordOrUnion(isStructRecordOrUnionType);
    tycon.SetCompiledName(TryFindFSharpStringAttribute(cenv_1.g, cenv_1.g.attrib_CompiledNameAttribute, patternInput[0]));

    if (hasMeasureAttr) {
      tycon.SetTypeOrMeasureKind(new TyparKind(1));

      if (!(_arg1.data[0].data[1].tail == null)) {
        error_1(new _Error(SR.tcMeasureDefinitionsCannotHaveTypeParameters(), m));
      }
    }

    let repr_2;
    let $var396;

    if (_arg1.data[1].tag === 7) {
      $var396 = [0];
    } else if (_arg1.data[1].tag === 6) {
      $var396 = [1, _arg1.data[1].data];
    } else if (_arg1.data[1].tag === 0) {
      const activePatternResult43431 = _TyconCoreAbbrevThatIsReallyAUnion___(hasMeasureAttr, envinner, id, _arg1.data[1]);

      if (activePatternResult43431 != null) {
        $var396 = [2, getValue(activePatternResult43431)[1]];
      } else {
        $var396 = [2, _arg1.data[1].data[2]];
      }
    } else {
      const activePatternResult43432 = _TyconCoreAbbrevThatIsReallyAUnion___(hasMeasureAttr, envinner, id, _arg1.data[1]);

      if (activePatternResult43432 != null) {
        $var396 = [2, getValue(activePatternResult43432)[1]];
      } else {
        $var396 = [3];
      }
    }

    switch ($var396[0]) {
      case 0:
        repr_2 = new TyconRepresentation(6);
        break;

      case 1:
        InferTyconKind(cenv_1.g, new SynTypeDefnKind(7), patternInput[0], new List(), new List(), inSig, true, $var396[1]);

        if (!inSig ? !hasMeasureAttr : false) {
          errorR(new _Error(SR.tcTypeRequiresDefinition(), $var396[1]));
        }

        if (hasMeasureAttr) {
          repr_2 = new TyconRepresentation(0, new TyconObjModelData(new TyconObjModelKind(0), new List(), MakeRecdFieldsTable(new List())));
        } else {
          repr_2 = new TyconRepresentation(6);
        }

        break;

      case 2:
        InferTyconKind(cenv_1.g, new SynTypeDefnKind(5), patternInput[0], new List(), new List(), inSig, true, $var396[1]);
        repr_2 = MakeUnionRepr(new List());
        break;

      case 3:
        switch (_arg1.data[1].tag) {
          case 5:
            InferTyconKind(cenv_1.g, new SynTypeDefnKind(6), patternInput[0], new List(), new List(), inSig, true, m);
            repr_2 = new TyconRepresentation(6);
            break;

          case 4:
            InferTyconKind(cenv_1.g, new SynTypeDefnKind(9), patternInput[0], new List(), new List(), inSig, true, _arg1.data[1].data[1]);
            repr_2 = new TyconRepresentation(4, _arg1.data[1].data[0]);
            break;

          case 2:
            InferTyconKind(cenv_1.g, new SynTypeDefnKind(4), patternInput[0], new List(), new List(), inSig, true, _arg1.data[1].data[2]);
            repr_2 = new TyconRepresentation(1, MakeRecdFieldsTable(new List()));
            break;

          case 3:
            const kind = InferTyconKind(cenv_1.g, _arg1.data[1].data[0], patternInput[0], _arg1.data[1].data[2], _arg1.data[1].data[3], inSig, _arg1.data[1].data[4], m);

            if (kind.tag === 7) {
              repr_2 = new TyconRepresentation(6);
            } else {
              let kind_1;

              switch (kind.tag) {
                case 1:
                  kind_1 = new TyconObjModelKind(0);
                  break;

                case 2:
                  kind_1 = new TyconObjModelKind(1);
                  break;

                case 10:
                  kind_1 = new TyconObjModelKind(3, MakeSlotSig("Invoke", cenv_1.g.unit_ty, new List(), new List(), new List(), null));
                  break;

                case 3:
                  kind_1 = new TyconObjModelKind(2);
                  break;

                default:
                  kind_1 = error_1(new InternalError("should have inferred tycon kind", m));
              }

              const repr = new TyconObjModelData(kind_1, new List(), MakeRecdFieldsTable(new List()));
              repr_2 = new TyconRepresentation(0, repr);
            }

            break;

          case 1:
            const kind_2 = new TyconObjModelKind(4);
            const repr_1 = new TyconObjModelData(kind_2, new List(), MakeRecdFieldsTable(new List()));
            repr_2 = new TyconRepresentation(0, repr_1);
            break;

          default:
            throw new Error("C:/projects/fcs/src/fsharp/TypeChecker.fs", 14678, 18);
        }

        break;
    }

    tycon.entity_tycon_repr = repr_2;
    return [patternInput[0], patternInput[1]];
  };

  const TcTyconDefnCore_Phase1C_Phase1E_EstablishAbbreviations = function (cenv_1, envinner, inSig, tpenv, pass, _arg1, tycon, attrs) {
    const m = tycon.Range;
    const checkCxs = pass.Equals(new TypeRealizationPass(1)) ? new CheckConstraints(0) : new CheckConstraints(1);
    const firstPass = pass.Equals(new TypeRealizationPass(0));

    try {
      const id = tycon.Id;
      const thisTyconRef = mkLocalTyconRef(tycon);
      const hasMeasureAttr = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_MeasureAttribute, attrs);
      const hasMeasureableAttr = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_MeasureableAttribute, attrs);
      const envinner_1 = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), tycon.Typars(m), envinner);
      const envinner_2 = MakeInnerEnvForTyconRef(cenv_1, envinner_1, thisTyconRef, false);

      const activePatternResult43439 = _TyconCoreAbbrevThatIsReallyAUnion___(hasMeasureAttr, envinner_2, id, _arg1.data[1]);

      if (activePatternResult43439 != null) {} else {
        const $var397 = _arg1.data[1].tag === 5 ? _arg1.data[1].data[0].tag === 0 ? [0, _arg1.data[1].data[2], _arg1.data[1].data[1]] : [1] : [1];

        switch ($var397[0]) {
          case 0:
            inSig;

            if (!hasMeasureableAttr) {
              const kind = hasMeasureAttr ? new TyparKind(1) : new TyparKind(0);
              const patternInput = TcTypeOrMeasureAndRecover(kind, cenv_1, new ImplictlyBoundTyparsAllowed(2), checkCxs, new ItemOccurence(2), envinner_2, tpenv, $var397[2]);

              if (!firstPass) {
                const ftyvs = freeInTypeLeftToRight(cenv_1.g, false, patternInput[0]);
                const typars = tycon.Typars($var397[1]);

                if (ftyvs.length !== typars.length) {
                  errorR(new Deprecated(SR.tcTypeAbbreviationHasTypeParametersMissingOnType(), tycon.Range));
                }
              }

              if (firstPass) {
                tycon.SetTypeAbbrev(patternInput[0]);
              }
            }

            break;

          case 1:
            break;
        }
      }
    } catch (e) {
      errorRecovery(e, m);
    }
  };

  const TcTyconDefnCore_Phase1D_Phase1F_EstablishSuperTypesAndInterfaceTypes = function (cenv_1, tpenv, inSig, pass, envMutRec, mutRecDefns) {
    var action;
    const checkCxs = pass.Equals(new TypeRealizationPass(1)) ? new CheckConstraints(0) : new CheckConstraints(1);
    const firstPass = pass.Equals(new TypeRealizationPass(0));
    const tyconWithImplementsL = MutRecShapes.mapTyconsWithEnv(function (envinner, tupledArg) {
      var f;
      var newOk;
      var occ;
      var f_1;
      var newOk_1;
      var occ_1;
      const matchValue = [tupledArg[0], tupledArg[1]];

      if (matchValue[1] != null) {
        const typeDefCore = matchValue[0][0];
        const tycon = getValue(matchValue[1])[0];
        const attrs = getValue(matchValue[1])[1][0];
        const m = tycon.Range;
        const tcref = mkLocalTyconRef(tycon);
        const envinner_1 = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), tycon.Typars(m), envinner);
        const envinner_2 = MakeInnerEnvForTyconRef(cenv_1, envinner_1, tcref, false);
        const patternInput = mapFold((f = (newOk = new ImplictlyBoundTyparsAllowed(2), occ = new ItemOccurence(2), function (tpenv_1, ty) {
          return TcTypeAndRecover(cenv_1, newOk, checkCxs, occ, envinner_2, tpenv_1, ty);
        }), function (s, tupledArg_1) {
          return mapFoldFst(f, s, tupledArg_1[0], tupledArg_1[1]);
        }), tpenv, typeDefCore.data[2], ofArray);

        if (firstPass) {
          tycon.entity_attribs = attrs;
        }

        let patternInput_2;

        switch (typeDefCore.data[1].tag) {
          case 3:
            const kind = InferTyconKind(cenv_1.g, typeDefCore.data[1].data[0], attrs, typeDefCore.data[1].data[2], typeDefCore.data[1].data[3], inSig, typeDefCore.data[1].data[4], typeDefCore.data[1].data[7]);
            const inherits = map_1(function (tupledArg_2) {
              return [tupledArg_2[0], tupledArg_2[1]];
            }, typeDefCore.data[1].data[1]);
            const inheritedTys = mapFold((f_1 = (newOk_1 = new ImplictlyBoundTyparsAllowed(2), occ_1 = new ItemOccurence(2), function (tpenv_2, ty_1) {
              return TcTypeAndRecover(cenv_1, newOk_1, checkCxs, occ_1, envinner_2, tpenv_2, ty_1);
            }), function (s_1, tupledArg_3) {
              return mapFoldFst(f_1, s_1, tupledArg_3[0], tupledArg_3[1]);
            }), tpenv, inherits, ofArray)[0];
            let patternInput_1;

            if (kind.tag === 2) {
              iterate(function (tupledArg_4) {
                errorR(new _Error(SR.tcInterfacesShouldUseInheritNotInterface(), tupledArg_4[1]));
              }, typeDefCore.data[2]);
              patternInput_1 = [append(patternInput[0], inheritedTys), new List()];
            } else {
              patternInput_1 = [patternInput[0], inheritedTys];
            }

            patternInput_2 = [patternInput_1[0], patternInput_1[1]];
            break;

          case 1:
          case 6:
          case 5:
          case 0:
          case 4:
          case 2:
            patternInput_2 = [patternInput[0], new List()];
            break;

          default:
            patternInput_2 = [new List(), new List()];
        }

        for (let forLoopVar of patternInput_2[0]) {
          if (firstPass ? isErasedType(cenv_1.g, forLoopVar[0]) : false) {
            errorR(new _Error(SR.tcCannotInheritFromErasedType(), forLoopVar[1]));
          }
        }

        if (firstPass) {
          iterate(function (tupledArg_5) {
            PublishInterface(cenv_1, envinner_2.DisplayEnv, tcref, tupledArg_5[1], false, tupledArg_5[0]);
          }, patternInput_2[0]);
        }

        return [attrs, patternInput_2[1], typeDefCore.data[1], tycon];
      } else {
        return null;
      }
    }, envMutRec, mutRecDefns);
    MutRecShapes.iterTycons((action = function (tupledArg_6) {
      const m_1 = tupledArg_6[3].Range;

      try {
        let _super;

        switch (tupledArg_6[2].tag) {
          case 6:
            _super = null;
            break;

          case 5:
            _super = null;
            break;

          case 4:
            _super = null;
            break;

          case 0:
          case 2:
            if (tupledArg_6[3].IsStructRecordOrUnionTycon) {
              _super = cenv_1.g.system_Value_typ;
            } else {
              _super = null;
            }

            break;

          case 3:
            const kind_1 = InferTyconKind(cenv_1.g, tupledArg_6[2].data[0], tupledArg_6[0], tupledArg_6[2].data[2], tupledArg_6[2].data[3], inSig, tupledArg_6[2].data[4], m_1);

            if (tupledArg_6[1].tail != null) {
              if (tupledArg_6[1].tail.tail == null) {
                if (!firstPass ? !(kind_1.tag === 1 ? true : false) : false) {
                  errorR(new _Error(SR.tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes(), tupledArg_6[1].head[1]));
                }

                CheckSuperType(cenv_1, tupledArg_6[1].head[0], tupledArg_6[1].head[1]);

                if (isTyparTy(cenv_1.g, tupledArg_6[1].head[0])) {
                  if (firstPass) {
                    errorR(new _Error(SR.tcCannotInheritFromVariableType(), tupledArg_6[1].head[1]));
                  }

                  _super = cenv_1.g.obj_ty;
                } else {
                  _super = tupledArg_6[1].head[0];
                }
              } else {
                _super = error_1(new _Error(SR.tcTypesCannotInheritFromMultipleConcreteTypes(), m_1));
              }
            } else {
              switch (kind_1.tag) {
                case 3:
                  _super = cenv_1.g.system_Value_typ;
                  break;

                case 10:
                  _super = cenv_1.g.system_MulticastDelegate_typ;
                  break;

                case 7:
                case 1:
                case 2:
                  _super = null;
                  break;

                default:
                  _super = error_1(new InternalError("should have inferred tycon kind", m_1));
              }
            }

            break;

          case 1:
            _super = cenv_1.g.system_Enum_typ;
            break;

          default:
            _super = cenv_1.g.exn_ty;
        }

        tupledArg_6[3].TypeContents.tcaug_super = _super;
      } catch (e) {
        errorRecovery(e, m_1);
      }
    }, function (option) {
      iterate(action, defaultArg(option, [], $var398 => [$var398]));
    }), tyconWithImplementsL);
  };

  const TcTyconDefnCore_Phase1G_EstablishRepresentation = function (cenv_1, envinner, tpenv, inSig, _arg1, tycon, attrs) {
    var matchValue;
    var tcAttributes;
    var arg10__1;
    const m = tycon.Range;

    try {
      const id = tycon.Id;
      const thisTyconRef = mkLocalTyconRef(tycon);
      const innerParent = new ParentRef(0, thisTyconRef);
      const patternInput = generalizeTyconRef(thisTyconRef);
      const hasAbstractAttr = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_AbstractClassAttribute, attrs);
      const hasSealedAttr = (cenv_1.g.compilingFslib ? id.idText === "Unit" : false) ? true : TryFindFSharpBoolAttribute(cenv_1.g, cenv_1.g.attrib_SealedAttribute, attrs);
      const hasMeasureAttr = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_MeasureAttribute, attrs);
      const hasMeasureableAttr = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_MeasureableAttribute, attrs);
      const hasCLIMutable = HasFSharpAttribute(cenv_1.g, cenv_1.g.attrib_CLIMutableAttribute, attrs);
      const structLayoutAttr = TryFindFSharpInt32Attribute(cenv_1.g, cenv_1.g.attrib_StructLayoutAttribute, attrs);
      const hasAllowNullLiteralAttr = equals(TryFindFSharpBoolAttribute(cenv_1.g, cenv_1.g.attrib_AllowNullLiteralAttribute, attrs), true);

      if (hasAbstractAttr) {
        tycon.TypeContents.tcaug_abstract = true;
      }

      tycon.entity_attribs = attrs;

      const noAbstractClassAttributeCheck = function () {
        if (hasAbstractAttr) {
          errorR(new _Error(SR.tcOnlyClassesCanHaveAbstract(), m));
        }
      };

      const noAllowNullLiteralAttributeCheck = function () {
        if (hasAllowNullLiteralAttr) {
          errorR(new _Error(SR.tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute(), m));
        }
      };

      const allowNullLiteralAttributeCheck = function () {
        if (hasAllowNullLiteralAttr) {
          iterate(function (ty) {
            if (!TypeNullIsExtraValue(cenv_1.g, m, ty)) {
              errorR(new _Error(SR.tcAllowNullTypesMayOnlyInheritFromAllowNullTypes(), m));
            }
          }, defaultArg(tycon.TypeContents.tcaug_super, [], $var399 => [$var399]));
          iterate(function (ty_1) {
            if (!TypeNullIsExtraValue(cenv_1.g, m, ty_1)) {
              errorR(new _Error(SR.tcAllowNullTypesMayOnlyInheritFromAllowNullTypes(), m));
            }
          }, tycon.ImmediateInterfaceTypesOfFSharpTycon);
        }
      };

      const structLayoutAttributeCheck = function (allowed) {
        const explicitKind = 2 | 0;

        if (structLayoutAttr == null) {} else if (allowed) {
          if (getValue(structLayoutAttr) === explicitKind) {
            warning(new PossibleUnverifiableCode(m));
          }
        } else if (thisTyconRef.Typars(m).tail == null) {
          errorR(new _Error(SR.tcOnlyStructsCanHaveStructLayout(), m));
        } else {
          errorR(new _Error(SR.tcGenericTypesCannotHaveStructLayout(), m));
        }
      };

      const hiddenReprChecks = function (hasRepr) {
        structLayoutAttributeCheck(false);

        if (equals(hasSealedAttr, false) ? true : (hasRepr ? !equals(hasSealedAttr, true) : false) ? !(id.idText === "Unit" ? cenv_1.g.compilingFslib : false) : false) {
          errorR(new _Error(SR.tcRepresentationOfTypeHiddenBySignature(), m));
        }

        if (hasAbstractAttr) {
          errorR(new _Error(SR.tcOnlyClassesCanHaveAbstract(), m));
        }
      };

      const noMeasureAttributeCheck = function () {
        if (hasMeasureAttr) {
          errorR(new _Error(SR.tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure(), m));
        }
      };

      const noCLIMutableAttributeCheck = function () {
        if (hasCLIMutable) {
          errorR(new _Error(SR.tcThisTypeMayNotHaveACLIMutableAttribute(), m));
        }
      };

      const noSealedAttributeCheck = function (k) {
        if (equals(hasSealedAttr, true)) {
          errorR(new _Error(k(), m));
        }
      };

      const noFieldsCheck = function (fields_) {
        if (fields_.tail != null) {
          errorR(new _Error(SR.tcInterfaceTypesAndDelegatesCannotContainFields(), fields_.head.Range));
        }
      };

      const envinner_1 = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), tycon.Typars(m), envinner);
      const envinner_2 = MakeInnerEnvForTyconRef(cenv_1, envinner_1, thisTyconRef, false);

      const writeFakeRecordFieldsToSink = function (fields) {
        const nenv = envinner_2.NameEnv;

        for (let fspec of fields) {
          if (!fspec.IsCompilerGenerated) {
            const info = new RecdFieldInfo(0, [patternInput[0], thisTyconRef.MakeNestedRecdFieldRef(fspec)]);
            const nenv_ = AddFakeNameToNameEnv(fspec.Name, nenv, new Item(5, info));
            const item = FreshenRecdFieldRef(cenv_1.nameResolver, m, thisTyconRef.MakeNestedRecdFieldRef(fspec));
            CallNameResolutionSink(cenv_1.tcSink, fspec.Range, nenv, item, item, emptyTyparInst, new ItemOccurence(0), envinner_2.DisplayEnv, envinner_2.eAccessRights);
            CallEnvSink(cenv_1.tcSink, fspec.Range, nenv_, envinner_2.eAccessRights);
          }
        }
      };

      const writeFakeUnionCtorsToSink = function (unionCases) {
        const nenv_1 = envinner_2.NameEnv;

        for (let unionCase of unionCases) {
          const info_1 = new UnionCaseInfo(0, [patternInput[0], mkUnionCaseRef(thisTyconRef, unionCase.Id.idText)]);
          const nenv__1 = AddFakeNameToNameEnv(unionCase.Id.idText, nenv_1, new Item(1, [info_1, false]));
          const item_1 = new Item(1, [info_1, false]);
          CallNameResolutionSink(cenv_1.tcSink, unionCase.Range, nenv_1, item_1, item_1, emptyTyparInst, new ItemOccurence(0), envinner_2.DisplayEnv, envinner_2.eAccessRights);
          CallEnvSink(cenv_1.tcSink, unionCase.Id.idRange, nenv__1, envinner_2.eAccessRights);
        }
      };

      let patternInput_6;

      if (_arg1.data[1].tag === 7) {
        const parent = new ParentRef(0, mkLocalTyconRef(tycon));
        TcExceptionDeclarations.TcExnDefnCore_Phase1G_EstablishRepresentation(cenv_1, envinner_2, parent, tycon, _arg1.data[1].data);
        patternInput_6 = [new TyconRepresentation(6), null, new SafeInitData(1)];
      } else if (_arg1.data[1].tag === 6) {
        hiddenReprChecks(false);
        noAllowNullLiteralAttributeCheck();

        if (hasMeasureAttr) {
          const repr = new TyconRepresentation(0, new TyconObjModelData(new TyconObjModelKind(0), new List(), MakeRecdFieldsTable(new List())));
          patternInput_6 = [repr, null, new SafeInitData(1)];
        } else {
          patternInput_6 = [new TyconRepresentation(6), null, new SafeInitData(1)];
        }
      } else {
        const activePatternResult43510 = _TyconCoreAbbrevThatIsReallyAUnion___(hasMeasureAttr, envinner_2, id, _arg1.data[1]);

        if (activePatternResult43510 != null) {
          structLayoutAttributeCheck(false);
          noAllowNullLiteralAttributeCheck();
          TcRecdUnionAndEnumDeclarations.CheckUnionCaseName(cenv_1, getValue(activePatternResult43510)[0].idText, getValue(activePatternResult43510)[0].idRange);
          const unionCase_1 = NewUnionCase(getValue(activePatternResult43510)[0], getValue(activePatternResult43510)[0].idText, new List(), patternInput[1], new List(), XmlDoc.Empty, tycon.Accessibility);
          writeFakeUnionCtorsToSink(ofArray([unionCase_1]));
          patternInput_6 = [MakeUnionRepr(ofArray([unionCase_1])), null, new SafeInitData(1)];
        } else if (_arg1.data[1].tag === 5) {
          if (_arg1.data[1].data[0].tag === 0) {
            if (equals(hasSealedAttr, true)) {
              errorR(new _Error(SR.tcAbbreviatedTypesCannotBeSealed(), m));
            }

            noAbstractClassAttributeCheck();
            noAllowNullLiteralAttributeCheck();

            if (hasMeasureableAttr) {
              const kind = hasMeasureAttr ? new TyparKind(1) : new TyparKind(0);
              const patternInput_1 = TcTypeOrMeasureAndRecover(kind, cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(0), new ItemOccurence(2), envinner_2, tpenv, _arg1.data[1].data[1]);
              patternInput_6 = [new TyconRepresentation(5, patternInput_1[0]), null, new SafeInitData(1)];
            } else if (matchValue = tycon.TypeReprInfo, matchValue.tag === 6 ? false : true) {
              patternInput_6 = [tycon.TypeReprInfo, null, new SafeInitData(1)];
            } else {
              patternInput_6 = [new TyconRepresentation(6), null, new SafeInitData(1)];
            }
          } else {
            patternInput_6 = [new TyconRepresentation(6), null, new SafeInitData(1)];
          }
        } else if (_arg1.data[1].tag === 0) {
          noCLIMutableAttributeCheck();
          noMeasureAttributeCheck();
          noSealedAttributeCheck(function () {
            return SR.tcTypesAreAlwaysSealedDU();
          });
          noAbstractClassAttributeCheck();
          noAllowNullLiteralAttributeCheck();
          structLayoutAttributeCheck(false);
          const unionCases_1 = TcRecdUnionAndEnumDeclarations.TcUnionCaseDecls(cenv_1, envinner_2, innerParent, patternInput[1], tpenv, _arg1.data[1].data[1]);

          if (tycon.IsStructRecordOrUnionTycon ? unionCases_1.length > 1 : false) {
            const fieldNames = toList(delay(function () {
              return collect_1(function (uc) {
                return map_2(function (ft) {
                  return ft.Name;
                }, uc.FieldTable.TrueInstanceFieldsAsList);
              }, unionCases_1);
            }));

            if (toList(distinct(fieldNames)).length !== fieldNames.length) {
              errorR(new _Error(SR.tcStructUnionMultiCaseDistinctFields(), m));
            }
          }

          writeFakeUnionCtorsToSink(unionCases_1);
          patternInput_6 = [MakeUnionRepr(unionCases_1), null, new SafeInitData(1)];
        } else if (_arg1.data[1].tag === 2) {
          noMeasureAttributeCheck();
          noSealedAttributeCheck(function () {
            return SR.tcTypesAreAlwaysSealedRecord();
          });
          noAbstractClassAttributeCheck();
          noAllowNullLiteralAttributeCheck();
          structLayoutAttributeCheck(true);
          const recdFields = TcRecdUnionAndEnumDeclarations.TcNamedFieldDecls(cenv_1, envinner_2, innerParent, false, tpenv, _arg1.data[1].data[1]);
          CheckDuplicates(function (f) {
            return f.Id;
          }, "field", recdFields);
          writeFakeRecordFieldsToSink(recdFields);
          patternInput_6 = [new TyconRepresentation(1, MakeRecdFieldsTable(recdFields)), null, new SafeInitData(1)];
        } else if (_arg1.data[1].tag === 4) {
          noCLIMutableAttributeCheck();
          noMeasureAttributeCheck();
          noSealedAttributeCheck(function () {
            return SR.tcTypesAreAlwaysSealedAssemblyCode();
          });
          noAllowNullLiteralAttributeCheck();
          structLayoutAttributeCheck(false);
          noAbstractClassAttributeCheck();
          patternInput_6 = [new TyconRepresentation(4, _arg1.data[1].data[0]), null, new SafeInitData(1)];
        } else if (_arg1.data[1].tag === 3) {
          const userFields = TcRecdUnionAndEnumDeclarations.TcNamedFieldDecls(cenv_1, envinner_2, innerParent, _arg1.data[1].data[5], tpenv, _arg1.data[1].data[3]);
          const implicitStructFields = toList(delay(function () {
            if (_arg1.data[1].data[6] != null) {
              if (tycon.IsFSharpStructOrEnumTycon) {
                const patternInput_2 = TcSimplePatsOfUnknownType(cenv_1, true, new CheckConstraints(0), envinner_2, tpenv, new SynSimplePats(0, [getValue(_arg1.data[1].data[6]), m]));
                const names = patternInput_2[1][1];
                return collect_1(function (arg) {
                  const ty_2 = names.get(arg).Type;
                  const id_1 = names.get(arg).Ident;
                  const taccess = new Accessibility(0, ofArray([envinner_2.eAccessPath]));
                  return singleton(NewRecdField(false, null, id_1, false, ty_2, false, false, new List(), new List(), XmlDoc.Empty, taccess, true));
                }, patternInput_2[0]);
              } else {
                return empty();
              }
            } else {
              return empty();
            }
          }));
          CheckDuplicates(function (f_1) {
            return f_1.Id;
          }, "field", append(userFields, implicitStructFields));
          writeFakeRecordFieldsToSink(userFields);
          const superTy = tycon.TypeContents.tcaug_super;
          const containerInfo = TyconContainerInfo(innerParent, thisTyconRef, thisTyconRef.Typars(m), new SafeInitData(1));
          const kind_1 = InferTyconKind(cenv_1.g, _arg1.data[1].data[0], attrs, _arg1.data[1].data[2], _arg1.data[1].data[3], inSig, _arg1.data[1].data[4], m);

          if (kind_1.tag === 7) {
            hiddenReprChecks(true);
            noAllowNullLiteralAttributeCheck();
            patternInput_6 = [new TyconRepresentation(6), null, new SafeInitData(1)];
          } else {
            iterate(function (ty_3) {
              let m_2;

              if (_arg1.data[1].data[1].tail != null) {
                const m_1 = _arg1.data[1].data[1].head[1];
                m_2 = m_1;
              } else {
                m_2 = m;
              }

              if (isSealedTy(cenv_1.g, ty_3)) {
                errorR(new _Error(SR.tcCannotInheritFromSealedType(), m_2));
              } else if (!isClassTy(cenv_1.g, ty_3)) {
                errorR(new _Error(SR.tcCannotInheritFromInterfaceType(), m_2));
              }
            }, defaultArg(superTy, [], $var400 => [$var400]));
            let kind_2;

            switch (kind_1.tag) {
              case 3:
                noCLIMutableAttributeCheck();
                noSealedAttributeCheck(function () {
                  return SR.tcTypesAreAlwaysSealedStruct();
                });
                noAbstractClassAttributeCheck();
                noAllowNullLiteralAttributeCheck();

                if (!(_arg1.data[1].data[2].tail == null)) {
                  errorR(new _Error(SR.tcStructTypesCannotContainAbstractMembers(), m));
                }

                structLayoutAttributeCheck(true);
                kind_2 = new TyconObjModelKind(2);
                break;

              case 2:
                if (equals(hasSealedAttr, true)) {
                  errorR(new _Error(SR.tcInterfaceTypesCannotBeSealed(), m));
                }

                noCLIMutableAttributeCheck();
                structLayoutAttributeCheck(false);
                noAbstractClassAttributeCheck();
                allowNullLiteralAttributeCheck();
                noFieldsCheck(userFields);
                kind_2 = new TyconObjModelKind(1);
                break;

              case 1:
                noCLIMutableAttributeCheck();
                structLayoutAttributeCheck(!_arg1.data[1].data[5]);
                allowNullLiteralAttributeCheck();
                kind_2 = new TyconObjModelKind(0);
                break;

              case 10:
                noCLIMutableAttributeCheck();
                noSealedAttributeCheck(function () {
                  return SR.tcTypesAreAlwaysSealedDelegate();
                });
                structLayoutAttributeCheck(false);
                noAllowNullLiteralAttributeCheck();
                noAbstractClassAttributeCheck();
                noFieldsCheck(userFields);
                const patternInput_3 = TcTypeAndRecover(cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(0), new ItemOccurence(2), envinner_2, tpenv, kind_1.data[0]);
                const patternInput_4 = GetTopValTypeInCompiledForm(cenv_1.g, TranslatePartialArity(new List(), (tcAttributes = function (attrTgt, synAttribs) {
                  return TcAttributes(cenv_1, envinner_2, attrTgt, synAttribs);
                }, function (arg20_) {
                  return TranslateTopValSynInfo(m, tcAttributes, arg20_);
                })(kind_1.data[1])), patternInput_3[0], m);

                if (patternInput_4[1].length < 1) {
                  error_1(new _Error(SR.tcInvalidDelegateSpecification(), m));
                }

                if (patternInput_4[1].length > 1) {
                  error_1(new _Error(SR.tcDelegatesCannotBeCurried(), m));
                }

                const ttps = thisTyconRef.Typars(m);

                const fparams = function (list) {
                  return map_1(function (tupledArg) {
                    return MakeSlotParam(tupledArg[0], tupledArg[1]);
                  }, list);
                }(patternInput_4[1].head);

                kind_2 = new TyconObjModelKind(3, MakeSlotSig("Invoke", patternInput[1], ttps, new List(), ofArray([fparams]), patternInput_4[2]));
                break;

              default:
                kind_2 = error_1(new InternalError("should have inferred tycon kind", m));
            }

            let baseIdOpt_1;

            switch (_arg1.data[1].tag) {
              case 7:
                baseIdOpt_1 = null;
                break;

              case 5:
                baseIdOpt_1 = null;
                break;

              case 0:
                baseIdOpt_1 = null;
                break;

              case 4:
                baseIdOpt_1 = null;
                break;

              case 2:
                baseIdOpt_1 = null;
                break;

              case 1:
                baseIdOpt_1 = null;
                break;

              case 3:
                if (_arg1.data[1].data[1].tail != null) {
                  const m_3 = _arg1.data[1].data[1].head[1];
                  const baseIdOpt = _arg1.data[1].data[1].head[2];

                  if (baseIdOpt != null) {
                    baseIdOpt_1 = getValue(baseIdOpt);
                  } else {
                    baseIdOpt_1 = ident("base", m_3);
                  }
                } else {
                  baseIdOpt_1 = null;
                }

                break;

              default:
                baseIdOpt_1 = null;
            }

            const abstractSlots = toList(delay(function () {
              return collect_1(function (matchValue_1) {
                CheckMemberFlags(null, new NewSlotsOK(0), new OverridesOK(0), matchValue_1[1], matchValue_1[0].data[10]);
                const slots = TcAndPublishValSpec(cenv_1, envinner_2, containerInfo, new DeclKind(0), matchValue_1[1], tpenv, matchValue_1[0])[0];
                return map_2(function (slot) {
                  return mkLocalValRef(slot);
                }, slots);
              }, _arg1.data[1].data[2]);
            }));
            const baseValOpt = MakeAndPublishBaseVal(cenv_1, envinner_2, baseIdOpt_1, superOfTycon(cenv_1.g, tycon));
            const safeInitInfo = ComputeInstanceSafeInitInfo(cenv_1, envinner_2, thisTyconRef.Range, patternInput[1]);
            const safeInitFields = safeInitInfo.tag === 1 ? new List() : ofArray([safeInitInfo.data[1]]);
            const repr_1 = new TyconRepresentation(0, new TyconObjModelData(kind_2, abstractSlots, MakeRecdFieldsTable(append(userFields, append(implicitStructFields, safeInitFields)))));
            patternInput_6 = [repr_1, baseValOpt, safeInitInfo];
          }
        } else if (_arg1.data[1].tag === 1) {
          const patternInput_5 = TcRecdUnionAndEnumDeclarations.TcEnumDecls(cenv_1, envinner_2, innerParent, patternInput[1], _arg1.data[1].data[0]);
          const kind_3 = new TyconObjModelKind(4);
          structLayoutAttributeCheck(false);
          noCLIMutableAttributeCheck();
          noSealedAttributeCheck(function () {
            return SR.tcTypesAreAlwaysSealedEnum();
          });
          noAllowNullLiteralAttributeCheck();
          const vfld = NewRecdField(false, null, ident("value__", _arg1.data[1].data[1]), false, patternInput_5[0], false, false, new List(), new List(), XmlDoc.Empty, taccessPublic, true);

          if (!exists_1(CurriedLambda(function (arg10_, arg20__1) {
            return typeEquiv(cenv_1.g, arg10_, arg20__1);
          })(patternInput_5[0]), ofArray([cenv_1.g.int32_ty, cenv_1.g.int16_ty, cenv_1.g.sbyte_ty, cenv_1.g.int64_ty, cenv_1.g.char_ty, cenv_1.g.bool_ty, cenv_1.g.uint32_ty, cenv_1.g.uint16_ty, cenv_1.g.byte_ty, cenv_1.g.uint64_ty]))) {
            errorR(new _Error(SR.tcInvalidTypeForLiteralEnumeration(), _arg1.data[1].data[1]));
          }

          writeFakeRecordFieldsToSink(patternInput_5[1]);
          const repr_2 = new TyconRepresentation(0, new TyconObjModelData(kind_3, new List(), MakeRecdFieldsTable(new List(vfld, patternInput_5[1]))));
          patternInput_6 = [repr_2, null, new SafeInitData(1)];
        } else {
          throw new Error("C:/projects/fcs/src/fsharp/TypeChecker.fs", 15214, 22);
        }
      }

      tycon.entity_tycon_repr = patternInput_6[0];

      if (TyconHasUseNullAsTrueValueAttribute(cenv_1.g, tycon) ? !CanHaveUseNullAsTrueValueAttribute(cenv_1.g, tycon) : false) {
        errorR(new _Error(SR.tcInvalidUseNullAsTrueValue(), m));
      }

      const matchValue_2 = tryFind((arg10__1 = cenv_1.g.attrib_ConditionalAttribute, function (arg20__2) {
        return IsMatchingFSharpAttribute(cenv_1.g, arg10__1, arg20__2);
      }), attrs);

      if (matchValue_2 != null) {
        if (!ExistsInEntireHierarchyOfType(function (t) {
          return typeEquiv(cenv_1.g, t, mkAppTy(cenv_1.g.tcref_System_Attribute, new List()));
        }, cenv_1.g, cenv_1.amap, m, new AllowMultiIntfInstantiations(0), patternInput[1])) {
          errorR(new _Error(SR.tcConditionalAttributeUsage(), m));
        }
      }

      return [patternInput_6[1], patternInput_6[2]];
    } catch (e) {
      errorRecovery(e, m);
      return [null, new SafeInitData(1)];
    }
  };

  const TcTyconDefnCore_CheckForCyclicAbbreviations = function (tycons) {
    const edgesFrom = function (tycon) {
      const accInAbbrevType = function (ty, acc) {
        accInAbbrevType: while (true) {
          const matchValue = stripTyparEqns(ty);
          const $var401 = matchValue.tag === 4 ? [1, matchValue.data[0].data[0], matchValue.data[1]] : matchValue.tag === 1 ? [1, matchValue.data[0], matchValue.data[1]] : matchValue.tag === 3 ? [2] : matchValue.tag === 5 ? [3] : matchValue.tag === 0 ? [4] : matchValue.tag === 6 ? [5] : [0];

          switch ($var401[0]) {
            case 0:
              return accInAbbrevTypes(matchValue.data[1], acc);

            case 1:
              const tycon2 = $var401[1].Deref;
              const acc_1 = accInAbbrevTypes($var401[2], acc);

              if (exists_1(CurriedLambda(function (x, y) {
                return x === y;
              })(tycon2), tycons)) {
                return new List([tycon, tycon2], acc_1);
              } else if ($var401[1].IsTypeAbbrev) {
                ty = reduceTyconRefAbbrev($var401[1], $var401[2]);
                acc = acc_1;
                continue accInAbbrevType;
              } else {
                return acc_1;
              }

            case 2:
              ty = matchValue.data[0];
              acc = accInAbbrevType(matchValue.data[1], acc);
              continue accInAbbrevType;

            case 3:
              return acc;

            case 4:
              ty = matchValue.data[1];
              acc = acc;
              continue accInAbbrevType;

            case 5:
              return accInMeasure(matchValue.data, acc);
          }
        }
      };

      const accInMeasure = function (ms, acc_2) {
        accInMeasure: while (true) {
          const matchValue_1 = stripUnitEqns(ms);
          const $var402 = matchValue_1.tag === 1 ? exists_1(CurriedLambda(function (x_1, y_1) {
            return x_1 === y_1;
          })(matchValue_1.data.Deref), tycons) ? [0, matchValue_1.data] : [1] : [1];

          switch ($var402[0]) {
            case 0:
              return new List([tycon, $var402[1].Deref], acc_2);

            case 1:
              const $var403 = matchValue_1.tag === 1 ? matchValue_1.data.IsTypeAbbrev ? [0, matchValue_1.data] : [1] : [1];

              switch ($var403[0]) {
                case 0:
                  ms = reduceTyconRefAbbrevMeasureable($var403[1]);
                  acc_2 = acc_2;
                  continue accInMeasure;

                case 1:
                  if (matchValue_1.tag === 2) {
                    ms = matchValue_1.data[0];
                    acc_2 = accInMeasure(matchValue_1.data[1], acc_2);
                    continue accInMeasure;
                  } else if (matchValue_1.tag === 3) {
                    ms = matchValue_1.data;
                    acc_2 = acc_2;
                    continue accInMeasure;
                  } else {
                    return acc_2;
                  }

              }

          }
        }
      };

      const accInAbbrevTypes = function (tys, acc_3) {
        return foldBack(accInAbbrevType, tys, acc_3);
      };

      const matchValue_2 = tycon.TypeAbbrev;

      if (matchValue_2 != null) {
        return accInAbbrevType(getValue(matchValue_2), new List());
      } else {
        return new List();
      }
    };

    const edges = collect(edgesFrom, tycons);
    const graph = new Graph(function (tc) {
      return tc.Stamp;
    }, tycons, edges);
    graph.IterateCycles(function (path) {
      const tycon_1 = path.head;
      tycon_1.SetTypeAbbrev(null);
      tycon_1.entity_tycon_repr = new TyconRepresentation(6);
      errorR(new _Error(SR.tcTypeDefinitionIsCyclic(), tycon_1.Range));
    });
  };

  const TcTyconDefnCore_CheckForCyclicStructsAndInheritance = __exports.TcTyconDefnCore_CheckForCyclicStructsAndInheritance = function (cenv_1, tycons) {
    const edgesFrom = function (tycon) {
      const insertEdgeToTycon = function (tycon2, acc) {
        if (exists_1(CurriedLambda(function (x, y) {
          return x === y;
        })(tycon2), tycons) ? !exists_1(function (tupledArg) {
          return tupledArg[0] === tycon ? tupledArg[1] === tycon2 : false;
        }, acc) : false) {
          return new List([tycon, tycon2], acc);
        } else {
          return acc;
        }
      };

      const insertEdgeToType = function (ty, acc_1) {
        const matchValue = tryDestAppTy(cenv_1.g, ty);

        if (matchValue == null) {
          return acc_1;
        } else {
          return insertEdgeToTycon(getValue(matchValue).Deref, acc_1);
        }
      };

      const accStructField = function (structTycon, structTyInst, fspec, tupledArg_1) {
        const fieldTy = actualTyOfRecdFieldForTycon(structTycon, structTyInst, fspec);
        return accStructFieldType(structTycon, structTyInst, fspec, fieldTy, [tupledArg_1[0], tupledArg_1[1]]);
      };

      const accStructFieldType = function (structTycon_1, structTyInst_1, fspec_1, fieldTy_1, tupledArg_2) {
        accStructFieldType: while (true) {
          const fieldTy_2 = stripTyparEqns(fieldTy_1);
          const $var404 = fieldTy_2.tag === 1 ? fieldTy_2.data[0].IsStructOrEnumTycon ? [0, fieldTy_2.data[0], fieldTy_2.data[1]] : [1] : [1];

          switch ($var404[0]) {
            case 0:
              const tycon2_1 = $var404[1].Deref;
              const specialCaseStaticField = (fspec_1.IsStatic ? structTycon_1 === tycon2_1 : false) ? List_1.lengthsEqAndForall2(function (ty1, ty2) {
                const matchValue_1 = tryDestTyparTy(cenv_1.g, ty1);

                if (matchValue_1 != null) {
                  const matchValue_2 = tryDestTyparTy(cenv_1.g, ty2);

                  if (matchValue_2 != null) {
                    return typarEq(getValue(matchValue_1), getValue(matchValue_2));
                  } else {
                    return false;
                  }
                } else {
                  return false;
                }
              }, structTyInst_1, $var404[2]) : false;

              if (specialCaseStaticField) {
                return [tupledArg_2[0], tupledArg_2[1]];
              } else {
                const acc_2 = insertEdgeToTycon(tycon2_1, tupledArg_2[1]);
                return accStructInstanceFields(fieldTy_2, tycon2_1, $var404[2], [tupledArg_2[0], acc_2]);
              }

            case 1:
              const $var405 = fieldTy_2.tag === 1 ? fieldTy_2.data[0].IsTypeAbbrev ? [0, fieldTy_2.data[0], fieldTy_2.data[1]] : [1] : [1];

              switch ($var405[0]) {
                case 0:
                  structTycon_1 = structTycon_1;
                  structTyInst_1 = structTyInst_1;
                  fspec_1 = fspec_1;
                  fieldTy_1 = reduceTyconRefAbbrev($var405[1], $var405[2]);
                  tupledArg_2 = [tupledArg_2[0], tupledArg_2[1]];
                  continue accStructFieldType;

                case 1:
                  return [tupledArg_2[0], tupledArg_2[1]];
              }

          }
        }
      };

      const accStructFields = function (includeStaticFields, ty_1, structTycon_2, tinst, tupledArg_3) {
        if (exists_1(function (arg20_) {
          return typeEquiv(cenv_1.g, ty_1, arg20_);
        }, tupledArg_3[0])) {
          return [tupledArg_3[0], tupledArg_3[1]];
        } else {
          const doneTypes = new List(ty_1, tupledArg_3[0]);
          const fspecs = structTycon_2.IsUnionTycon ? toList(delay(function () {
            return collect_1(function (uc) {
              return map_2(function (c) {
                return c;
              }, uc.FieldTable.AllFieldsAsList);
            }, structTycon_2.UnionCasesArray);
          })) : structTycon_2.AllFieldsAsList;
          const fspecs_1 = filter(function (fspec_2) {
            return includeStaticFields ? true : !fspec_2.IsStatic;
          }, fspecs);
          const patternInput = foldBack(CurriedLambda(accStructField)(structTycon_2, tinst), fspecs_1, [doneTypes, tupledArg_3[1]]);
          return [patternInput[0], patternInput[1]];
        }
      };

      const accStructInstanceFields = function (ty_2, structTycon_3, tinst_1, tupledArg_4) {
        return accStructFields(false, ty_2, structTycon_3, tinst_1, [tupledArg_4[0], tupledArg_4[1]]);
      };

      const accStructAllFields = function (ty_3, structTycon_4, tinst_2, tupledArg_5) {
        return accStructFields(true, ty_3, structTycon_4, tinst_2, [tupledArg_5[0], tupledArg_5[1]]);
      };

      const acc_3 = new List();
      let acc_4;

      if (tycon.IsStructOrEnumTycon) {
        const patternInput_1 = generalizeTyconRef(mkLocalTyconRef(tycon));
        const patternInput_2 = accStructAllFields(patternInput_1[1], tycon, patternInput_1[0], [new List(), acc_3]);
        acc_4 = patternInput_2[1];
      } else {
        acc_4 = acc_3;
      }

      let acc_5;

      const _super = superOfTycon(cenv_1.g, tycon);

      acc_5 = insertEdgeToType(_super, acc_4);
      const acc_6 = foldBack(insertEdgeToType, tycon.ImmediateInterfaceTypesOfFSharpTycon, acc_5);
      return acc_6;
    };

    const edges = collect(edgesFrom, tycons);
    const graph = new Graph(function (tc) {
      return tc.Stamp;
    }, tycons, edges);
    graph.IterateCycles(function (path) {
      const tycon_1 = path.head;
      tycon_1.SetTypeAbbrev(null);
      tycon_1.entity_tycon_repr = new TyconRepresentation(6);
      errorR(new _Error(SR.tcTypeDefinitionIsCyclicThroughInheritance(), tycon_1.Range));
    });
  };

  const TcMutRecDefns_CheckExplicitConstraints = __exports.TcMutRecDefns_CheckExplicitConstraints = function (cenv_1, tpenv, m, checkCxs, envMutRecPrelim, withEnvs) {
    MutRecShapes.iterTyconsWithEnv(function (envForDecls, tupledArg) {
      const matchValue = [tupledArg[0], tupledArg[1]];

      if (matchValue[1] != null) {
        const typeDefCore = matchValue[0][0];
        const tycon = getValue(matchValue[1]);
        const envForTycon = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), tycon.Typars(m), envForDecls);
        const thisTyconRef = mkLocalTyconRef(tycon);
        const envForTycon_1 = MakeInnerEnvForTyconRef(cenv_1, envForTycon, thisTyconRef, false);

        try {
          TcTyparConstraints(cenv_1, new ImplictlyBoundTyparsAllowed(2), checkCxs, new ItemOccurence(2), envForTycon_1, tpenv, typeDefCore.data[0].data[2]);
        } catch (e) {
          errorRecovery(e, m);
        }
      }
    }, envMutRecPrelim, withEnvs);
  };

  const TcMutRecDefns_Phase1 = __exports.TcMutRecDefns_Phase1 = function (mkLetInfo, cenv_1, envInitial, parent, typeNames, inSig, tpenv, m, scopem, mutRecNSInfo, mutRecDefns) {
    var getTyconOpt;
    var getVals;
    var pass;
    var pass_1;
    const withEntities = MutRecShapes.mapWithParent([parent, typeNames, envInitial], function (tupledArg, compInfo, decls) {
      return TcTyconDefnCore_Phase1A_BuildInitialModule(cenv_1, tupledArg[2], tupledArg[0], tupledArg[1], compInfo, decls);
    }, function (tupledArg_1, tupledArg_2) {
      const tyconOpt = tupledArg_2[0].data[5] ? TcTyconDefnCore_Phase1A_BuildInitialTycon(cenv_1, tupledArg_1[2], tupledArg_1[0], tupledArg_2[0]) : null;
      return [[tupledArg_2[0], tupledArg_2[1], tupledArg_1[0]], tyconOpt];
    }, function (tupledArg_3, synBinds) {
      const containerInfo = ModuleOrNamespaceContainerInfo(tupledArg_3[0].tag === 0 ? tupledArg_3[0].data : (() => {
        throw new Error("unreachable");
      })());
      return mkLetInfo(containerInfo, synBinds);
    }, mutRecDefns);
    const patternInput = MutRecShapes.computeEnvs(function (envAbove, _arg4) {
      PublishModuleDefn(cenv_1, envAbove, _arg4.data[1]);
      return MakeInnerEnvWithAcc(envAbove, _arg4.data[1].Id, _arg4.data[0], _arg4.data[1].ModuleOrNamespaceType.ModuleOrNamespaceKind);
    }, function (envAbove_1, _arg5) {
      return envAbove_1;
    }, envInitial, withEntities);
    MutRecBindingChecking.TcMutRecDefns_UpdateModuleContents(mutRecNSInfo, patternInput[1]);
    MutRecShapes.iterTyconsWithEnv(function (envAbove_2, tupledArg_4) {
      iterate(function (tycon) {
        CheckForDuplicateConcreteType(envAbove_2, tycon.LogicalName, tycon.Range);
        PublishTypeDefn(cenv_1, envAbove_2, tycon);
      }, defaultArg(tupledArg_4[1], [], $var406 => [$var406]));
    }, patternInput[0], patternInput[1]);
    MutRecBindingChecking.TcMutRecDefns_UpdateModuleContents(mutRecNSInfo, patternInput[1]);
    const patternInput_1 = (getTyconOpt = function (tuple) {
      return tuple[1];
    }, getVals = function (_arg7) {
      return new List();
    }, function (envInitial_1, mutRecShape) {
      return MutRecBindingChecking.TcMutRecDefns_ComputeEnvs(getTyconOpt, getVals, cenv_1, false, scopem, m, envInitial_1, mutRecShape);
    })(envInitial, withEntities);
    const withAttrs = MutRecShapes.mapTyconsWithEnv(function (envForDecls, tupledArg_5) {
      let res;
      const matchValue = [tupledArg_5[0], tupledArg_5[1]];

      if (matchValue[1] != null) {
        const typeDefCore = matchValue[0][0];
        const tycon_1 = getValue(matchValue[1]);
        res = [tycon_1, TcTyconDefnCore_Phase1B_EstablishBasicKind(cenv_1, inSig, envForDecls, typeDefCore, tycon_1)];
      } else {
        res = null;
      }

      return [tupledArg_5[0], res];
    }, patternInput_1[0], patternInput_1[1]);
    MutRecShapes.iterTyconsWithEnv(function (envForDecls_1, tupledArg_6) {
      const matchValue_1 = [tupledArg_6[0], tupledArg_6[1]];

      if (matchValue_1[1] != null) {
        const typeDefCore_1 = matchValue_1[0][0];
        const tycon_2 = getValue(matchValue_1[1])[0];
        const attrs = getValue(matchValue_1[1])[1][0];
        TcTyconDefnCore_Phase1C_Phase1E_EstablishAbbreviations(cenv_1, envForDecls_1, inSig, tpenv, new TypeRealizationPass(0), typeDefCore_1, tycon_2, attrs);
      }
    }, patternInput_1[0], withAttrs);
    const tycons = choose_1(function (tuple_1) {
      return tuple_1[1];
    }, MutRecShapes.collectTycons(withEntities));
    TcTyconDefnCore_CheckForCyclicAbbreviations(tycons);
    (pass = new TypeRealizationPass(0), function (tupledArg_7) {
      TcTyconDefnCore_Phase1D_Phase1F_EstablishSuperTypesAndInterfaceTypes(cenv_1, tpenv, inSig, pass, tupledArg_7[0], tupledArg_7[1]);
    })([patternInput_1[0], withAttrs]);
    const tyconsWithStructuralTypes = choose_1(function (x) {
      return x;
    }, MutRecShapes.collectTycons(MutRecShapes.mapTyconsWithEnv(function (envForDecls_2, tupledArg_8) {
      const matchValue_2 = [tupledArg_8[0], tupledArg_8[1]];

      if (matchValue_2[1] != null) {
        const typeDefCore_2 = matchValue_2[0][0];
        const tycon_3 = getValue(matchValue_2[1]);
        return [tycon_3, GetStructuralElementsOfTyconDefn(cenv_1, envForDecls_2, tpenv, typeDefCore_2, tycon_3)];
      } else {
        return null;
      }
    }, patternInput_1[0], patternInput_1[1])));
    const scSet = TyconConstraintInference.InferSetOfTyconsSupportingComparable(cenv_1, patternInput_1[0].DisplayEnv, tyconsWithStructuralTypes);
    const seSet = TyconConstraintInference.InferSetOfTyconsSupportingEquatable(cenv_1, patternInput_1[0].DisplayEnv, tyconsWithStructuralTypes);
    MutRecShapes.iterTyconsWithEnv(function (envForDecls_3, tupledArg_9) {
      iterate(function (tycon_4) {
        AddAugmentationDeclarations.AddGenericHashAndComparisonDeclarations(cenv_1, envForDecls_3, scSet, seSet, tycon_4);
      }, defaultArg(tupledArg_9[1], [], $var407 => [$var407]));
    }, patternInput_1[0], patternInput_1[1]);
    TcMutRecDefns_CheckExplicitConstraints(cenv_1, tpenv, m, new CheckConstraints(1), patternInput_1[0], patternInput_1[1]);
    MutRecShapes.iterTyconsWithEnv(function (envForDecls_4, tupledArg_10) {
      iterate(function (tycon_5) {
        var denv;
        iterate((denv = envForDecls_4.DisplayEnv, function (tp) {
          SetTyparRigid(cenv_1.g, denv, m, tp);
        }), tycon_5.Typars(m));
      }, defaultArg(tupledArg_10[1], [], $var408 => [$var408]));
    }, patternInput_1[0], patternInput_1[1]);
    MutRecShapes.iterTyconsWithEnv(function (envForDecls_5, tupledArg_11) {
      const matchValue_3 = [tupledArg_11[0], tupledArg_11[1]];

      if (matchValue_3[1] != null) {
        const typeDefCore_3 = matchValue_3[0][0];
        const tycon_6 = getValue(matchValue_3[1])[0];
        const attrs_1 = getValue(matchValue_3[1])[1][0];
        TcTyconDefnCore_Phase1C_Phase1E_EstablishAbbreviations(cenv_1, envForDecls_5, inSig, tpenv, new TypeRealizationPass(1), typeDefCore_3, tycon_6, attrs_1);
      }
    }, patternInput_1[0], withAttrs);
    (pass_1 = new TypeRealizationPass(1), function (tupledArg_12) {
      TcTyconDefnCore_Phase1D_Phase1F_EstablishSuperTypesAndInterfaceTypes(cenv_1, tpenv, inSig, pass_1, tupledArg_12[0], tupledArg_12[1]);
    })([patternInput_1[0], withAttrs]);
    TcMutRecDefns_CheckExplicitConstraints(cenv_1, tpenv, m, new CheckConstraints(0), patternInput_1[0], patternInput_1[1]);
    const patternInput_2 = MutRecShapes.extendEnvs(function (envForDecls_6, decls_1) {
      const tycons_1 = choose_1(function (_arg1) {
        const $var409 = _arg1.tag === 0 ? _arg1.data[1] != null ? [0, getValue(_arg1.data[1])[0]] : [1] : [1];

        switch ($var409[0]) {
          case 0:
            return $var409[1];

          case 1:
            return null;
        }
      }, decls_1);
      const exns = filter(function (tycon_7) {
        return tycon_7.IsExceptionDecl;
      }, tycons_1);
      const envForDecls_7 = fold(function (env, exnc) {
        return AddLocalExnDefnAndReport(cenv_1.tcSink, scopem, env, exnc);
      }, envForDecls_6, exns);
      return envForDecls_7;
    }, patternInput_1[0], withAttrs);
    const withBaseValsAndSafeInitInfos = MutRecShapes.mapTyconsWithEnv(function (envForDecls_8, tupledArg_13) {
      let info;
      const matchValue_4 = [tupledArg_13[0], tupledArg_13[1]];

      if (matchValue_4[1] != null) {
        const typeDefCore_4 = matchValue_4[0][0];
        const tycon_8 = getValue(matchValue_4[1])[0];
        const attrs_2 = getValue(matchValue_4[1])[1][0];
        info = TcTyconDefnCore_Phase1G_EstablishRepresentation(cenv_1, envForDecls_8, tpenv, inSig, typeDefCore_4, tycon_8, attrs_2);
      } else {
        info = [null, new SafeInitData(1)];
      }

      let patternInput_3;

      if (tupledArg_13[1] != null) {
        const tycon_9 = getValue(tupledArg_13[1])[0];
        const getFinalAttrs = getValue(tupledArg_13[1])[1][1];
        const _prelimAttrs = getValue(tupledArg_13[1])[1][0];
        patternInput_3 = [tycon_9, function () {
          tycon_9.entity_attribs = getFinalAttrs();
        }];
      } else {
        patternInput_3 = [null, function () {}];
      }

      return [tupledArg_13[0], patternInput_3[0], patternInput_3[1], info];
    }, patternInput_2[0], patternInput_2[1]);
    TcTyconDefnCore_CheckForCyclicStructsAndInheritance(cenv_1, tycons);
    return [tycons, patternInput_2[0], withBaseValsAndSafeInitInfos];
  };

  return __exports;
}({});
export const TcDeclarations = function (__exports) {
  const ComputeTyconDeclKind = function (tyconOpt, isAtOriginalTyconDefn, cenv_1, envForDecls, inSig, m, synTypars, synTyparCxs, longPath) {
    var denv;
    let tcref;
    const $var410 = tyconOpt != null ? isAtOriginalTyconDefn ? [0, getValue(tyconOpt)] : [1] : [1];

    switch ($var410[0]) {
      case 0:
        const resInfo = TypeNameResolutionStaticArgsInfo.FromTyArgs(synTypars.length);
        ResolveTypeLongIdent(cenv_1.tcSink, cenv_1.nameResolver, new ItemOccurence(0), new FullyQualifiedFlag(1), envForDecls.eNameResEnv, envForDecls.eAccessRights, longPath, resInfo, new PermitDirectReferenceToGeneratedType(1));
        tcref = mkLocalTyconRef($var410[1]);
        break;

      case 1:
        const resInfo_1 = TypeNameResolutionStaticArgsInfo.FromTyArgs(synTypars.length);
        const matchValue = ResolveTypeLongIdent(cenv_1.tcSink, cenv_1.nameResolver, new ItemOccurence(0), new FullyQualifiedFlag(1), envForDecls.eNameResEnv, envForDecls.eAccessRights, longPath, resInfo_1, new PermitDirectReferenceToGeneratedType(1));

        if (matchValue.tag === 0) {
          tcref = matchValue.data;
        } else if (inSig ? longPath.length === 1 : false) {
          errorR(new Deprecated(SR.tcReservedSyntaxForAugmentation(), m));
          tcref = ResultOrExceptionModule.ForceRaise(matchValue);
        } else {
          tcref = ResultOrExceptionModule.ForceRaise(matchValue);
        }

        break;
    }

    const isInterfaceOrDelegateOrEnum = (tcref.Deref.IsFSharpInterfaceTycon ? true : tcref.Deref.IsFSharpDelegateTycon) ? true : tcref.Deref.IsFSharpEnumTycon;
    const reqTypars = tcref.Typars(m);
    let patternInput;

    if (isAtOriginalTyconDefn) {
      patternInput = [new DeclKind(0), reqTypars];
    } else {
      let isInSameModuleOrNamespace;
      const matchValue_1 = tryFind_1(tcref.LogicalName, envForDecls.eModuleOrNamespaceTypeAccumulator.contents.TypesByMangledName);

      if (matchValue_1 == null) {
        if (cenv_1.g.compilingFslib) {
          isInSameModuleOrNamespace = tcref.LogicalName.indexOf("Tuple`") === 0;
        } else {
          isInSameModuleOrNamespace = false;
        }
      } else {
        isInSameModuleOrNamespace = tyconOrder.Compare(tcref.Deref, getValue(matchValue_1)) === 0;
      }

      const nReqTypars = reqTypars.length | 0;
      const declaredTypars = TcTyparDecls(cenv_1, envForDecls, synTypars);
      const envForTycon = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), declaredTypars, envForDecls);

      const _tpenv = TcTyparConstraints(cenv_1, new ImplictlyBoundTyparsAllowed(2), new CheckConstraints(0), new ItemOccurence(2), envForTycon, emptyUnscopedTyparEnv, synTyparCxs);

      iterate((denv = envForDecls.DisplayEnv, function (tp) {
        SetTyparRigid(cenv_1.g, denv, m, tp);
      }), declaredTypars);

      if (isInSameModuleOrNamespace ? !isInterfaceOrDelegateOrEnum : false) {
        if (nReqTypars !== synTypars.length) {
          warning(new _Error(SR.tcDeclaredTypeParametersForExtensionDoNotMatchOriginal(tcref.DisplayNameWithStaticParametersAndUnderscoreTypars), m));
        }

        if (!typarsAEquiv(cenv_1.g, TypeEquivEnv.Empty, reqTypars, declaredTypars)) {
          warning(new _Error(SR.tcDeclaredTypeParametersForExtensionDoNotMatchOriginal(tcref.DisplayNameWithStaticParametersAndUnderscoreTypars), m));
        }

        patternInput = [new DeclKind(1), reqTypars];
      } else {
        if (isInSameModuleOrNamespace ? isInterfaceOrDelegateOrEnum : false) {
          errorR(new _Error(SR.tcMembersThatExtendInterfaceMustBePlacedInSeparateModule(), tcref.Range));
        }

        if (nReqTypars !== synTypars.length) {
          error_1(new _Error(SR.tcDeclaredTypeParametersForExtensionDoNotMatchOriginal(tcref.DisplayNameWithStaticParametersAndUnderscoreTypars), m));
        }

        if (!typarsAEquiv(cenv_1.g, TypeEquivEnv.Empty, reqTypars, declaredTypars)) {
          errorR(new _Error(SR.tcDeclaredTypeParametersForExtensionDoNotMatchOriginal(tcref.DisplayNameWithStaticParametersAndUnderscoreTypars), m));
        }

        patternInput = [new DeclKind(2), declaredTypars];
      }
    }

    return [patternInput[0], tcref, patternInput[1]];
  };

  const isAugmentationTyconDefnRepr = function (_arg1) {
    const $var411 = _arg1.tag === 3 ? _arg1.data[0].tag === 8 ? [0] : [1] : [1];

    switch ($var411[0]) {
      case 0:
        return true;

      case 1:
        return false;
    }
  };

  const isAutoProperty = function (_arg1) {
    if (_arg1.tag === 10) {
      return true;
    } else {
      return false;
    }
  };

  const isMember = function (_arg1) {
    if (_arg1.tag === 1) {
      return true;
    } else {
      return false;
    }
  };

  const isImplicitCtor = function (_arg1) {
    if (_arg1.tag === 2) {
      return true;
    } else {
      return false;
    }
  };

  const isImplicitInherit = function (_arg1) {
    if (_arg1.tag === 3) {
      return true;
    } else {
      return false;
    }
  };

  const isAbstractSlot = function (_arg1) {
    if (_arg1.tag === 5) {
      return true;
    } else {
      return false;
    }
  };

  const isInterface = function (_arg1) {
    if (_arg1.tag === 6) {
      return true;
    } else {
      return false;
    }
  };

  const isInherit = function (_arg1) {
    if (_arg1.tag === 7) {
      return true;
    } else {
      return false;
    }
  };

  const isField = function (_arg1) {
    if (_arg1.tag === 8) {
      return true;
    } else {
      return false;
    }
  };

  const isTycon = function (_arg1) {
    if (_arg1.tag === 9) {
      return true;
    } else {
      return false;
    }
  };

  const allFalse = function (ps, x) {
    return forAll(function (p) {
      return !p(x);
    }, ps);
  };

  const CheckMembersForm = function (ds) {
    var ps;
    var ps_1;
    const $var412 = ds.tail != null ? isImplicitCtor(ds.head) ? [0, ds.head, ds.tail] : [1] : [1];

    switch ($var412[0]) {
      case 0:
        let ds_1;
        const $var413 = $var412[2].tail != null ? isImplicitInherit($var412[2].head) ? [0, $var412[2].head, $var412[2].tail] : [1] : [1];

        switch ($var413[0]) {
          case 0:
            ds_1 = $var413[2];
            break;

          case 1:
            ds_1 = $var412[2];
            break;
        }

        const patternInput = List_1.takeUntil(function (_arg1) {
          return _arg1.tag === 4 ? false : true;
        }, ds_1);
        const patternInput_1 = List_1.takeUntil((ps = ofArray([function (_arg1_1) {
          return isMember(_arg1_1);
        }, function (_arg1_2) {
          return isAbstractSlot(_arg1_2);
        }, function (_arg1_3) {
          return isInterface(_arg1_3);
        }, function (_arg1_4) {
          return isAutoProperty(_arg1_4);
        }]), function (x) {
          return allFalse(ps, x);
        }), patternInput[1]);
        const $var414 = patternInput_1[1].tail != null ? patternInput_1[1].head.tag === 1 ? [0, patternInput_1[1].head.data[1]] : patternInput_1[1].head.tag === 5 ? [1, patternInput_1[1].head.data[2]] : patternInput_1[1].head.tag === 6 ? [2, patternInput_1[1].head.data[2]] : patternInput_1[1].head.tag === 2 ? [3, patternInput_1[1].head.data[4]] : patternInput_1[1].head.tag === 10 ? [4, patternInput_1[1].head.data[10]] : patternInput_1[1].head.tag === 3 ? [5, patternInput_1[1].head.data[3]] : patternInput_1[1].head.tag === 4 ? [6, patternInput_1[1].head.data[3]] : patternInput_1[1].head.tag === 7 ? [7, patternInput_1[1].head.data[2]] : patternInput_1[1].head.tag === 9 ? [8, patternInput_1[1].head.data[2]] : [9] : [9];

        switch ($var414[0]) {
          case 0:
            errorR(new InternalError("List.takeUntil is wrong, have binding", $var414[1]));
            break;

          case 1:
            errorR(new InternalError("List.takeUntil is wrong, have slotsig", $var414[1]));
            break;

          case 2:
            errorR(new InternalError("List.takeUntil is wrong, have interface", $var414[1]));
            break;

          case 3:
            errorR(new InternalError("implicit class construction with two implicit constructions", $var414[1]));
            break;

          case 4:
            errorR(new InternalError("List.takeUntil is wrong, have auto property", $var414[1]));
            break;

          case 5:
            errorR(new _Error(SR.tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit(), $var414[1]));
            break;

          case 6:
            errorR(new _Error(SR.tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers(), $var414[1]));
            break;

          case 7:
            errorR(new _Error(SR.tcInheritDeclarationMissingArguments(), $var414[1]));
            break;

          case 8:
            errorR(new _Error(SR.tcTypesCannotContainNestedTypes(), $var414[1]));
            break;

          case 9:
            break;
        }

        break;

      case 1:
        const patternInput_2 = List_1.takeUntil((ps_1 = ofArray([function (_arg1_5) {
          return isMember(_arg1_5);
        }, function (_arg1_6) {
          return isAbstractSlot(_arg1_6);
        }, function (_arg1_7) {
          return isInterface(_arg1_7);
        }, function (_arg1_8) {
          return isInherit(_arg1_8);
        }, function (_arg1_9) {
          return isField(_arg1_9);
        }, function (_arg1_10) {
          return isTycon(_arg1_10);
        }]), function (x_1) {
          return allFalse(ps_1, x_1);
        }), ds);
        const $var415 = patternInput_2[1].tail != null ? patternInput_2[1].head.tag === 1 ? [0, patternInput_2[1].head.data[1]] : patternInput_2[1].head.tag === 2 ? [1, patternInput_2[1].head.data[4]] : patternInput_2[1].head.tag === 3 ? [2, patternInput_2[1].head.data[3]] : patternInput_2[1].head.tag === 10 ? [3, patternInput_2[1].head.data[10]] : patternInput_2[1].head.tag === 4 ? patternInput_2[1].head.data[1] ? [6] : [4, patternInput_2[1].head.data[3]] : patternInput_2[1].head.tag === 5 ? [5, patternInput_2[1].head.data[2]] : patternInput_2[1].head.tag === 6 ? [5, patternInput_2[1].head.data[2]] : patternInput_2[1].head.tag === 7 ? [5, patternInput_2[1].head.data[2]] : patternInput_2[1].head.tag === 8 ? [5, patternInput_2[1].head.data[1]] : patternInput_2[1].head.tag === 9 ? [5, patternInput_2[1].head.data[2]] : [6] : [6];

        switch ($var415[0]) {
          case 0:
            errorR(new InternalError("CheckMembersForm: List.takeUntil is wrong", $var415[1]));
            break;

          case 1:
            errorR(new InternalError("CheckMembersForm: implicit ctor line should be first", $var415[1]));
            break;

          case 2:
            errorR(new _Error(SR.tcInheritConstructionCallNotPartOfImplicitSequence(), $var415[1]));
            break;

          case 3:
            errorR(new _Error(SR.tcAutoPropertyRequiresImplicitConstructionSequence(), $var415[1]));
            break;

          case 4:
            errorR(new _Error(SR.tcLetAndDoRequiresImplicitConstructionSequence(), $var415[1]));
            break;

          case 5:
            errorR(new InternalError("CheckMembersForm: List.takeUntil is wrong", $var415[1]));
            break;

          case 6:
            break;
        }

        break;
    }
  };

  const SplitTyconDefn = function (_arg1) {
    const implements1 = choose_1(function (_arg2) {
      return _arg2.tag === 6 ? [_arg2.data[0], _arg2.data[0].Range] : null;
    }, _arg1.data[2]);

    if (_arg1.data[1].tag === 1) {
      const members = new List();
      const core = new MutRecDefnsPhase1DataForTycon(0, [_arg1.data[0], _arg1.data[1].data[0], implements1, false, false, true]);
      return [core, append(members, _arg1.data[2])];
    } else if (_arg1.data[1].tag === 2) {
      const core_1 = new MutRecDefnsPhase1DataForTycon(0, [_arg1.data[0], new SynTypeDefnSimpleRepr(7, _arg1.data[1].data), implements1, false, false, true]);
      return [core_1, _arg1.data[2]];
    } else {
      CheckMembersForm(_arg1.data[1].data[1]);
      const fields = choose_1(function (_arg3) {
        return _arg3.tag === 8 ? _arg3.data[0] : null;
      }, _arg1.data[1].data[1]);
      const implements2 = choose_1(function (_arg4) {
        return _arg4.tag === 6 ? [_arg4.data[0], _arg4.data[0].Range] : null;
      }, _arg1.data[1].data[1]);
      const inherits = choose_1(function (_arg5) {
        return _arg5.tag === 7 ? [_arg5.data[0], _arg5.data[2], _arg5.data[1]] : _arg5.tag === 3 ? [_arg5.data[0], _arg5.data[3], _arg5.data[2]] : null;
      }, _arg1.data[1].data[1]);
      const slotsigs = choose_1(function (_arg6) {
        return _arg6.tag === 5 ? [_arg6.data[0], _arg6.data[1]] : null;
      }, _arg1.data[1].data[1]);
      let members_1;
      const membersIncludingAutoProps = filter(function (memb) {
        switch (memb.tag) {
          case 1:
          case 4:
          case 2:
          case 10:
          case 0:
          case 3:
            return true;

          case 9:
            error_1(new _Error(SR.tcTypesCannotContainNestedTypes(), memb.data[2]));
            return false;

          case 8:
          case 7:
          case 5:
            return false;

          default:
            return true;
        }
      }, _arg1.data[1].data[1]);

      const preAutoProps = function (memb_1) {
        const $var416 = memb_1.tag === 10 ? [0, memb_1.data[7], memb_1.data[9], memb_1.data[0], memb_1.data[2], memb_1.data[1], memb_1.data[10], memb_1.data[4], memb_1.data[8], memb_1.data[3], memb_1.data[6]] : memb_1.tag === 6 ? memb_1.data[1] != null ? [1, getValue(memb_1.data[1])] : [3] : memb_1.tag === 4 ? [2] : memb_1.tag === 2 ? [2] : memb_1.tag === 0 ? [2] : memb_1.tag === 3 ? [2] : [3];

        switch ($var416[0]) {
          case 0:
            const attribs = filter(function (a) {
              const $var417 = a.Target != null ? getValue(a.Target).idText === "field" ? [0, getValue(a.Target)] : [1] : [1];

              switch ($var417[0]) {
                case 0:
                  return true;

                case 1:
                  return false;
              }
            }, $var416[3]);
            const mLetPortion = $var416[8].Range;
            const fldId = ident(CompilerGeneratedName($var416[4].idText), mLetPortion);
            const headPat = new SynPat(7, [new LongIdentWithDots(0, [ofArray([fldId]), new List()]), null, noInferredTypars, new SynConstructorArgs(0, new List()), null, mLetPortion]);
            const retInfo = $var416[9] != null ? new SynReturnInfo(0, [[getValue($var416[9]), SynInfo.unnamedRetVal], getValue($var416[9]).Range]) : null;
            let isMutable;
            const $var418 = $var416[7].tag === 4 ? [0] : $var416[7].tag === 5 ? [0] : [1];

            switch ($var418[0]) {
              case 0:
                isMutable = true;
                break;

              case 1:
                isMutable = false;
                break;
            }

            const binding = mkSynBinding($var416[10], headPat, null, false, isMutable, mLetPortion, new SequencePointInfoForBinding(4), retInfo, $var416[8], $var416[8].Range, new List(), attribs, null);
            return ofArray([new SynMemberDefn(4, [ofArray([binding]), $var416[5], false, $var416[6]])]);

          case 1:
            return collect(preAutoProps, $var416[1]);

          case 2:
            return ofArray([memb_1]);

          case 3:
            return new List();
        }
      };

      const postAutoProps = function (memb_2) {
        const $var419 = memb_2.tag === 10 ? [0, memb_2.data[10], memb_2.data[8], memb_2.data[7], memb_2.data[0], memb_2.data[2], memb_2.data[1], memb_2.data[9], memb_2.data[5], memb_2.data[4], memb_2.data[3], memb_2.data[6]] : memb_2.tag === 6 ? memb_2.data[1] != null ? [1, memb_2.data[2], getValue(memb_2.data[1]), memb_2.data[0]] : [3] : memb_2.tag === 4 ? [2] : memb_2.tag === 2 ? [2] : memb_2.tag === 0 ? [2] : memb_2.tag === 3 ? [2] : [3];

        switch ($var419[0]) {
          case 0:
            const mMemberPortion = $var419[5].idRange;
            const attribs_1 = filter(function (a_1) {
              const $var420 = a_1.Target != null ? getValue(a_1.Target).idText === "field" ? [0, getValue(a_1.Target)] : [1] : [1];

              switch ($var420[0]) {
                case 0:
                  return false;

                case 1:
                  return true;
              }
            }, $var419[4]);
            const fldId_1 = ident(CompilerGeneratedName($var419[5].idText), mMemberPortion);
            const headPatIds = $var419[6] ? ofArray([$var419[5]]) : ofArray([ident("__", mMemberPortion), $var419[5]]);
            const headPat_1 = new SynPat(7, [new LongIdentWithDots(0, [headPatIds, new List()]), null, noInferredTypars, new SynConstructorArgs(0, new List()), null, mMemberPortion]);
            const matchValue = [$var419[9], $var419[7]];
            const $var421 = matchValue[0].tag === 4 ? matchValue[1] != null ? [0] : [1] : [1];

            switch ($var421[0]) {
              case 0:
                const m = getValue(matchValue[1]);
                errorR(new _Error(SR.parsMutableOnAutoPropertyShouldBeGetSetNotJustSet(), m));
                break;

              case 1:
                break;
            }

            return toList(delay(function () {
              return append_1((() => {
                const $var422 = $var419[9].tag === 2 ? [0] : $var419[9].tag === 3 ? [0] : $var419[9].tag === 5 ? [0] : [1];

                switch ($var422[0]) {
                  case 0:
                    let getter;
                    const rhsExpr = new SynExpr(28, fldId_1);
                    const retInfo_1 = $var419[10] != null ? new SynReturnInfo(0, [[getValue($var419[10]), SynInfo.unnamedRetVal], getValue($var419[10]).Range]) : null;
                    const binding_1 = mkSynBinding($var419[11], headPat_1, $var419[3], false, false, mMemberPortion, new SequencePointInfoForBinding(4), retInfo_1, rhsExpr, rhsExpr.Range, new List(), attribs_1, $var419[8](new MemberKind_2(2)));
                    getter = new SynMemberDefn(1, [binding_1, mMemberPortion]);
                    return singleton(getter);

                  case 1:
                    return empty();
                }
              })(), delay(function () {
                const $var423 = $var419[9].tag === 4 ? [0] : $var419[9].tag === 5 ? [0] : [1];

                switch ($var423[0]) {
                  case 0:
                    let setter;
                    const vId = ident("v", mMemberPortion);
                    const headPat_2 = new SynPat(7, [new LongIdentWithDots(0, [headPatIds, new List()]), null, noInferredTypars, new SynConstructorArgs(0, ofArray([mkSynPatVar(null, vId)])), null, mMemberPortion]);
                    const rhsExpr_1 = mkSynAssign(new SynExpr(28, fldId_1), new SynExpr(28, vId));
                    const binding_2 = mkSynBinding($var419[11], headPat_2, $var419[3], false, false, mMemberPortion, new SequencePointInfoForBinding(4), null, rhsExpr_1, rhsExpr_1.Range, new List(), new List(), $var419[8](new MemberKind_2(4)));
                    setter = new SynMemberDefn(1, [binding_2, mMemberPortion]);
                    return singleton(setter);

                  case 1:
                    return empty();
                }
              }));
            }));

          case 1:
            const membs_ = collect(postAutoProps, $var419[2]);
            return ofArray([new SynMemberDefn(6, [$var419[3], membs_, $var419[1]])]);

          case 2:
            return new List();

          case 3:
            return ofArray([memb_2]);
        }
      };

      const preMembers = function (list) {
        return collect(preAutoProps, list);
      }(membersIncludingAutoProps);

      const postMembers = function (list_1) {
        return collect(postAutoProps, list_1);
      }(membersIncludingAutoProps);

      members_1 = append(preMembers, postMembers);
      const isConcrete = exists_1(function (_arg7) {
        const $var424 = _arg7.tag === 1 ? _arg7.data[0].data[6].data[0] != null ? [0, getValue(_arg7.data[0].data[6].data[0])] : [5] : _arg7.tag === 6 ? [1, _arg7.data[1]] : _arg7.tag === 4 ? [2] : _arg7.tag === 2 ? [3] : _arg7.tag === 3 ? [4] : [5];

        switch ($var424[0]) {
          case 0:
            return !$var424[1].IsDispatchSlot;

          case 1:
            return $var424[1] != null;

          case 2:
            return true;

          case 3:
            return true;

          case 4:
            return true;

          case 5:
            return false;
        }
      }, members_1);
      const isIncrClass = exists_1(function (_arg8) {
        return _arg8.tag === 2 ? true : false;
      }, members_1);
      const hasSelfReferentialCtor = exists_1(function (_arg9) {
        const $var425 = _arg9.tag === 2 ? [0, _arg9.data[3]] : _arg9.tag === 1 ? [0, _arg9.data[0].data[6].data[2]] : [1];

        switch ($var425[0]) {
          case 0:
            return CurriedLambda(() => $var425[1] != null)();

          case 1:
            return false;
        }
      }, members_1);
      const implicitCtorSynPats = tryPick(function (_arg10) {
        return _arg10.tag === 2 ? _arg10.data[2] : null;
      }, members_1);
      const preEstablishedHasDefaultCtor = exists_1(function (_arg11) {
        let $var426;

        if (_arg11.tag === 1) {
          if (_arg11.data[0].data[6].data[0] != null) {
            const activePatternResult43672 = _SynPatForConstructorDecl___(_arg11.data[0].data[7]);

            if (activePatternResult43672 != null) {
              const activePatternResult43673 = _SynPatForNullaryArgs___(getValue(activePatternResult43672));

              if (activePatternResult43673 != null) {
                $var426 = [0, getValue(_arg11.data[0].data[6].data[0])];
              } else {
                $var426 = [1];
              }
            } else {
              $var426 = [1];
            }
          } else {
            $var426 = [1];
          }
        } else {
          $var426 = [1];
        }

        switch ($var426[0]) {
          case 0:
            return $var426[1].MemberKind.Equals(new MemberKind_2(1));

          case 1:
            if (_arg11.tag === 2) {
              return _arg11.data[2].tail == null;
            } else {
              return false;
            }

        }
      }, members_1);
      const repr = new SynTypeDefnSimpleRepr(3, [_arg1.data[1].data[0], inherits, slotsigs, fields, isConcrete, isIncrClass, implicitCtorSynPats, _arg1.data[1].data[2]]);
      const isAtOriginalTyconDefn = !isAugmentationTyconDefnRepr(repr);
      const core_2 = new MutRecDefnsPhase1DataForTycon(0, [_arg1.data[0], repr, append(implements2, implements1), preEstablishedHasDefaultCtor, hasSelfReferentialCtor, isAtOriginalTyconDefn]);
      return [core_2, append(members_1, _arg1.data[2])];
    }
  };

  const TcMutRecDefinitions = __exports.TcMutRecDefinitions = function (cenv_1, envInitial, parent, typeNames, tpenv, m, scopem, mutRecNSInfo, mutRecDefns) {
    var getTyconOpt;
    var getVals;

    const mutRecDefnsAfterSplit = function (xs) {
      return MutRecShapes.mapTycons(function (arg00_) {
        return SplitTyconDefn(arg00_);
      }, xs);
    }(mutRecDefns);

    const patternInput = EstablishTypeDefinitionCores.TcMutRecDefns_Phase1(function (containerInfo, synBinds) {
      return toList(delay(function () {
        return map_2(function (synBind) {
          return new RecDefnBindingInfo(0, [containerInfo, new NewSlotsOK(1), new DeclKind(0), synBind]);
        }, synBinds);
      }));
    }, cenv_1, envInitial, parent, typeNames, false, tpenv, m, scopem, mutRecNSInfo, mutRecDefnsAfterSplit);
    const mutRecDefnsAfterPrep = MutRecShapes.mapTyconsWithEnv(function (envForDecls, tupledArg) {
      const tyDeclRange = tupledArg[0][0].data[0].Range;
      const patternInput_1 = ComputeTyconDeclKind(tupledArg[1], tupledArg[0][0].data[5], cenv_1, envForDecls, false, tyDeclRange, tupledArg[0][0].data[0].data[1], tupledArg[0][0].data[0].data[2], tupledArg[0][0].data[0].data[3]);
      const newslotsOK = (tupledArg[0][0].data[5] ? patternInput_1[1].IsFSharpObjectModelTycon : false) ? new NewSlotsOK(0) : new NewSlotsOK(1);

      if (!(tupledArg[0][1].tail == null) ? patternInput_1[1].IsTypeAbbrev : false) {
        errorR(new _Error(SR.tcTypeAbbreviationsCannotHaveAugmentations(), tyDeclRange));
      }

      return new MutRecDefnsPhase2DataForTycon(0, [tupledArg[1], tupledArg[0][2], patternInput_1[0], patternInput_1[1], tupledArg[3][0], tupledArg[3][1], patternInput_1[2], tupledArg[0][1], tyDeclRange, newslotsOK, tupledArg[2]]);
    }, patternInput[1], patternInput[2]);
    const patternInput_2 = (getTyconOpt = function (_arg3) {
      return _arg3.data[0];
    }, getVals = function (_binds) {
      return new List();
    }, function (envInitial_1, mutRecShape) {
      return MutRecBindingChecking.TcMutRecDefns_ComputeEnvs(getTyconOpt, getVals, cenv_1, true, scopem, m, envInitial_1, mutRecShape);
    })(envInitial, MutRecShapes.dropEnvs(mutRecDefnsAfterPrep));
    const patternInput_3 = TcMutRecDefns_Phase2(cenv_1, envInitial, m, scopem, mutRecNSInfo, patternInput_2[0], patternInput_2[1]);
    const withExtraBindings = MutRecShapes.expandTyconsWithEnv(function (envForDecls_1, tupledArg_1) {
      if (tupledArg_1[0] != null) {
        const binds = AddAugmentationDeclarations.AddGenericHashAndComparisonBindings(cenv_1, getValue(tupledArg_1[0]));
        const binds3 = AddAugmentationDeclarations.AddGenericEqualityBindings(cenv_1, envForDecls_1, getValue(tupledArg_1[0]));
        return [binds, binds3];
      } else {
        return [new List(), new List()];
      }
    }, patternInput_3[1], patternInput_3[0]);
    EstablishTypeDefinitionCores.TcTyconDefnCore_CheckForCyclicStructsAndInheritance(cenv_1, patternInput[0]);
    return [withExtraBindings, patternInput_3[1]];
  };

  const SplitTyconSignature = function (_arg1) {
    const implements1 = choose_1(function (_arg2) {
      return _arg2.tag === 1 ? [_arg2.data[0], _arg2.data[1]] : null;
    }, _arg1.data[2]);
    const $var427 = _arg1.data[1].tag === 0 ? [0, _arg1.data[1].data[1], _arg1.data[1].data[0], _arg1.data[1].data[2]] : _arg1.data[1].tag === 1 ? _arg1.data[1].data[0].tag === 6 ? !(_arg1.data[2].tail == null) ? [1, _arg1.data[1].data[0]] : [2] : [2] : [2];

    switch ($var427[0]) {
      case 0:
        const fields = choose_1(function (_arg3) {
          return _arg3.tag === 3 ? _arg3.data[0] : null;
        }, $var427[1]);
        const implements2 = choose_1(function (_arg4) {
          return _arg4.tag === 1 ? [_arg4.data[0], _arg4.data[1]] : null;
        }, $var427[1]);
        const inherits = choose_1(function (_arg5) {
          return _arg5.tag === 2 ? [_arg5.data[0], $var427[3], null] : null;
        }, $var427[1]);
        const slotsigs = choose_1(function (_arg6) {
          const $var428 = _arg6.tag === 0 ? _arg6.data[1].IsDispatchSlot ? [0, _arg6.data[1], _arg6.data[0]] : [1] : [1];

          switch ($var428[0]) {
            case 0:
              return [$var428[2], $var428[1]];

            case 1:
              return null;
          }
        }, $var427[1]);
        const members = filter(function (_arg7) {
          const $var429 = _arg7.tag === 1 ? [0] : _arg7.tag === 0 ? !_arg7.data[1].IsDispatchSlot ? [1, _arg7.data[1]] : [2] : [2];

          switch ($var429[0]) {
            case 0:
              return true;

            case 1:
              return true;

            case 2:
              if (_arg7.tag === 4) {
                error_1(new _Error(SR.tcTypesCannotContainNestedTypes(), _arg7.data[1]));
                return false;
              } else {
                return false;
              }

          }
        }, $var427[1]);
        const isConcrete = exists_1(function (_arg8) {
          return _arg8.tag === 0 ? _arg8.data[1].MemberKind.Equals(new MemberKind_2(1)) : false;
        }, members);
        const preEstablishedHasDefaultCtor = exists_1(function (_arg9) {
          var id;

          if (_arg9.tag === 0) {
            if (_arg9.data[1].MemberKind.Equals(new MemberKind_2(1))) {
              const matchValue = [_arg9.data[0].SynType, _arg9.data[0].SynInfo.ArgInfos];
              const $var430 = matchValue[0].tag === 6 ? matchValue[0].data[0].tag === 0 ? matchValue[0].data[0].data.data[0].tail != null ? matchValue[0].data[0].data.data[0].tail.tail == null ? matchValue[1].tail != null ? matchValue[1].head.tail != null ? matchValue[1].head.tail.tail == null ? matchValue[1].tail.tail == null ? (id = matchValue[0].data[0].data.data[0].head, id.idText === "unit") ? [0, matchValue[0].data[0].data.data[0].head] : [1] : [1] : [1] : [1] : [1] : [1] : [1] : [1] : [1];

              switch ($var430[0]) {
                case 0:
                  return true;

                case 1:
                  return false;
              }
            } else {
              return false;
            }
          } else {
            return false;
          }
        }, members);
        const repr = new SynTypeDefnSimpleRepr(3, [$var427[2], inherits, slotsigs, fields, isConcrete, false, null, $var427[3]]);
        const tyconCore = new MutRecDefnsPhase1DataForTycon(0, [_arg1.data[0], repr, append(implements2, implements1), preEstablishedHasDefaultCtor, false, true]);
        return [tyconCore, [_arg1.data[0], append(members, _arg1.data[2])]];

      case 1:
        const tyconCore_1 = new MutRecDefnsPhase1DataForTycon(0, [_arg1.data[0], $var427[1], implements1, false, false, false]);
        return [tyconCore_1, [_arg1.data[0], _arg1.data[2]]];

      case 2:
        if (_arg1.data[1].tag === 2) {
          const core = new MutRecDefnsPhase1DataForTycon(0, [_arg1.data[0], new SynTypeDefnSimpleRepr(7, _arg1.data[1].data), implements1, false, false, true]);
          return [core, [_arg1.data[0], _arg1.data[2]]];
        } else if (_arg1.data[1].tag === 1) {
          const tyconCore_2 = new MutRecDefnsPhase1DataForTycon(0, [_arg1.data[0], _arg1.data[1].data[0], implements1, false, false, true]);
          return [tyconCore_2, [_arg1.data[0], _arg1.data[2]]];
        } else {
          throw new Error("C:/projects/fcs/src/fsharp/TypeChecker.fs", 16213, 14);
        }

    }
  };

  const TcMutRecSignatureDecls_Phase2 = function (cenv_1, scopem, envMutRec, mutRecDefns) {
    return MutRecShapes.mapWithEnv(function (envForDecls, tupledArg) {
      const synTyconInfo = tupledArg[0][1][0];
      const members = tupledArg[0][1][1];
      const tpenv = emptyUnscopedTyparEnv;
      const patternInput = ComputeTyconDeclKind(tupledArg[1], tupledArg[0][0].data[5], cenv_1, envForDecls, true, synTyconInfo.data[7], synTyconInfo.data[1], synTyconInfo.data[2], synTyconInfo.data[3]);
      const envForTycon = AddDeclaredTypars(new CheckForDuplicateTyparFlag(0), patternInput[2], envForDecls);
      const envForTycon_1 = MakeInnerEnvForTyconRef(cenv_1, envForTycon, patternInput[1], patternInput[0].Equals(new DeclKind(2)));
      return TcTyconMemberSpecs(cenv_1, envForTycon_1, TyconContainerInfo(tupledArg[0][2], patternInput[1], patternInput[2], new SafeInitData(1)), patternInput[0], tpenv, members);
    }, function (envForDecls_1, tupledArg_1) {
      const tpenv_1 = emptyUnscopedTyparEnv;
      const patternInput_1 = TcAndPublishValSpec(cenv_1, envForDecls_1, tupledArg_1[0], new DeclKind(0), null, tpenv_1, tupledArg_1[1]);
      const env_1 = foldBack(function (v, env) {
        return AddLocalVal(cenv_1.tcSink, scopem, v, env);
      }, patternInput_1[0], envForDecls_1);
      return env_1;
    }, envMutRec, mutRecDefns);
  };

  const TcMutRecSignatureDecls = __exports.TcMutRecSignatureDecls = function (cenv_1, envInitial, parent, typeNames, tpenv, m, scopem, mutRecNSInfo, mutRecSigs) {
    var getTyconOpt;
    var getVals;

    const mutRecSigsAfterSplit = function (xs) {
      return MutRecShapes.mapTycons(function (arg00_) {
        return SplitTyconSignature(arg00_);
      }, xs);
    }(mutRecSigs);

    const patternInput = EstablishTypeDefinitionCores.TcMutRecDefns_Phase1(function (containerInfo, valDecl) {
      return [containerInfo, valDecl];
    }, cenv_1, envInitial, parent, typeNames, true, tpenv, m, scopem, mutRecNSInfo, mutRecSigsAfterSplit);
    MutRecBindingChecking.TcMutRecDefns_UpdateModuleContents(mutRecNSInfo, patternInput[2]);
    const patternInput_1 = (getTyconOpt = function (tupledArg) {
      return tupledArg[1];
    }, getVals = function (_binds) {
      return new List();
    }, function (envInitial_1, mutRecShape) {
      return MutRecBindingChecking.TcMutRecDefns_ComputeEnvs(getTyconOpt, getVals, cenv_1, true, scopem, m, envInitial_1, mutRecShape);
    })(envInitial, MutRecShapes.dropEnvs(patternInput[2]));
    TcMutRecSignatureDecls_Phase2(cenv_1, scopem, patternInput_1[0], patternInput_1[1]);
    return patternInput[1];
  };

  return __exports;
}({});
export function TcSignatureElementNonMutRec(cenv_1, parent, typeNames, endm, env, synSigDecl) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.TryWith(builder_.Delay(function () {
        switch (synSigDecl.tag) {
          case 3:
            const scopem = unionRanges(synSigDecl.data[1], endm);
            const mutRecDefns = map_1(function (arg0) {
              return new MutRecShape(0, arg0);
            }, synSigDecl.data[0]);
            const env_1 = TcDeclarations.TcMutRecSignatureDecls(cenv_1, env, parent, typeNames, emptyUnscopedTyparEnv, synSigDecl.data[1], scopem, null, mutRecDefns);
            return builder_.Return(env_1);

          case 5:
            const scopem_1 = unionRanges(synSigDecl.data[1].EndRange, endm);
            const env_2 = TcOpenDecl(cenv_1.tcSink, cenv_1.g, cenv_1.amap, synSigDecl.data[1], scopem_1, env, synSigDecl.data[0]);
            return builder_.Return(env_2);

          case 2:
            const parentModule = parent.tag === 0 ? parent.data : error_1(new NumberedError(SR.tcNamespaceCannotContainValues(), synSigDecl.data[0].RangeOfId));
            const containerInfo = ModuleOrNamespaceContainerInfo(parentModule);
            const patternInput = TcAndPublishValSpec(cenv_1, env, containerInfo, new DeclKind(0), null, emptyUnscopedTyparEnv, synSigDecl.data[0]);
            const scopem_2 = unionRanges(synSigDecl.data[1], endm);
            const env_4 = foldBack(function (v, env_3) {
              return AddLocalVal(cenv_1.tcSink, scopem_2, v, env_3);
            }, patternInput[0], env);
            return builder_.Return(env_4);

          case 1:
            const xml = synSigDecl.data[0].data[4];
            const vis = synSigDecl.data[0].data[6];
            const longPath = synSigDecl.data[0].data[3];
            const im = synSigDecl.data[0].data[7];
            const attribs = synSigDecl.data[0].data[0];
            const _parms = synSigDecl.data[0].data[1];
            const _constraints = synSigDecl.data[0].data[2];

            if (synSigDecl.data[1]) {
              const modDecl = new SynModuleSigDecl(1, [synSigDecl.data[0], false, synSigDecl.data[2], synSigDecl.data[3]]);
              return builder_.ReturnFrom(TcSignatureElementsMutRec(cenv_1, parent, typeNames, endm, null, env, ofArray([modDecl])));
            } else {
              const id = ComputeModuleName(longPath);
              const patternInput_1 = ComputeAccessAndCompPath(env, null, im, vis, null, parent);
              const attribs_1 = TcAttributes(cenv_1, env, AttributeTargets.ModuleDecl, attribs);
              CheckNamespaceModuleOrTypeName(cenv_1.g, id);
              const modKind = EstablishTypeDefinitionCores.ComputeModuleOrNamespaceKind(cenv_1.g, true, typeNames, attribs_1, id.idText);
              const modName = EstablishTypeDefinitionCores.AdjustModuleName(modKind, id.idText);
              CheckForDuplicateConcreteType(env, modName, id.idRange);
              const id_1 = ident(modName, id.idRange);
              const mspec = NewModuleOrNamespace(env.eCompPath, patternInput_1[0], id_1, xml.ToXmlDoc(), attribs_1, new MaybeLazy(0, NewEmptyModuleOrNamespaceType(modKind)));
              return builder_.Bind(TcModuleOrNamespaceSignatureElementsNonMutRec(cenv_1, new ParentRef(0, mkLocalModRef(mspec)), env, id_1, modKind, synSigDecl.data[2], synSigDecl.data[3], xml), function (_arg1) {
                mspec.entity_modul_contents = new MaybeLazy(0, _arg1[0]);
                const scopem_3 = unionRanges(synSigDecl.data[3], endm);
                PublishModuleDefn(cenv_1, env, mspec);
                const env_5 = AddLocalSubModuleAndReport(cenv_1.tcSink, scopem_3, cenv_1.g, cenv_1.amap, synSigDecl.data[3], env, mspec);
                return builder_.Return(env_5);
              });
            }

          case 0:
            const resolved = synSigDecl.data[1].tail != null ? ResolveLongIndentAsModuleOrNamespace(cenv_1.tcSink, new ResultCollectionSettings(0), cenv_1.amap, synSigDecl.data[2], true, new FullyQualifiedFlag(1), env.eNameResEnv, env.eAccessRights, synSigDecl.data[1].head, synSigDecl.data[1].tail, false) : new ResultOrException(0, new List());
            const mvvs = ResultOrExceptionModule.ForceRaise(resolved);
            const scopem_4 = unionRanges(synSigDecl.data[2], endm);
            const unfilteredModrefs = map_1(function (tupledArg) {
              return p23(tupledArg[0], tupledArg[1], tupledArg[2]);
            }, mvvs);
            const modrefs = filter(function (modref) {
              return !modref.IsNamespace;
            }, unfilteredModrefs);
            return builder_.Combine((!(unfilteredModrefs.tail == null) ? modrefs.tail == null : false) ? (errorR(new _Error(SR.tcModuleAbbreviationForNamespace(fullDisplayTextOfModRef(unfilteredModrefs.head)), synSigDecl.data[2])), builder_.Zero()) : builder_.Zero(), builder_.Delay(function () {
              if (modrefs.tail == null) {
                return builder_.Return(env);
              } else {
                iterate(function (modref_1) {
                  CommitOperationResult(CheckEntityAttributes(cenv_1.g, modref_1, synSigDecl.data[2]));
                }, modrefs);
                const env_6 = AddModuleAbbreviationAndReport(cenv_1.tcSink, scopem_4, synSigDecl.data[0], modrefs, env);
                return builder_.Return(env_6);
              }
            }));

          case 6:
            return builder_.Return(env);

          case 7:
            const xml_1 = synSigDecl.data.data[4];
            const vis_1 = synSigDecl.data.data[6];
            const m = synSigDecl.data.data[7];
            const longId = synSigDecl.data.data[0];
            const isRec = synSigDecl.data.data[1];
            const isModule = synSigDecl.data.data[2];
            const defs = synSigDecl.data.data[3];
            const attribs_2 = synSigDecl.data.data[5];

            for (let id_2 of longId) {
              CheckNamespaceModuleOrTypeName(cenv_1.g, id_2);
            }

            let patternInput_3;

            if (isModule) {
              const patternInput_2 = List_1.frontAndBack(longId);
              const modDecl_1 = ofArray([new SynModuleSigDecl(1, [new SynComponentInfo(0, [attribs_2, new List(), new List(), ofArray([patternInput_2[1]]), xml_1, false, vis_1, m]), false, defs, m])]);
              patternInput_3 = [patternInput_2[0], modDecl_1];
            } else {
              patternInput_3 = [longId, defs];
            }

            const envNS = LocateEnv(cenv_1.topCcu, env, patternInput_3[0]);
            const envNS_1 = ImplicitlyOpenOwnNamespace(cenv_1.tcSink, cenv_1.g, cenv_1.amap, m, patternInput_3[0], envNS);
            const mtypNS = envNS_1.eModuleOrNamespaceTypeAccumulator.contents;
            const patternInput_4 = BuildRootModuleType(patternInput_3[0], envNS_1.eCompPath, mtypNS);
            const mspecNSOpt = tryHead(patternInput_4[1]);
            iterate(function (mspec_1) {
              const modref_2 = mkLocalModRef(mspec_1);
              const item = new Item(18, ofArray([modref_2]));
              CallNameResolutionSink(cenv_1.tcSink, mspec_1.Range, env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(0), env.DisplayEnv, env.eAccessRights);
            }, patternInput_4[1]);
            const envNS_2 = isRec ? AddLocalRootModuleOrNamespace(cenv_1.tcSink, cenv_1.g, cenv_1.amap, m, envNS_1, patternInput_4[0]) : envNS_1;
            const nsInfo = [mspecNSOpt, envNS_2.eModuleOrNamespaceTypeAccumulator];
            const mutRecNSInfo = isRec ? nsInfo : null;
            return builder_.Bind(TcSignatureElements(cenv_1, new ParentRef(1), m.EndRange, envNS_2, xml_1, mutRecNSInfo, patternInput_3[1]), function (_arg2) {
              MutRecBindingChecking.TcMutRecDefns_UpdateNSContents(nsInfo);
              let env_9;

              if (patternInput_3[0].tail == null) {
                env_9 = _arg2;
              } else {
                const env_7 = AddLocalRootModuleOrNamespace(cenv_1.tcSink, cenv_1.g, cenv_1.amap, m, env, patternInput_4[0]);
                let env_8;
                const matchValue = TryStripPrefixPath(cenv_1.g, patternInput_3[0]);

                if (matchValue == null) {
                  env_8 = env_7;
                } else {
                  const p = getValue(matchValue)[0];
                  env_8 = TcOpenDecl(cenv_1.tcSink, cenv_1.g, cenv_1.amap, m.EndRange, m.EndRange, env_7, ofArray([p]));
                }

                env_8.eModuleOrNamespaceTypeAccumulator.contents = CombineCcuContentFragments(m, ofArray([env_8.eModuleOrNamespaceTypeAccumulator.contents, patternInput_4[0]]));
                env_9 = env_8;
              }

              return builder_.Return(env_9);
            });

          default:
            const scopem_5 = unionRanges(synSigDecl.data[1].EndRange, endm);
            const patternInput_5 = TcExceptionDeclarations.TcExnSignature(cenv_1, env, parent, emptyUnscopedTyparEnv, synSigDecl.data[0], scopem_5);
            return builder_.Return(patternInput_5[3]);
        }
      }), function (_arg3) {
        errorRecovery(_arg3, endm);
        return builder_.Return(env);
      });
    });
  }(eventually);
}
export function TcSignatureElements(cenv_1, parent, endm, env, xml, mutRecNSInfo, defs) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.Combine(cenv_1.compilingCanonicalFslibModuleType ? (ensureCcuHasModuleOrNamespaceAtPath(cenv_1.topCcu, env.ePath, env.eCompPath, xml.ToXmlDoc()), builder_.Zero()) : builder_.Zero(), builder_.Delay(function () {
        const typeNames = EstablishTypeDefinitionCores.TypeNamesInNonMutRecSigDecls(defs);

        if (mutRecNSInfo == null) {
          return builder_.ReturnFrom(TcSignatureElementsNonMutRec(cenv_1, parent, typeNames, endm, env, defs));
        } else {
          return builder_.ReturnFrom(TcSignatureElementsMutRec(cenv_1, parent, typeNames, endm, mutRecNSInfo, env, defs));
        }
      }));
    });
  }(eventually);
}
export function TcSignatureElementsNonMutRec(cenv_1, parent, typeNames, endm, env, defs) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.ReturnFrom(EventuallyModule.fold(function (env_1, synSigDecl) {
        return TcSignatureElementNonMutRec(cenv_1, parent, typeNames, endm, env_1, synSigDecl);
      }, env, defs));
    });
  }(eventually);
}
export function TcSignatureElementsMutRec(cenv_1, parent, typeNames, endm, mutRecNSInfo, envInitial, defs) {
  return function (builder_) {
    return builder_.Delay(function () {
      const m = defs.tail == null ? endm : function (list) {
        return reduce(function (arg00_, arg10_) {
          return unionRanges(arg00_, arg10_);
        }, list);
      }(map_1(function (d) {
        return d.Range;
      }, defs));
      const scopem = foldBack(function (h, m_1) {
        return unionRanges(h.Range, m_1);
      }, defs, endm);
      let mutRecDefns;

      const loop = function (isNamespace, defs_1) {
        return List_1.collectFold(function (tupledArg, def) {
          switch (def.tag) {
            case 5:
              if (!tupledArg[0]) {
                errorR(new _Error(SR.tcOpenFirstInMutRec(), def.data[1]));
              }

              const decls = ofArray([new MutRecShape(4, new MutRecDataForOpen(0, [def.data[0], def.data[1]]))]);
              return [decls, [tupledArg[0], tupledArg[1]]];

            case 4:
              const members = def.data[0].data[1];
              const exnRepr = def.data[0].data[0];
              const id = exnRepr.data[1].data[1];
              const _args = exnRepr.data[1].data[2];
              const compInfo = new SynComponentInfo(0, [exnRepr.data[0], new List(), new List(), ofArray([id]), exnRepr.data[3], false, exnRepr.data[4], id.idRange]);
              const decls_1 = ofArray([new MutRecShape(0, new SynTypeDefnSig(0, [compInfo, new SynTypeDefnSigRepr(2, exnRepr), members, exnRepr.data[5]]))]);
              return [decls_1, [false, false]];

            case 2:
              if (isNamespace) {
                error_1(new NumberedError(SR.tcNamespaceCannotContainValues(), def.data[0].RangeOfId));
              }

              const decls_2 = ofArray([new MutRecShape(1, def.data[0])]);
              return [decls_2, [false, false]];

            case 1:
              if (def.data[1]) {
                warning(new _Error(SR.tcRecImplied(), def.data[0].Range));
              }

              const mutRecDefs = loop(false, def.data[2]);
              const decls_3 = ofArray([new MutRecShape(2, [def.data[0], mutRecDefs])]);
              return [decls_3, [false, false]];

            case 6:
              return [new List(), [tupledArg[0], tupledArg[1]]];

            case 0:
              if (!tupledArg[1]) {
                errorR(new _Error(SR.tcModuleAbbrevFirstInMutRec(), def.data[2]));
              }

              const decls_4 = ofArray([new MutRecShape(3, new MutRecDataForModuleAbbrev(0, [def.data[0], def.data[1], def.data[2]]))]);
              return [decls_4, [false, tupledArg[1]]];

            case 7:
              return error_1(new _Error(SR.tcUnsupportedMutRecDecl(), def.Range));

            default:
              const decls_5 = map_1(function (arg0) {
                return new MutRecShape(0, arg0);
              }, def.data[0]);
              return [decls_5, [false, false]];
          }
        }, [true, true], defs_1)[0];
      };

      mutRecDefns = loop(parent.tag === 0 ? false : true, defs);
      return builder_.Return(TcDeclarations.TcMutRecSignatureDecls(cenv_1, envInitial, parent, typeNames, emptyUnscopedTyparEnv, m, scopem, mutRecNSInfo, mutRecDefns));
    });
  }(eventually);
}
export function TcModuleOrNamespaceSignatureElementsNonMutRec(cenv_1, parent, env, id, modKind, defs, m, xml) {
  return function (builder_) {
    return builder_.Delay(function () {
      const endm = m.EndRange;
      const patternInput = MakeInnerEnv(env, id, modKind);
      return builder_.Bind(TcSignatureElements(cenv_1, parent, endm, patternInput[0], xml, null, defs), function (_arg4) {
        return builder_.Return([patternInput[1].contents, _arg4]);
      });
    });
  }(eventually);
}
export function ElimModuleDoBinding(bind) {
  if (bind.tag === 3) {
    const bind2 = new SynBinding(0, [null, new SynBindingKind(0), false, false, new List(), PreXmlDoc.Empty, SynInfo.emptySynValData, new SynPat(1, bind.data[2]), null, bind.data[1], bind.data[2], bind.data[0]]);
    return new SynModuleDecl(2, [false, ofArray([bind2]), bind.data[2]]);
  } else {
    return bind;
  }
}
export function TcMutRecDefnsEscapeCheck(binds, env) {
  var f1;
  const freeInEnv = GeneralizationHelpers.ComputeUnabstractableTycons(env);

  const checkTycon = function (tycon) {
    if (!tycon.IsTypeAbbrev ? ZsetModule.contains(tycon, freeInEnv) : false) {
      const nm = tycon.DisplayName;
      errorR(new _Error(SR.tcTypeUsedInInvalidWay(nm, nm, nm), tycon.Range));
    }
  };

  MutRecShapes.iterTycons($var432 => function (option) {
    iterate(checkTycon, defaultArg(option, [], $var431 => [$var431]));
  }(function (tuple) {
    return tuple[0];
  }($var432)), binds);
  const freeInEnv_1 = GeneralizationHelpers.ComputeUnabstractableTraitSolutions(env);

  const checkBinds = function (binds_1) {
    for (let bind of binds_1) {
      if (ZsetModule.contains(bind.Var, freeInEnv_1)) {
        const nm_1 = bind.Var.DisplayName;
        errorR(new _Error(SR.tcMemberUsedInInvalidWay(nm_1, nm_1, nm_1), bind.Var.Range));
      }
    }
  };

  (f1 = $var433 => checkBinds(function (tuple_1) {
    return tuple_1[1];
  }($var433)), function (x) {
    MutRecShapes.iterTyconsAndLets(f1, checkBinds, x);
  })(binds);
}
export function CheckLetOrDoInNamespace(binds, m) {
  const $var434 = binds.tail == null ? [1] : binds.head.data[0] == null ? binds.head.data[1].tag === 0 ? binds.head.data[2] ? [2] : binds.head.data[3] ? [2] : binds.head.data[4].tail == null ? binds.head.data[8] == null ? binds.head.data[9].tag === 18 ? binds.head.data[9].data[0].tag === 2 ? binds.head.data[9].data[0].data[0].tag === 0 ? binds.tail.tail == null ? [0] : [2] : [2] : [2] : binds.head.data[9].tag === 2 ? binds.head.data[9].data[0].tag === 0 ? binds.tail.tail == null ? [0] : [2] : [2] : [2] : [2] : [2] : binds.head.data[1].tag === 2 ? binds.head.data[2] ? [2] : binds.head.data[3] ? [2] : binds.head.data[4].tail == null ? binds.head.data[8] == null ? binds.head.data[9].tag === 18 ? binds.head.data[9].data[0].tag === 2 ? binds.head.data[9].data[0].data[0].tag === 0 ? binds.tail.tail == null ? [0] : [2] : [2] : [2] : binds.head.data[9].tag === 2 ? binds.head.data[9].data[0].tag === 0 ? binds.tail.tail == null ? [0] : [2] : [2] : [2] : [2] : [2] : [2] : [2];

  switch ($var434[0]) {
    case 0:
      break;

    case 1:
      error_1(new NumberedError(SR.tcNamespaceCannotContainValues(), m));
      break;

    case 2:
      error_1(new NumberedError(SR.tcNamespaceCannotContainValues(), binds.head.RangeOfHeadPat));
      break;
  }
}
export function TcModuleOrNamespaceElementNonMutRec(cenv_1, parent, typeNames, scopem, env, synDecl) {
  return function (builder_) {
    return builder_.Delay(function () {
      cenv_1.synArgNameGenerator.Reset();
      const tpenv = emptyUnscopedTyparEnv;
      return builder_.TryWith(builder_.Delay(function () {
        const matchValue = ElimModuleDoBinding(synDecl);

        switch (matchValue.tag) {
          case 5:
            const patternInput = TcExceptionDeclarations.TcExnDefn(cenv_1, env, parent, matchValue.data[0], scopem);
            return builder_.Return([[function (e) {
              return new List(new ModuleOrNamespaceExpr(4, [true, ofArray([patternInput[1]]), map_1(function (arg0) {
                return new ModuleOrNamespaceBinding(0, arg0);
              }, patternInput[0]), matchValue.data[1]]), e);
            }, new List()], patternInput[2], patternInput[2]]);

          case 4:
            const scopem_1 = unionRanges(matchValue.data[1], scopem);
            const mutRecDefns = map_1(function (arg0_1) {
              return new MutRecShape(0, arg0_1);
            }, matchValue.data[0]);
            const patternInput_1 = TcDeclarations.TcMutRecDefinitions(cenv_1, env, parent, typeNames, tpenv, matchValue.data[1], scopem_1, null, mutRecDefns);

            const exprfWithEscapeCheck = function (e_1) {
              TcMutRecDefnsEscapeCheck(patternInput_1[0], env);
              return new List(TcMutRecDefsFinish(cenv_1, patternInput_1[0], matchValue.data[1]), e_1);
            };

            return builder_.Return([[exprfWithEscapeCheck, new List()], patternInput_1[1], patternInput_1[1]]);

          case 6:
            const mp = matchValue.data[0].data[0];
            const scopem_2 = unionRanges(matchValue.data[1].EndRange, scopem);
            const env_1 = TcOpenDecl(cenv_1.tcSink, cenv_1.g, cenv_1.amap, matchValue.data[1], scopem_2, env, mp);
            return builder_.Return([[function (e_2) {
              return e_2;
            }, new List()], env_1, env_1]);

          case 2:
            if (parent.tag === 0) {
              const containerInfo = ModuleOrNamespaceContainerInfo(parent.data);

              if (matchValue.data[0]) {
                const scopem_3 = unionRanges(matchValue.data[2], scopem);
                const binds = map_1(function (bind) {
                  return new RecDefnBindingInfo(0, [containerInfo, new NewSlotsOK(1), new DeclKind(0), bind]);
                }, matchValue.data[1]);
                const patternInput_2 = TcLetrec(new OverridesOK(1), cenv_1, env, tpenv, binds, matchValue.data[2], scopem_3);
                return builder_.Return([[function (e_3) {
                  return new List(new ModuleOrNamespaceExpr(4, [true, new List(), map_1(function (arg0_2) {
                    return new ModuleOrNamespaceBinding(0, arg0_2);
                  }, patternInput_2[0]), matchValue.data[2]]), e_3);
                }, new List()], patternInput_2[1], patternInput_2[1]]);
              } else {
                const patternInput_3 = TcLetBindings(cenv_1, env, containerInfo, new DeclKind(0), tpenv, matchValue.data[1], matchValue.data[2], scopem);
                return builder_.Return([[function (e_4) {
                  return append(patternInput_3[0], e_4);
                }, new List()], patternInput_3[1], patternInput_3[1]]);
              }
            } else {
              CheckLetOrDoInNamespace(matchValue.data[1], matchValue.data[2]);
              return builder_.Return([[function (x) {
                return x;
              }, new List()], env, env]);
            }

          case 3:
            return builder_.ReturnFrom((() => {
              throw new Error("unreachable");
            })());

          case 7:
            const patternInput_4 = TcAttributesWithPossibleTargets(false, cenv_1, env, AttributeTargets.Top, matchValue.data[0]);
            return builder_.Return([[function (e_5) {
              return e_5;
            }, patternInput_4[0]], env, env]);

          case 8:
            return builder_.Return([[function (e_6) {
              return e_6;
            }, new List()], env, env]);

          case 1:
            if (matchValue.data[1]) {
              const modDecl = new SynModuleDecl(1, [matchValue.data[0], false, matchValue.data[2], matchValue.data[3], matchValue.data[4]]);
              return builder_.ReturnFrom(TcModuleOrNamespaceElementsMutRec(cenv_1, parent, typeNames, matchValue.data[4], env, null, ofArray([modDecl])));
            } else {
              const id = ComputeModuleName(matchValue.data[0].data[3]);
              const modAttrs = TcAttributes(cenv_1, env, AttributeTargets.ModuleDecl, matchValue.data[0].data[0]);
              const modKind = EstablishTypeDefinitionCores.ComputeModuleOrNamespaceKind(cenv_1.g, true, typeNames, modAttrs, id.idText);
              const modName = EstablishTypeDefinitionCores.AdjustModuleName(modKind, id.idText);
              CheckForDuplicateConcreteType(env, modName, matchValue.data[0].data[7]);
              CheckForDuplicateModule(env, id.idText, id.idRange);
              const patternInput_5 = ComputeAccessAndCompPath(env, null, id.idRange, matchValue.data[0].data[6], null, parent);
              const endm = matchValue.data[4].EndRange;
              const id_1 = ident(modName, id.idRange);
              CheckNamespaceModuleOrTypeName(cenv_1.g, id_1);
              const patternInput_6 = MakeInnerEnv(env, id_1, modKind);
              const mspec = NewModuleOrNamespace(env.eCompPath, patternInput_5[0], id_1, matchValue.data[0].data[4].ToXmlDoc(), modAttrs, new MaybeLazy(0, NewEmptyModuleOrNamespaceType(modKind)));
              return builder_.Bind(TcModuleOrNamespaceElements(cenv_1, new ParentRef(0, mkLocalModRef(mspec)), endm, patternInput_6[0], matchValue.data[0].data[4], null, matchValue.data[2]), function (_arg1) {
                mspec.entity_modul_contents = new MaybeLazy(0, patternInput_6[1].contents);
                const modDefn = new ModuleOrNamespaceExpr(4, [false, new List(), ofArray([new ModuleOrNamespaceBinding(1, [mspec, _arg1[0]])]), matchValue.data[4]]);
                PublishModuleDefn(cenv_1, env, mspec);
                const env_2 = AddLocalSubModuleAndReport(cenv_1.tcSink, scopem, cenv_1.g, cenv_1.amap, matchValue.data[4], env, mspec);
                const envAtEnd = matchValue.data[3] ? _arg1[2] : env_2;
                return builder_.Return([[function (modDefs) {
                  return new List(modDefn, modDefs);
                }, _arg1[1]], env_2, envAtEnd]);
              });
            }

          case 9:
            const xml = matchValue.data.data[4];
            const vis = matchValue.data.data[6];
            const m = matchValue.data.data[7];
            const longId = matchValue.data.data[0];
            const isRec = matchValue.data.data[1];
            const isModule = matchValue.data.data[2];
            const defs = matchValue.data.data[3];
            const attribs = matchValue.data.data[5];
            return builder_.Combine(progress.contents ? (dprintn("Typecheck implementation " + textOfLid(longId)), builder_.Zero()) : builder_.Zero(), builder_.Delay(function () {
              const endm_1 = m.EndRange;

              for (let id_2 of longId) {
                CheckNamespaceModuleOrTypeName(cenv_1.g, id_2);
              }

              let patternInput_8;

              if (isModule) {
                const patternInput_7 = List_1.frontAndBack(longId);
                const modDecl_1 = ofArray([new SynModuleDecl(1, [new SynComponentInfo(0, [attribs, new List(), new List(), ofArray([patternInput_7[1]]), xml, false, vis, m]), false, defs, true, m])]);
                patternInput_8 = [patternInput_7[0], modDecl_1];
              } else {
                patternInput_8 = [longId, defs];
              }

              const envNS = LocateEnv(cenv_1.topCcu, env, patternInput_8[0]);
              const envNS_1 = ImplicitlyOpenOwnNamespace(cenv_1.tcSink, cenv_1.g, cenv_1.amap, m, patternInput_8[0], envNS);
              const mtypNS = envNS_1.eModuleOrNamespaceTypeAccumulator.contents;
              const patternInput_9 = BuildRootModuleType(patternInput_8[0], envNS_1.eCompPath, mtypNS);
              const mspecNSOpt = tryHead(patternInput_9[1]);
              iterate(function (mspec_1) {
                const modref = mkLocalModRef(mspec_1);
                const item = new Item(18, ofArray([modref]));
                CallNameResolutionSink(cenv_1.tcSink, mspec_1.Range, env.NameEnv, item, item, emptyTyparInst, new ItemOccurence(0), env.DisplayEnv, env.eAccessRights);
              }, patternInput_9[1]);
              const envNS_2 = isRec ? AddLocalRootModuleOrNamespace(cenv_1.tcSink, cenv_1.g, cenv_1.amap, m, envNS_1, patternInput_9[0]) : envNS_1;
              const nsInfo = [mspecNSOpt, envNS_2.eModuleOrNamespaceTypeAccumulator];
              const mutRecNSInfo = isRec ? nsInfo : null;
              return builder_.Bind(TcModuleOrNamespaceElements(cenv_1, parent, endm_1, envNS_2, xml, mutRecNSInfo, patternInput_8[1]), function (_arg2) {
                MutRecBindingChecking.TcMutRecDefns_UpdateNSContents(nsInfo);
                let env_5;

                if (patternInput_8[0].tail == null) {
                  env_5 = _arg2[2];
                } else {
                  const env_3 = AddLocalRootModuleOrNamespace(cenv_1.tcSink, cenv_1.g, cenv_1.amap, m, env, patternInput_9[0]);
                  let env_4;
                  const matchValue_1 = TryStripPrefixPath(cenv_1.g, patternInput_8[0]);

                  if (matchValue_1 == null) {
                    env_4 = env_3;
                  } else {
                    const p = getValue(matchValue_1)[0];
                    env_4 = TcOpenDecl(cenv_1.tcSink, cenv_1.g, cenv_1.amap, m.EndRange, m.EndRange, env_3, ofArray([p]));
                  }

                  env_4.eModuleOrNamespaceTypeAccumulator.contents = CombineCcuContentFragments(m, ofArray([env_4.eModuleOrNamespaceTypeAccumulator.contents, patternInput_9[0]]));
                  env_5 = env_4;
                }

                const modExprRoot = BuildRootModuleExpr(patternInput_8[0], envNS_2.eCompPath, _arg2[0]);
                return builder_.Return([[function (modExprs) {
                  return new List(modExprRoot, modExprs);
                }, _arg2[1]], env_5, _arg2[2]]);
              });
            }));

          default:
            const env_6 = MutRecBindingChecking.TcModuleAbbrevDecl(cenv_1, scopem, env, matchValue.data[0], matchValue.data[1], matchValue.data[2]);
            return builder_.Return([[function (e_7) {
              return e_7;
            }, new List()], env_6, env_6]);
        }
      }), function (_arg3) {
        errorRecovery(_arg3, synDecl.Range);
        return builder_.Return([[function (e_8) {
          return e_8;
        }, new List()], env, env]);
      });
    });
  }(eventually);
}
export function TcModuleOrNamespaceElementsNonMutRec(cenv_1, parent, typeNames, endm, defsSoFar, env, envAtEnd, moreDefs) {
  return function (builder_) {
    return builder_.Delay(function () {
      if (moreDefs.tail == null) {
        return builder_.Return([reverse(defsSoFar), envAtEnd]);
      } else {
        const scopem = moreDefs.tail.tail == null ? unionRanges(moreDefs.head.Range, endm) : unionRanges(moreDefs.tail.head.Range, endm);
        return builder_.Bind(TcModuleOrNamespaceElementNonMutRec(cenv_1, parent, typeNames, scopem, env, moreDefs.head), function (_arg4) {
          return builder_.ReturnFrom(TcModuleOrNamespaceElementsNonMutRec(cenv_1, parent, typeNames, endm, new List(_arg4[0], defsSoFar), _arg4[1], _arg4[2], moreDefs.tail));
        });
      }
    });
  }(eventually);
}
export function TcModuleOrNamespaceElementsMutRec(cenv_1, parent, typeNames, endm, envInitial, mutRecNSInfo, defs) {
  return function (builder_) {
    return builder_.Delay(function () {
      const m = defs.tail == null ? endm : function (list) {
        return reduce(function (arg00_, arg10_) {
          return unionRanges(arg00_, arg10_);
        }, list);
      }(map_1(function (d) {
        return d.Range;
      }, defs));
      const scopem = foldBack(function (h, m_1) {
        return unionRanges(h.Range, m_1);
      }, defs, endm);
      let patternInput_1;

      const loop = function (isNamespace, attrs, defs_1) {
        return List_1.collectFold(function (tupledArg, def) {
          const matchValue = ElimModuleDoBinding(def);

          switch (matchValue.tag) {
            case 2:
              let binds;

              if (isNamespace) {
                CheckLetOrDoInNamespace(matchValue.data[1], matchValue.data[2]);
                binds = new List();
              } else if (matchValue.data[0]) {
                binds = ofArray([new MutRecShape(1, matchValue.data[1])]);
              } else {
                binds = map_1($var435 => new MutRecShape(1, singleton_1($var435)), matchValue.data[1]);
              }

              return [binds, [false, false, tupledArg[2]]];

            case 1:
              if (matchValue.data[1]) {
                warning(new _Error(SR.tcRecImplied(), matchValue.data[0].Range));
              }

              const patternInput = loop(false, tupledArg[2], matchValue.data[2]);
              const attrs_1 = patternInput[1][2];
              const decls = ofArray([new MutRecShape(2, [matchValue.data[0], patternInput[0]])]);
              return [decls, [false, false, attrs_1]];

            case 6:
              const lid = matchValue.data[0].data[0];

              if (!tupledArg[0]) {
                errorR(new _Error(SR.tcOpenFirstInMutRec(), matchValue.data[1]));
              }

              const decls_1 = ofArray([new MutRecShape(4, new MutRecDataForOpen(0, [lid, matchValue.data[1]]))]);
              return [decls_1, [tupledArg[0], tupledArg[1], tupledArg[2]]];

            case 5:
              const repr = matchValue.data[0].data[0];
              const members = matchValue.data[0].data[1];
              const id = repr.data[1].data[1];
              const _args = repr.data[1].data[2];
              const compInfo = new SynComponentInfo(0, [repr.data[0], new List(), new List(), ofArray([id]), repr.data[3], false, repr.data[4], id.idRange]);
              const decls_2 = ofArray([new MutRecShape(0, new SynTypeDefn(0, [compInfo, new SynTypeDefnRepr(2, repr), members, repr.data[5]]))]);
              return [decls_2, [false, false, tupledArg[2]]];

            case 8:
              return [new List(), [tupledArg[0], tupledArg[1], tupledArg[2]]];

            case 7:
              return [new List(), [false, false, matchValue.data[0]]];

            case 0:
              if (!tupledArg[1]) {
                errorR(new _Error(SR.tcModuleAbbrevFirstInMutRec(), matchValue.data[2]));
              }

              const decls_3 = ofArray([new MutRecShape(3, new MutRecDataForModuleAbbrev(0, [matchValue.data[0], matchValue.data[1], matchValue.data[2]]))]);
              return [decls_3, [false, tupledArg[1], tupledArg[2]]];

            case 3:
              throw new Error("unreachable: SynModuleDecl.DoExpr - ElimModuleDoBinding");

            case 9:
              return error_1(new _Error(SR.tcUnsupportedMutRecDecl(), matchValue.Range));

            default:
              const decls_4 = map_1(function (arg0) {
                return new MutRecShape(0, arg0);
              }, matchValue.data[0]);
              return [decls_4, [false, false, tupledArg[2]]];
          }
        }, [true, true, attrs], defs_1);
      };

      patternInput_1 = loop(parent.tag === 0 ? false : true, new List(), defs);
      const synAttrs = patternInput_1[1][2];
      const tpenv = emptyUnscopedTyparEnv;
      const patternInput_2 = TcDeclarations.TcMutRecDefinitions(cenv_1, envInitial, parent, typeNames, tpenv, m, scopem, mutRecNSInfo, patternInput_1[0]);
      const patternInput_3 = TcAttributesWithPossibleTargets(false, cenv_1, patternInput_2[1], AttributeTargets.Top, synAttrs);

      const exprfWithEscapeCheck = function (modExprs) {
        TcMutRecDefnsEscapeCheck(patternInput_2[0], envInitial);
        const modExpr = TcMutRecDefsFinish(cenv_1, patternInput_2[0], m);
        return new List(modExpr, modExprs);
      };

      return builder_.Return([[exprfWithEscapeCheck, patternInput_3[0]], patternInput_2[1], patternInput_2[1]]);
    });
  }(eventually);
}
export function TcMutRecDefsFinish(cenv_1, defs, m) {
  const tycons = choose_1(function (_arg5) {
    const $var436 = _arg5.tag === 0 ? _arg5.data[0] != null ? [0, getValue(_arg5.data[0])] : [1] : [1];

    switch ($var436[0]) {
      case 0:
        return $var436[1];

      case 1:
        return null;
    }
  }, defs);
  const binds = collect(function (_arg6) {
    const $var437 = _arg6.tag === 3 ? [1] : _arg6.tag === 0 ? [2, _arg6.data[1]] : _arg6.tag === 1 ? [2, _arg6.data] : _arg6.tag === 2 ? [3] : [0];

    switch ($var437[0]) {
      case 0:
        return new List();

      case 1:
        return new List();

      case 2:
        return map_1(function (arg0) {
          return new ModuleOrNamespaceBinding(0, arg0);
        }, $var437[1]);

      case 3:
        const mtypeAcc = _arg6.data[0][0].data[0];
        const mspec = _arg6.data[0][0].data[1];
        const mexpr = TcMutRecDefsFinish(cenv_1, _arg6.data[1], m);
        mspec.entity_modul_contents = new MaybeLazy(0, mtypeAcc.contents);
        return ofArray([new ModuleOrNamespaceBinding(1, [mspec, mexpr])]);
    }
  }, defs);
  return new ModuleOrNamespaceExpr(4, [true, tycons, binds, m]);
}
export function TcModuleOrNamespaceElements(cenv_1, parent, endm, env, xml, mutRecNSInfo, defs) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.Combine(cenv_1.compilingCanonicalFslibModuleType ? (ensureCcuHasModuleOrNamespaceAtPath(cenv_1.topCcu, env.ePath, env.eCompPath, xml.ToXmlDoc()), builder_.Zero()) : builder_.Zero(), builder_.Delay(function () {
        const typeNames = EstablishTypeDefinitionCores.TypeNamesInNonMutRecDecls(defs);

        if (mutRecNSInfo == null) {
          return builder_.Bind(TcModuleOrNamespaceElementsNonMutRec(cenv_1, parent, typeNames, endm, new List(), env, env, defs), function (_arg8) {
            const mexpr = new ModuleOrNamespaceExpr(1, foldBack(function (tupledArg, x) {
              return tupledArg[0](x);
            }, _arg8[0], new List()));
            const topAttrsNew = foldBack(function (tupledArg_1, x_1) {
              return append(tupledArg_1[1], x_1);
            }, _arg8[0], new List());
            return builder_.Return([mexpr, topAttrsNew, _arg8[1]]);
          });
        } else {
          return builder_.Bind(TcModuleOrNamespaceElementsMutRec(cenv_1, parent, typeNames, endm, env, mutRecNSInfo, defs), function (_arg7) {
            const topAttrsNew_1 = _arg7[0][1];
            const exprf = _arg7[0][0];
            const mexpr_1 = new ModuleOrNamespaceExpr(1, exprf(new List()));
            return builder_.Return([mexpr_1, topAttrsNew_1, _arg7[2]]);
          });
        }
      }));
    });
  }(eventually);
}
export function ApplyAssemblyLevelAutoOpenAttributeToTcEnv(g, amap, ccu, scopem, env, p, root) {
  const warn = function () {
    warning(new _Error(SR.tcAttributeAutoOpenWasIgnored(p, ccu.AssemblyName), scopem));
    return env;
  };

  const p_1 = splitNamespace(p);

  if (p_1.tail == null) {
    return warn();
  } else {
    const patternInput = List_1.frontAndBack(p_1);
    const modref = mkNonLocalTyconRef(mkNonLocalEntityRef(ccu, Array.from(patternInput[0])), patternInput[1]);
    const matchValue = modref.TryDeref;

    if (matchValue.tag === 0) {
      const openDecl = OpenDeclaration.Create(new List(), ofArray([modref]), scopem, false);
      return OpenModulesOrNamespaces(TcResultsSink.NoSink, g, amap, scopem, root, env, ofArray([modref]), openDecl);
    } else {
      return warn();
    }
  }
}
export function AddCcuToTcEnv(g, amap, scopem, env, assemblyName, ccu, autoOpens, internalsVisible) {
  const env_1 = AddNonLocalCcu(g, amap, scopem, env, assemblyName, ccu, internalsVisible);
  let autoOpens_2;
  const autoOpens_1 = map_1(function (p) {
    return [p, false];
  }, autoOpens);

  if (ccuEq(ccu, g.fslibCcu)) {
    autoOpens_2 = new List(["Microsoft", true], autoOpens_1);
  } else {
    autoOpens_2 = autoOpens_1;
  }

  const env_3 = fold(function (env_2, tupledArg) {
    return ApplyAssemblyLevelAutoOpenAttributeToTcEnv(g, amap, ccu, scopem, env_2, tupledArg[0], tupledArg[1]);
  }, env_1, autoOpens_2);
  return env_3;
}
export function CreateInitialTcEnv(g, amap, scopem, assemblyName, ccus) {
  return fold(function (env, tupledArg) {
    try {
      return AddCcuToTcEnv(g, amap, scopem, env, assemblyName, tupledArg[0], tupledArg[1], tupledArg[2]);
    } catch (e) {
      errorRecovery(e, scopem);
      return env;
    }
  }, emptyTcEnv(g), ccus);
}
export class TopAttribs {
  constructor(mainMethodAttrs, netModuleAttrs, assemblyAttrs) {
    this.mainMethodAttrs = mainMethodAttrs;
    this.netModuleAttrs = netModuleAttrs;
    this.assemblyAttrs = assemblyAttrs;
  }

  [_Symbol.reflection]() {
    return {
      type: "Microsoft.FSharp.Compiler.TypeChecker.TopAttribs",
      interfaces: ["FSharpRecord"],
      properties: {
        mainMethodAttrs: makeGeneric(List, {
          T: Attrib
        }),
        netModuleAttrs: makeGeneric(List, {
          T: Attrib
        }),
        assemblyAttrs: makeGeneric(List, {
          T: Attrib
        })
      }
    };
  }

}
setType("Microsoft.FSharp.Compiler.TypeChecker.TopAttribs", TopAttribs);
export const EmptyTopAttrs = new TopAttribs(new List(), new List(), new List());
export function CombineTopAttrs(topAttrs1, topAttrs2) {
  return new TopAttribs(append(topAttrs1.mainMethodAttrs, topAttrs2.mainMethodAttrs), append(topAttrs1.netModuleAttrs, topAttrs2.netModuleAttrs), append(topAttrs1.assemblyAttrs, topAttrs2.assemblyAttrs));
}
export function IterTyconsOfModuleOrNamespaceType(f, mty) {
  QueueListModule.iter(function (tycon) {
    f(tycon);
  }, mty.AllEntities);
  iterate(function (v) {
    IterTyconsOfModuleOrNamespaceType(f, v.ModuleOrNamespaceType);
  }, mty.ModuleAndNamespaceDefinitions);
}
export function ApplyDefaults(cenv_1, g, denvAtEnd, m, mexpr, extraAttribs) {
  try {
    const unsolved = UnsolvedTyparsOfModuleDef(g, cenv_1.amap, denvAtEnd, mexpr, extraAttribs);
    GeneralizationHelpers.CanonicalizePartialInferenceProblem(cenv_1, denvAtEnd, m, unsolved);

    const applyDefaults = function (priority) {
      iterate(function (tp) {
        if (!tp.IsSolved) {
          iterate(function (tpc) {
            const $var438 = tpc.tag === 1 ? tpc.data[0] === priority ? [0, tpc.data[2], tpc.data[0], tpc.data[1]] : [1] : [1];

            switch ($var438[0]) {
              case 0:
                const ty1 = mkTyparTy(tp);

                if (!tp.IsSolved ? !typeEquiv(cenv_1.g, ty1, $var438[3]) : false) {
                  const csenv = MakeConstraintSolverEnv(new ContextInfo(0), cenv_1.css, $var438[1], denvAtEnd);
                  RaiseOperationResult(TryD(function () {
                    return SolveTyparEqualsTyp(csenv, 0, $var438[1], new OptionalTrace(0), ty1, $var438[3]);
                  }, function (e) {
                    solveTypAsError(cenv_1, denvAtEnd, $var438[1], ty1);
                    return ErrorD(new ErrorFromApplyingDefault(g, denvAtEnd, tp, $var438[3], e, $var438[1]));
                  }));
                }

                break;

              case 1:
                break;
            }
          }, tp.Constraints);
        }
      }, unsolved);
    };

    for (let priority_1 = 10; priority_1 >= 0; priority_1--) {
      applyDefaults(priority_1);
    }

    iterate(function (tp_1) {
      if (!tp_1.IsSolved) {
        if (!tp_1.StaticReq.Equals(new TyparStaticReq(0))) {
          ChooseTyparSolutionAndSolve(cenv_1.css, denvAtEnd, tp_1);
        }
      }
    }, unsolved);
  } catch (e_1) {
    errorRecovery(e_1, m);
  }
}
export function CheckValueRestriction(denvAtEnd, rootSigOpt, implFileTypePriorToSig, m) {
  if (rootSigOpt == null) {
    const check = function (mty) {
      var matchValue;
      const inputSequence = mty.AllValsAndMembers;

      for (let v of inputSequence) {
        const ftyvs = ZsetModule.elements(freeInVal(CollectTyparsNoCaching, v).FreeTypars);

        if ((!v.IsCompilerGenerated ? !exists_1(function (tp) {
          return tp.IsFromError;
        }, ftyvs) : false) ? (matchValue = v.ValReprInfo, matchValue != null ? getValue(matchValue).HasNoArgs : true) : false) {
          if (ftyvs.tail != null) {
            errorR(new ValueRestriction(denvAtEnd, false, v, ftyvs.head, v.Range));
          }
        }
      }

      iterate(function (v_1) {
        check(v_1.ModuleOrNamespaceType);
      }, mty.ModuleAndNamespaceDefinitions);
    };

    try {
      check(implFileTypePriorToSig);
    } catch (e) {
      errorRecovery(e, m);
    }
  }
}
export function SolveInternalUnknowns(g, cenv_1, denvAtEnd, mexpr, extraAttribs) {
  const unsolved = UnsolvedTyparsOfModuleDef(g, cenv_1.amap, denvAtEnd, mexpr, extraAttribs);
  iterate(function (tp) {
    if (!tp.Rigidity.Equals(new TyparRigidity(0)) ? !tp.IsSolved : false) {
      ChooseTyparSolutionAndSolve(cenv_1.css, denvAtEnd, tp);
    }
  }, unsolved);
}
export function CheckModuleSignature(g, cenv_1, m, denvAtEnd, rootSigOpt, implFileTypePriorToSig, implFileSpecPriorToSig, mexpr) {
  var objectArg;

  if (rootSigOpt != null) {
    const denv = new DisplayEnv(denvAtEnd.includeStaticParametersInTypeNames, denvAtEnd.openTopPathsSorted, denvAtEnd.openTopPathsRaw, denvAtEnd.shortTypeNames, denvAtEnd.suppressNestedTypes, denvAtEnd.maxMembers, denvAtEnd.showObsoleteMembers, denvAtEnd.showHiddenMembers, denvAtEnd.showTyparBinding, true, denvAtEnd.suppressInlineKeyword, denvAtEnd.suppressMutableKeyword, denvAtEnd.showMemberContainers, denvAtEnd.shortConstraints, denvAtEnd.useColonForReturnType, denvAtEnd.showAttributes, denvAtEnd.showOverrides, denvAtEnd.showConstraintTyparAnnotations, denvAtEnd.abbreviateAdditionalConstraints, denvAtEnd.showTyparDefaultConstraints, denvAtEnd.g, denvAtEnd.contextAccessibility, denvAtEnd.generatedValueLayout);

    try {
      if (!CheckNamesOfModuleOrNamespace(denv, mkLocalTyconRef(implFileSpecPriorToSig), getValue(rootSigOpt))) {
        throw new ReportedError(null);
      }

      const patternInput = ComputeRemappingFromInferredSignatureToExplicitSignature(cenv_1.g, implFileTypePriorToSig, getValue(rootSigOpt));
      let aenv;
      const inputRecord = TypeEquivEnv.Empty;
      const EquivTycons = TyconRefMap.OfList(patternInput[0].mrpiEntities);
      aenv = new TypeEquivEnv(inputRecord.EquivTypars, EquivTycons);

      if (!(objectArg = new Checker(cenv_1.g, cenv_1.amap, denv, patternInput[0], true), function (arg00, arg10, arg20) {
        return objectArg.CheckSignature(arg00, arg10, arg20);
      })(aenv, mkLocalModRef(implFileSpecPriorToSig), getValue(rootSigOpt))) {
        throw new ReportedError(null);
      }
    } catch (e) {
      errorRecovery(e, m);
    }

    return new ModuleOrNamespaceExprWithSig(0, [getValue(rootSigOpt), mexpr, m]);
  } else {
    const implFileTypePriorToSigCopied = copyModuleOrNamespaceType(g, new ValCopyFlag(0), implFileTypePriorToSig);
    return new ModuleOrNamespaceExprWithSig(0, [implFileTypePriorToSigCopied, mexpr, m]);
  }
}
export function TypeCheckOneImplFile(g, niceNameGen, amap, topCcu, checkForErrors, conditionalDefines, tcSink, env, rootSigOpt, _arg1) {
  return function (builder_) {
    return builder_.Delay(function () {
      const cenv_1 = cenv.Create(g, _arg1.data[1], niceNameGen, amap, topCcu, false, rootSigOpt != null, conditionalDefines, tcSink, function (vref, vrefFlags, vrefTypeInst, m) {
        return LightweightTcValForUsingInBuildMethodCall(g, vref, vrefFlags, vrefTypeInst, m);
      });
      const patternInput = MakeInitialEnv(env);
      const defs = toList(delay(function () {
        return map_2(function (x) {
          return new SynModuleDecl(9, x);
        }, _arg1.data[5]);
      }));
      return builder_.Bind(TcModuleOrNamespaceElements(cenv_1, new ParentRef(1), _arg1.data[2].Range, patternInput[0], new PreXmlDoc(2), null, defs), function (_arg2) {
        const implFileTypePriorToSig = patternInput[1].contents;
        let topAttrs;
        const patternInput_1 = partition(function (tupledArg) {
          return (tupledArg[0] & 64) !== 0;
        }, _arg2[1]);
        const patternInput_2 = partition(function (tupledArg_1) {
          return (tupledArg_1[0] & 1) !== 0;
        }, patternInput_1[1]);
        const patternInput_3 = partition(function (tupledArg_2) {
          return (tupledArg_2[0] & 2) !== 0;
        }, patternInput_2[1]);
        topAttrs = new TopAttribs(map_1(function (tuple) {
          return tuple[1];
        }, patternInput_1[0]), map_1(function (tuple_1) {
          return tuple_1[1];
        }, patternInput_3[0]), map_1(function (tuple_2) {
          return tuple_2[1];
        }, patternInput_2[0]));
        const denvAtEnd = _arg2[2].DisplayEnv;
        const m_1 = _arg1.data[2].Range;
        const implFileSpecPriorToSig = wrapModuleOrNamespaceType(_arg1.data[2].Id, compPathOfCcu(topCcu), implFileTypePriorToSig);
        const extraAttribs = append(topAttrs.mainMethodAttrs, append(topAttrs.netModuleAttrs, topAttrs.assemblyAttrs));
        conditionallySuppressErrorReporting(checkForErrors(), function () {
          ApplyDefaults(cenv_1, g, denvAtEnd, m_1, _arg2[0], extraAttribs);
        });
        conditionallySuppressErrorReporting(checkForErrors(), function () {
          var nenv;

          try {
            IterTyconsOfModuleOrNamespaceType((nenv = _arg2[2].NameEnv, function (tycon) {
              FinalTypeDefinitionChecksAtEndOfInferenceScope(cenv_1.infoReader, nenv, cenv_1.tcSink, true, denvAtEnd, tycon);
            }), implFileTypePriorToSig);
          } catch (e) {
            errorRecovery(e, m_1);
          }
        });
        conditionallySuppressErrorReporting(checkForErrors(), function () {
          CheckValueRestriction(denvAtEnd, rootSigOpt, implFileTypePriorToSig, m_1);
        });
        conditionallySuppressErrorReporting(checkForErrors(), function () {
          SolveInternalUnknowns(g, cenv_1, denvAtEnd, _arg2[0], extraAttribs);
        });
        const implFileExprAfterSig = conditionallySuppressErrorReporting(checkForErrors(), function () {
          return CheckModuleSignature(g, cenv_1, m_1, denvAtEnd, rootSigOpt, implFileTypePriorToSig, implFileSpecPriorToSig, _arg2[0]);
        });
        conditionallySuppressErrorReporting(checkForErrors(), function () {
          const inputSequence = cenv_1.postInferenceChecks;

          for (let check of inputSequence) {
            try {
              check();
            } catch (e_1) {
              errorRecovery(e_1, m_1);
            }
          }
        });
        const hasExplicitEntryPoint = conditionallySuppressErrorReporting(checkForErrors(), function () {
          try {
            const reportErrors = !checkForErrors();
            return CheckTopImpl(g, cenv_1.amap, reportErrors, cenv_1.infoReader, env.eInternalsVisibleCompPaths, cenv_1.topCcu, _arg2[2].DisplayEnv, implFileExprAfterSig, extraAttribs, _arg1.data[6]);
          } catch (e_2) {
            errorRecovery(e_2, m_1);
            return false;
          }
        });
        const implFile = new TypedImplFile(0, [_arg1.data[2], _arg1.data[3], implFileExprAfterSig, hasExplicitEntryPoint, _arg1.data[1]]);
        return builder_.Return([topAttrs, implFile, implFileTypePriorToSig, _arg2[2], cenv_1.createsGeneratedProvidedTypes]);
      });
    });
  }(eventually);
}
export function TypeCheckOneSigFile(g, niceNameGen, amap, topCcu, checkForErrors, conditionalDefines, tcSink, tcEnv, _arg1) {
  return function (builder_) {
    return builder_.Delay(function () {
      const cenv_1 = cenv.Create(g, false, niceNameGen, amap, topCcu, true, false, conditionalDefines, tcSink, function (vref, vrefFlags, vrefTypeInst, m) {
        return LightweightTcValForUsingInBuildMethodCall(g, vref, vrefFlags, vrefTypeInst, m);
      });
      const patternInput = MakeInitialEnv(tcEnv);
      const specs = toList(delay(function () {
        return map_2(function (x) {
          return new SynModuleSigDecl(7, x);
        }, _arg1.data[4]);
      }));
      return builder_.Bind(TcSignatureElements(cenv_1, new ParentRef(1), _arg1.data[1].Range, patternInput[0], new PreXmlDoc(2), null, specs), function (_arg2) {
        const sigFileType = patternInput[1].contents;
        return builder_.Combine(!checkForErrors() ? builder_.TryWith(builder_.Delay(function () {
          var nenv;
          var denv;
          IterTyconsOfModuleOrNamespaceType((nenv = _arg2.NameEnv, denv = _arg2.DisplayEnv, function (tycon) {
            FinalTypeDefinitionChecksAtEndOfInferenceScope(cenv_1.infoReader, nenv, cenv_1.tcSink, false, denv, tycon);
          }), sigFileType);
          return builder_.Zero();
        }), function (_arg3) {
          errorRecovery(_arg3, _arg1.data[1].Range);
          return builder_.Zero();
        }) : builder_.Zero(), builder_.Delay(function () {
          return builder_.Return([_arg2, sigFileType, cenv_1.createsGeneratedProvidedTypes]);
        }));
      });
    });
  }(eventually);
}